
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>NWB File Conversion Tutorial</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-07-22"><meta name="DC.source" content="convertTrials.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>NWB File Conversion Tutorial</h1><!--introduction--><p>How to convert trial-based experimental data to the Neurodata Without Borders file format using MatNWB. This example uses the <a href="https://crcns.org/data-sets/motor-cortex/alm-3">CRCNS ALM-3</a> data set.  Information on how to download the data can be found on the <a href="https://crcns.org/data-sets/motor-cortex/download">CRCNS Download Page</a>.  One should first familiarize themselves with the file format, which can be found on the <a href="https://crcns.org/data-sets/motor-cortex/alm-3/about-alm-3">ALM-3 About Page</a> under the Documentation files.</p><pre>author: Lawrence Niu
contact: lawrence@vidriotech.com
last updated: Jan 11, 2019</pre><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Script Configuration</a></li><li><a href="#4">General Information</a></li><li><a href="#7">The ALM-3 File Structure</a></li><li><a href="#8">Metadata</a></li><li><a href="#15">Analysis Data Structure</a></li><li><a href="#16">Hashes</a></li><li><a href="#25">Raw Acquisition Data</a></li><li><a href="#26">Export</a></li></ul></div><h2 id="1">Script Configuration</h2><p>The following details configuration parameters specific to the publishing script, and can be skipped when implementing your own conversion. The parameters can be changed to fit any of the available sessions.</p><pre class="codeinput">animal = <span class="string">'ANM255201'</span>;
session = <span class="string">'20141125'</span>;

identifier = [animal <span class="string">'_'</span> session];

metadata_loc = fullfile(<span class="string">'data'</span>,<span class="string">'metadata'</span>, [<span class="string">'meta_data_'</span> identifier <span class="string">'.mat'</span>]);
datastructure_loc = fullfile(<span class="string">'data'</span>,<span class="string">'data_structure_files'</span>,<span class="keyword">...</span>
    [<span class="string">'data_structure_'</span> identifier <span class="string">'.mat'</span>]);
rawdata_loc = fullfile(<span class="string">'data'</span>, <span class="string">'RawVoltageTraces'</span>, [identifier <span class="string">'.tar'</span>]);
</pre><p>The animal and session specifier can be changed with the <tt>animal</tt> and <tt>session</tt> variable name respectively.  <tt>metadata_loc</tt>, <tt>datastructure_loc</tt>, and <tt>rawdata_loc</tt> should refer to the metadata .mat file, the data structure .mat file, and the raw .tar file.</p><pre class="codeinput">outloc = <span class="string">'out'</span>;

<span class="keyword">if</span> 7 ~= exist(outloc, <span class="string">'dir'</span>)
    mkdir(outloc);
<span class="keyword">end</span>

source_file = [mfilename() <span class="string">'.m'</span>];
[~, source_script, ~] = fileparts(source_file);
</pre><p>The NWB file will be saved in the output directory indicated by <tt>outdir</tt></p><h2 id="4">General Information</h2><pre class="codeinput">nwb = NwbFile();
nwb.identifier = identifier;
nwb.general_source_script = source_script;
nwb.general_source_script_file_name = source_file;
nwb.general_lab = <span class="string">'Svoboda'</span>;
nwb.general_keywords = {<span class="string">'Network models'</span>, <span class="string">'Premotor cortex'</span>, <span class="string">'Short-term memory'</span>};
nwb.general_institution = [<span class="string">'Janelia Research Campus,'</span><span class="keyword">...</span>
    <span class="string">' Howard Huges Medical Institute, Ashburn, Virginia 20147, USA'</span>];
nwb.general_related_publications = <span class="keyword">...</span>
    [<span class="string">'Li N, Daie K, Svoboda K, Druckmann S (2016).'</span>,<span class="keyword">...</span>
    <span class="string">' Robust neuronal dynamics in premotor cortex during motor planning.'</span>,<span class="keyword">...</span>
    <span class="string">' Nature. 7600:459-64. doi: 10.1038/nature17643'</span>];
nwb.general_stimulus = <span class="string">'photostim'</span>;
nwb.general_protocol = <span class="string">'IACUC'</span>;
nwb.general_surgery = [<span class="string">'Mice were prepared for photoinhibition and '</span>,<span class="keyword">...</span>
    <span class="string">'electrophysiology with a clear-skull cap and a headpost. '</span>,<span class="keyword">...</span>
    <span class="string">'The scalp and periosteum over the dorsal surface of the skull were removed. '</span>,<span class="keyword">...</span>
    <span class="string">'A layer of cyanoacrylate adhesive (Krazy glue, Elmer''s Products Inc.) '</span>,<span class="keyword">...</span>
    <span class="string">'was directly applied to the intact skull. A custom made headpost '</span>,<span class="keyword">...</span>
    <span class="string">'was placed on the skull with its anterior edge aligned with the suture lambda '</span>,<span class="keyword">...</span>
    <span class="string">'(approximately over cerebellum) and cemented in place '</span>,<span class="keyword">...</span>
    <span class="string">'with clear dental acrylic (Lang Dental Jet Repair Acrylic; 1223-clear). '</span>,<span class="keyword">...</span>
    <span class="string">'A thin layer of clear dental acrylic was applied over the cyanoacrylate adhesive '</span>,<span class="keyword">...</span>
    <span class="string">'covering the entire exposed skull, '</span>,<span class="keyword">...</span>
    <span class="string">'followed by a thin layer of clear nail polish (Electron Microscopy Sciences, 72180).'</span>];
nwb.session_description = sprintf(<span class="string">'Animal `%s` on Session `%s`'</span>, animal, session);
</pre><p>All properties with the prefix <tt>general</tt> contain context for the entire experiment such as lab, institution, and experimentors.  For session-delimited data from the same experiment, these fields will all be the same.  Note that most of this information was pulled from the publishing paper and not from any of the downloadable data.</p><p>The only required property is the <tt>identifier</tt>, which distinguishes one session from another within an experiment.  In our case, the ALM-3 data uses a combination of session date and animal ID.</p><h2 id="7">The ALM-3 File Structure</h2><p>Each ALM-3 session has three files: a metadata .mat file describing the experiment, a data structures .mat file containing analyzed data, and a raw .tar archive containing multiple raw electrophysiology data separated by trial as .mat files. All files will be merged into a single NWB file.</p><h2 id="8">Metadata</h2><p>ALM-3 Metadata contains information about the reference times, experimental context, methodology, as well as details of the electrophysiology, optophysiology, and behavioral portions of the experiment.  A vast majority of these details are placed in <tt>general</tt> prefixed properties in NWB.</p><pre class="codeinput">fprintf(<span class="string">'Processing Meta Data from `%s`\n'</span>, metadata_loc);
loaded = load(metadata_loc, <span class="string">'meta_data'</span>);
meta = loaded.meta_data;

<span class="comment">%experiment-specific treatment for animals with the ReaChR gene modification</span>
isreachr = any(cell2mat(strfind(meta.animalGeneModification, <span class="string">'ReaChR'</span>)));

<span class="comment">%sessions are separated by date of experiment.</span>
nwb.general_session_id = meta.dateOfExperiment;

<span class="comment">%ALM-3 data start time is equivalent to the reference time.</span>
nwb.session_start_time = datetime([meta.dateOfExperiment meta.timeOfExperiment],<span class="keyword">...</span>
    <span class="string">'InputFormat'</span>, <span class="string">'yyyyMMddHHmmss'</span>);
nwb.timestamps_reference_time = nwb.session_start_time;

nwb.general_experimenter = strjoin(meta.experimenters, <span class="string">', '</span>);
</pre><pre class="codeoutput">Processing Meta Data from `data\metadata\meta_data_ANM255201_20141125.mat`
</pre><pre class="codeinput">nwb.general_subject = types.core.Subject(<span class="keyword">...</span>
    <span class="string">'species'</span>, meta.species{1}, <span class="keyword">...</span>
    <span class="string">'subject_id'</span>, meta.animalID{1}(1,:), <span class="keyword">...</span><span class="comment"> %weird case with duplicate Animal ID</span>
    <span class="string">'sex'</span>, meta.sex, <span class="keyword">...</span>
    <span class="string">'age'</span>, meta.dateOfBirth, <span class="keyword">...</span>
    <span class="string">'description'</span>, [<span class="keyword">...</span>
        <span class="string">'Whisker Config: '</span> strjoin(meta.whiskerConfig, <span class="string">', '</span>) newline<span class="keyword">...</span>
        <span class="string">'Animal Source: '</span> strjoin(meta.animalSource, <span class="string">', '</span>)]);
</pre><p>Ideally, if a raw data field does not correspond directly to a NWB field, one would create their own using a <a href="https://pynwb.readthedocs.io/en/latest/extensions.html">custom NWB extension class</a>. However, since these fields are mostly experimental annotations, we instead pack the extra values into the <tt>description</tt> field as a string.</p><pre class="codeinput"><span class="comment">%The formatStruct function simply prints the field and values given the struct.</span>
<span class="comment">%An optional cell array of field names specifies whitelist of fields to print.  This</span>
<span class="comment">%function is provided with this script in the tutorials directory.</span>
nwb.general_subject.genotype = formatStruct(<span class="keyword">...</span>
    meta, <span class="keyword">...</span>
    {<span class="string">'animalStrain'</span>; <span class="string">'animalGeneModification'</span>; <span class="string">'animalGeneCopy'</span>;<span class="keyword">...</span>
    <span class="string">'animalGeneticBackground'</span>});

weight = {};
<span class="keyword">if</span> ~isempty(meta.weightBefore)
    weight{end+1} = <span class="string">'weightBefore'</span>;
<span class="keyword">end</span>
<span class="keyword">if</span> ~isempty(meta.weightAfter)
    weight{end+1} = <span class="string">'weightAfter'</span>;
<span class="keyword">end</span>
weight = weight(~cellfun(<span class="string">'isempty'</span>, weight));
<span class="keyword">if</span> ~isempty(weight)
    nwb.general_subject.weight = formatStruct(meta, weight);
<span class="keyword">end</span>

<span class="comment">% general/experiment_description</span>
nwb.general_experiment_description = [<span class="keyword">...</span>
    formatStruct(meta, {<span class="string">'experimentType'</span>; <span class="string">'referenceAtlas'</span>}), <span class="keyword">...</span>
    sprintf(<span class="string">'\n'</span>), <span class="keyword">...</span>
    formatStruct(meta.behavior, {<span class="string">'task_keyword'</span>})];

<span class="comment">% Miscellaneous collection information from ALM-3 that didn't quite fit any NWB properties</span>
<span class="comment">% are stored in general/data_collection.</span>
nwb.general_data_collection = formatStruct(meta.extracellular,<span class="keyword">...</span>
    {<span class="string">'extracellularDataType'</span>;<span class="string">'cellType'</span>;<span class="string">'identificationMethod'</span>;<span class="string">'amplifierRolloff'</span>;<span class="keyword">...</span>
    <span class="string">'spikeSorting'</span>;<span class="string">'ADunit'</span>});

<span class="comment">% Device objects are essentially just a list of device names.  We store the probe</span>
<span class="comment">% and laser hardware names here.</span>
probetype = meta.extracellular.probeType{1};
probeSource = meta.extracellular.probeSource{1};
deviceName = [probetype <span class="string">' ('</span> probeSource <span class="string">')'</span>];
nwb.general_devices.set(deviceName,<span class="keyword">...</span>
    types.core.Device());

<span class="keyword">if</span> isreachr
    laserName = <span class="string">'laser-594nm (Cobolt Inc., Cobolt Mambo 100)'</span>;
<span class="keyword">else</span>
    laserName = <span class="string">'laser-473nm (Laser Quantum, Gem 473)'</span>;
<span class="keyword">end</span>
nwb.general_devices.set(laserName, types.core.Device());
</pre><pre class="codeinput">structDesc = {<span class="string">'recordingCoordinates'</span>;<span class="string">'recordingMarker'</span>;<span class="string">'recordingType'</span>;<span class="string">'penetrationN'</span>;<span class="keyword">...</span>
    <span class="string">'groundCoordinates'</span>};
<span class="keyword">if</span> ~isempty(meta.extracellular.referenceCoordinates)
    structDesc{end+1} = <span class="string">'referenceCoordinates'</span>;
<span class="keyword">end</span>
recordingLocation = meta.extracellular.recordingLocation{1};
egroup = types.core.ElectrodeGroup(<span class="keyword">...</span>
    <span class="string">'description'</span>, formatStruct(meta.extracellular, structDesc),<span class="keyword">...</span>
    <span class="string">'location'</span>, recordingLocation,<span class="keyword">...</span>
    <span class="string">'device'</span>, types.untyped.SoftLink([<span class="string">'/general/devices/'</span> deviceName]));
nwb.general_extracellular_ephys.set(deviceName, egroup);
</pre><p>The NWB <b>ElectrodeGroup</b> object stores experimental information regarding a group of probes.  Doing so requires a <b>SoftLink</b> to the probe specified under <tt>general_devices</tt>.  SoftLink objects are direct maps to <a href="https://portal.hdfgroup.org/display/HDF5/H5L_CREATE_SOFT">HDF5 Soft Links</a> on export, and thus, require a true HDF5 path.</p><pre class="codeinput"><span class="comment">%raw HDF5 path to the above electrode group.  Used in the DynamicTable below.</span>
egroupPath = [<span class="string">'/general/extracellular_ephys/'</span> deviceName];

etrodeNum = length(meta.extracellular.siteLocations);
etrodeMat = cell2mat(meta.extracellular.siteLocations .');
emptyStr = repmat({<span class="string">''</span>}, etrodeNum,1);
dtColNames = {<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>, <span class="string">'imp'</span>, <span class="string">'location'</span>, <span class="string">'filtering'</span>,<span class="string">'group'</span>,<span class="keyword">...</span>
    <span class="string">'group_name'</span>};
<span class="comment">% you can specify column names and values as key-value arguments in the DynamicTable</span>
<span class="comment">% constructor.</span>
dynTable = types.core.DynamicTable(<span class="keyword">...</span>
    <span class="string">'colnames'</span>, dtColNames,<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'Electrodes'</span>,<span class="keyword">...</span>
    <span class="string">'id'</span>, types.core.ElementIdentifiers(<span class="string">'data'</span>, int64(1:etrodeNum)),<span class="keyword">...</span>
    <span class="string">'x'</span>, types.core.VectorData(<span class="string">'data'</span>, etrodeMat(:,1),<span class="keyword">...</span>
        <span class="string">'description'</span>, <span class="string">'the x coordinate of the channel location'</span>),<span class="keyword">...</span>
    <span class="string">'y'</span>, types.core.VectorData(<span class="string">'data'</span>, etrodeMat(:,2),<span class="keyword">...</span>
        <span class="string">'description'</span>, <span class="string">'the y coordinate of the channel location'</span>),<span class="keyword">...</span>
    <span class="string">'z'</span>, types.core.VectorData(<span class="string">'data'</span>, etrodeMat(:,3),<span class="keyword">...</span>
        <span class="string">'description'</span>,<span class="string">'the z coordinate of the channel location'</span>),<span class="keyword">...</span>
    <span class="string">'imp'</span>, types.core.VectorData(<span class="string">'data'</span>, zeros(etrodeNum,1),<span class="keyword">...</span>
        <span class="string">'description'</span>,<span class="string">'the impedance of the channel'</span>),<span class="keyword">...</span>
    <span class="string">'location'</span>, types.core.VectorData(<span class="string">'data'</span>,<span class="keyword">...</span>
        repmat({recordingLocation}, etrodeNum, 1),<span class="keyword">...</span>
        <span class="string">'description'</span>, <span class="string">'the location of channel within the subject e.g. brain region'</span>),<span class="keyword">...</span>
    <span class="string">'filtering'</span>, types.core.VectorData(<span class="string">'data'</span>, emptyStr,<span class="keyword">...</span>
        <span class="string">'description'</span>, <span class="string">'description of hardware filtering'</span>),<span class="keyword">...</span>
    <span class="string">'group'</span>, types.core.VectorData(<span class="string">'data'</span>,<span class="keyword">...</span>
        repmat(types.untyped.ObjectView(egroupPath), etrodeNum, 1),<span class="keyword">...</span>
        <span class="string">'description'</span>, <span class="string">'a reference to the ElectrodeGroup this electrode is a part of'</span>),<span class="keyword">...</span>
    <span class="string">'group_name'</span>, types.core.VectorData(<span class="string">'data'</span>, repmat({probetype}, etrodeNum, 1),<span class="keyword">...</span>
        <span class="string">'description'</span>, <span class="string">'the name of the ElectrodeGroup this electrode is a part of'</span>));
</pre><p>The <tt>group</tt> column in the Dynamic Table contains an <b>ObjectView</b> to the previously created <tt>ElectrodeGroup</tt>.  An <tt>ObjectView</tt> can be best thought of as a direct pointer to another typed object.  It also directly maps to a <a href="https://portal.hdfgroup.org/display/HDF5/H5R_CREATE">HDF5 Object Reference</a>, thus the HDF5 path requirement.  <tt>ObjectViews</tt> are slightly different from <tt>SoftLinks</tt> in that they can be stored in datasets (data columns, tables, and <tt>data</tt> fields in <tt>NWBData</tt> objects).</p><pre class="codeinput">nwb.general_extracellular_ephys_electrodes = dynTable;
</pre><p>The <tt>electrodes</tt> property in <tt>extracellular_ephys</tt> is a special keyword in NWB that must be paired with a <b>Dynamic Table</b>.  These are tables which can have an unbounded number of columns and rows, each as their own dataset.  With the exception of the <tt>id</tt> column, all other columns must be <b>VectorData</b> or <b>VectorIndex</b> objects.  The <tt>id</tt> column, meanwhile, must be an <b>ElementIdentifiers</b> object.  The names of all used columns are specified in the in the <tt>colnames</tt> property as a cell array of strings.</p><pre class="codeinput"><span class="comment">% general/optogenetics/photostim</span>
nwb.general_optogenetics.set(<span class="string">'photostim'</span>, <span class="keyword">...</span>
    types.core.OptogeneticStimulusSite(<span class="keyword">...</span>
    <span class="string">'excitation_lambda'</span>, meta.photostim.photostimWavelength{1}, <span class="keyword">...</span>
    <span class="string">'location'</span>, meta.photostim.photostimLocation{1}, <span class="keyword">...</span>
    <span class="string">'device'</span>, types.untyped.SoftLink([<span class="string">'/general/devices/'</span> laserName]), <span class="keyword">...</span>
    <span class="string">'description'</span>, formatStruct(meta.photostim, {<span class="keyword">...</span>
    <span class="string">'stimulationMethod'</span>;<span class="string">'photostimCoordinates'</span>;<span class="string">'identificationMethod'</span>})));
</pre><h2 id="15">Analysis Data Structure</h2><p>The ALM-3 data structures .mat file contains analyzed spike data, trial-specific parameters, and behavioral analysis data.</p><h2 id="16">Hashes</h2><p>ALM-3 stores its data structures in the form of <b>hashes</b> which are essentially the same as python's dictionaries or MATLAB's maps but where the keys and values are stored under separate struct fields.  Getting a hashed value from a key involves retrieving the array index that the key is in and applying it to the parallel array in the values field.</p><p>You can find more information about hashes and how they're used on the <a href="https://crcns.org/data-sets/motor-cortex/alm-3/about-alm-3">ALM-3 about page</a>.</p><pre class="codeinput">fprintf(<span class="string">'Processing Data Structure `%s`\n'</span>, datastructure_loc);
loaded = load(datastructure_loc, <span class="string">'obj'</span>);
data = loaded.obj;
</pre><pre class="codeoutput">Processing Data Structure `data\data_structure_files\data_structure_ANM255201_20141125.mat`
</pre><p>The <tt>timeseries</tt> property of the <tt>TimeIntervals</tt> object is an example of a <b>compound data type</b>.  These types are essentially tables of data in HDF5 and can be represented by a MATLAB table, an array of structs, or a struct of arrays. Beware: validation of column lengths here is not guaranteed by the type checker until export.</p><p><b>VectorIndex</b> objects index into a larger <b>VectorData</b> column.  The object that is being referenced is indicated by the <tt>target</tt> property, which uses an ObjectView. Each element in the VectorIndex marks the <b>last</b> element in the corresponding vector data object for the VectorIndex row.  Thus, the starting index for this row would be the previous index + 1.  Note that these indices must be 0-indexed for compatibility with pynwb.  You can see this in effect with the <tt>timeseries</tt> property which is indexed by the <tt>timeseries_index</tt> property.</p><pre class="codeinput">trials_idx = types.core.TimeIntervals(<span class="keyword">...</span>
    <span class="string">'start_time'</span>, types.core.VectorData(<span class="string">'data'</span>, data.trialStartTimes,<span class="keyword">...</span>
        <span class="string">'description'</span>, <span class="string">'the start time of each trial'</span>),<span class="keyword">...</span>
    <span class="string">'colnames'</span>, [data.trialTypeStr; data.trialPropertiesHash.keyNames .';<span class="keyword">...</span>
        {<span class="string">'start_time'</span>; <span class="string">'stop_time'</span>}],<span class="keyword">...</span><span class="comment"> %stop_time will be determined later</span>
    <span class="string">'description'</span>, <span class="string">'trial data and properties'</span>, <span class="keyword">...</span>
    <span class="string">'id'</span>, types.core.ElementIdentifiers(<span class="string">'data'</span>, data.trialIds),<span class="keyword">...</span>
    <span class="string">'timeseries'</span>, types.core.VectorData(<span class="keyword">...</span>
        <span class="string">'data'</span>, struct(<span class="string">'idx_start'</span>, {}, <span class="string">'count'</span>, {}, <span class="string">'timeseries'</span>, {}),<span class="keyword">...</span>
        <span class="string">'description'</span>, <span class="string">'A group of timeseries'</span>),<span class="keyword">...</span>
    <span class="string">'timeseries_index'</span>, types.core.VectorIndex(<span class="keyword">...</span>
        <span class="string">'data'</span>, [],<span class="keyword">...</span>
        <span class="string">'target'</span>, types.untyped.ObjectView(<span class="string">'/intervals/trials/timeseries'</span>)));
<span class="comment">% we use a cell array here as a simple form of the VectorIndex -&gt; VectorData pair.</span>
<span class="comment">% this data is populated and structured right before export.</span>
trial_timeseries = cell(size(data.trialIds));

<span class="keyword">for</span> i=1:length(data.trialTypeStr)
    trials_idx.vectordata.set(data.trialTypeStr{i}, <span class="keyword">...</span>
        types.core.VectorData(<span class="string">'data'</span>, data.trialTypeMat(i,:),<span class="keyword">...</span>
            <span class="string">'description'</span>, data.trialTypeStr{i}));
<span class="keyword">end</span>

<span class="keyword">for</span> i=1:length(data.trialPropertiesHash.keyNames)
    descr = data.trialPropertiesHash.descr{i};
    <span class="keyword">if</span> iscellstr(descr)
        descr = strjoin(descr, newline);
    <span class="keyword">end</span>
    trials_idx.vectordata.set(data.trialPropertiesHash.keyNames{i}, <span class="keyword">...</span>
        types.core.VectorData(<span class="keyword">...</span>
        <span class="string">'data'</span>, data.trialPropertiesHash.value{i}, <span class="keyword">...</span>
        <span class="string">'description'</span>, descr));
<span class="keyword">end</span>
nwb.intervals_trials = trials_idx;
</pre><p>NWB comes with default support for trial-based data.  These must be <b>TimeIntervals</b> that are placed in the <tt>intervals</tt> property.  Note that <tt>trials</tt> is a special keyword that is required for PyNWB compatibility.</p><pre class="codeinput">ephus = data.timeSeriesArrayHash.value{1};
ephusUnit = data.timeUnitNames{data.timeUnitIds(ephus.timeUnit)};

<span class="comment">% lick direction and timestamps trace</span>
tsIdx = strcmp(ephus.idStr, <span class="string">'lick_trace'</span>);
bts = types.core.BehavioralTimeSeries();

bts.timeseries.set(<span class="string">'lick_trace_ts'</span>, <span class="keyword">...</span>
    types.core.TimeSeries(<span class="keyword">...</span>
    <span class="string">'data'</span>, ephus.valueMatrix(:,tsIdx),<span class="keyword">...</span>
    <span class="string">'data_unit'</span>, ephusUnit,<span class="keyword">...</span>
    <span class="string">'description'</span>, ephus.idStrDetailed{tsIdx}, <span class="keyword">...</span>
    <span class="string">'timestamps'</span>, ephus.time, <span class="keyword">...</span>
    <span class="string">'timestamps_unit'</span>, ephusUnit));
nwb.acquisition.set(<span class="string">'lick_trace'</span>, bts);
bts_ref = types.untyped.ObjectView(<span class="string">'/acquisition/lick_trace/lick_trace_ts'</span>);

<span class="comment">% acousto-optic modulator input trace</span>
tsIdx = strcmp(ephus.idStr, <span class="string">'aom_input_trace'</span>);
ts = types.core.TimeSeries(<span class="keyword">...</span>
    <span class="string">'data'</span>, ephus.valueMatrix(:,tsIdx), <span class="keyword">...</span>
    <span class="string">'data_unit'</span>, <span class="string">'Volts'</span>, <span class="keyword">...</span>
    <span class="string">'description'</span>, ephus.idStrDetailed{tsIdx}, <span class="keyword">...</span>
    <span class="string">'timestamps'</span>, ephus.time, <span class="keyword">...</span>
    <span class="string">'timestamps_unit'</span>, ephusUnit);
nwb.stimulus_presentation.set(<span class="string">'aom_input_trace'</span>, ts);
ts_ref = types.untyped.ObjectView(<span class="string">'/stimulus/presentation/aom_input_trace'</span>);

<span class="comment">% laser power</span>
tsIdx = strcmp(ephus.idStr, <span class="string">'laser_power'</span>);
ots = types.core.OptogeneticSeries(<span class="keyword">...</span>
    <span class="string">'data'</span>, ephus.valueMatrix(:,tsIdx), <span class="keyword">...</span>
    <span class="string">'data_unit'</span>, <span class="string">'mW'</span>, <span class="keyword">...</span>
    <span class="string">'description'</span>, ephus.idStrDetailed{tsIdx}, <span class="keyword">...</span>
    <span class="string">'timestamps'</span>, ephus.time, <span class="keyword">...</span>
    <span class="string">'timestamps_unit'</span>, ephusUnit, <span class="keyword">...</span>
    <span class="string">'site'</span>, types.untyped.SoftLink(<span class="string">'/general/optogenetics/photostim'</span>));
nwb.stimulus_presentation.set(<span class="string">'laser_power'</span>, ots);
ots_ref = types.untyped.ObjectView(<span class="string">'/stimulus/presentation/laser_power'</span>);

<span class="comment">% append trials timeseries references in order</span>
[ephus_trials, ~, trials_to_data] = unique(ephus.trial);
<span class="keyword">for</span> i=1:length(ephus_trials)
    i_loc = i == trials_to_data;
    t_start = find(i_loc, 1);
    t_count = sum(i_loc);
    trial = ephus_trials(i);

    trial_timeseries{trial}(end+(1:3)) = [<span class="keyword">...</span>
        struct(<span class="string">'timeseries'</span>, bts_ref, <span class="string">'idx_start'</span>, t_start, <span class="string">'count'</span>, t_count);<span class="keyword">...</span>
        struct(<span class="string">'timeseries'</span>, ts_ref, <span class="string">'idx_start'</span>, t_start, <span class="string">'count'</span>, t_count);<span class="keyword">...</span>
        struct(<span class="string">'timeseries'</span>, ots_ref, <span class="string">'idx_start'</span>, t_start, <span class="string">'count'</span>, t_count)];
<span class="keyword">end</span>
</pre><p>Trial IDs, wherever they are used, are placed in a relevent <tt>control</tt> property in the data object and will indicate what data is associated with what trial as defined in <tt>trials</tt>'s <tt>id</tt> column.</p><pre class="codeinput">nwb.units = types.core.Units(<span class="string">'colnames'</span>,<span class="keyword">...</span>
    {<span class="string">'spike_times'</span>, <span class="string">'trials'</span>, <span class="string">'waveforms'</span>},<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'Analysed Spike Events'</span>);
esHash = data.eventSeriesHash;
ids = regexp(esHash.keyNames, <span class="string">'^unit(\d+)$'</span>, <span class="string">'once'</span>, <span class="string">'tokens'</span>);
ids = str2double([ids{:}]);
nwb.units.id = types.core.ElementIdentifiers(<span class="string">'data'</span>, ids);
nwb.units.spike_times_index = types.core.VectorIndex(<span class="keyword">...</span>
    <span class="string">'target'</span>, types.untyped.ObjectView(<span class="string">'/units/spike_times'</span>));
nwb.units.spike_times = types.core.VectorData(<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'timestamps of spikes'</span>);
</pre><p>Ephus spike data is separated into units which directly maps to the NWB property of the same name.  Each such unit contains a group of analysed waveforms and spike times, all linked to a different subset of trials IDs.</p><pre class="codeinput">unitTrials = types.core.VectorData(<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'A large group of trial IDs for each unit'</span>,<span class="keyword">...</span>
    <span class="string">'data'</span>, []);

trials_idx = types.core.VectorIndex(<span class="keyword">...</span>
    <span class="string">'data'</span>, [],<span class="keyword">...</span>
    <span class="string">'target'</span>, types.untyped.ObjectView(<span class="string">'/units/trials'</span>));

wav_idx = types.core.VectorData(<span class="string">'data'</span>,types.untyped.ObjectView.empty,<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'waveform references'</span>);
</pre><p>The waveforms are placed in the <tt>analysis</tt> Set and are paired with their unit name ('unitx' where 'x' is some unit ID).</p><pre class="codeinput"><span class="keyword">for</span> i=1:length(ids)
    esData = esHash.value{i};
    <span class="comment">% add trials ID reference</span>

    good_trials_mask = ismember(esData.eventTrials, nwb.intervals_trials.id.data);
    eventTrials = esData.eventTrials(good_trials_mask);
    eventTimes = esData.eventTimes(good_trials_mask);
    waveforms = esData.waveforms(good_trials_mask,:);
    channel = esData.channel(good_trials_mask);

    unitTrials.data = [unitTrials.data; eventTrials];
    trials_idx.data(end+1) = length(unitTrials.data);

    <span class="comment">% add spike times index and data.  note that these are also VectorIndex and VectorData pairs.</span>
    nwb.units.spike_times.data = [nwb.units.spike_times.data;eventTimes];
    nwb.units.spike_times_index.data(end+1) = length(nwb.units.spike_times.data);

    <span class="comment">% add waveform data to "unitx" and associate with "waveform" column as ObjectView.</span>
    ses = types.core.SpikeEventSeries(<span class="keyword">...</span>
        <span class="string">'control'</span>, ids(i),<span class="keyword">...</span>
        <span class="string">'control_description'</span>, <span class="string">'Units Table ID'</span>,<span class="keyword">...</span>
        <span class="string">'data'</span>, waveforms .', <span class="keyword">...</span>
        <span class="string">'description'</span>, esHash.descr{i}, <span class="keyword">...</span>
        <span class="string">'timestamps'</span>, eventTimes, <span class="keyword">...</span>
        <span class="string">'timestamps_unit'</span>, data.timeUnitNames{data.timeUnitIds(esData.timeUnit)},<span class="keyword">...</span>
        <span class="string">'electrodes'</span>, types.core.DynamicTableRegion(<span class="keyword">...</span>
            <span class="string">'description'</span>, <span class="string">'Electrodes involved with these spike events'</span>,<span class="keyword">...</span>
            <span class="string">'table'</span>, types.untyped.ObjectView(<span class="string">'/general/extracellular_ephys/electrodes'</span>),<span class="keyword">...</span>
            <span class="string">'data'</span>, channel - 1));
    ses_name = esHash.keyNames{i};
    ses_ref = types.untyped.ObjectView([<span class="string">'/analysis/'</span>, ses_name]);
    <span class="keyword">if</span> ~isempty(esData.cellType)
        ses.comments = [<span class="string">'cellType: '</span> esData.cellType{1}];
    <span class="keyword">end</span>
    nwb.analysis.set(ses_name, ses);
    wav_idx.data(end+1) = ses_ref;

    <span class="comment">%add this timeseries into the trials table as well.</span>
    [s_trials, ~, trials_to_data] = unique(eventTrials);
    <span class="keyword">for</span> j=1:length(s_trials)
        trial = s_trials(j);
        j_loc = j == trials_to_data;
        t_start = find(j_loc, 1);
        t_count = sum(j_loc);

        trial_timeseries{trial}(end+1) = struct(<span class="keyword">...</span>
            <span class="string">'timeseries'</span>, ses_ref, <span class="string">'idx_start'</span>, t_start, <span class="string">'count'</span>, t_count);
    <span class="keyword">end</span>
<span class="keyword">end</span>
nwb.units.vectorindex.set(<span class="string">'trials_index'</span>, trials_idx);
nwb.units.vectordata.set(<span class="string">'trials'</span>, unitTrials);
nwb.units.vectordata.set(<span class="string">'waveforms'</span>, wav_idx);
</pre><p>To better understand how <tt>spike_times_index</tt> and <tt>spike_times</tt> map to each other, refer to <a href="https://neurodatawithoutborders.github.io/matnwb/tutorials/html/ecephys.html#13">this diagram</a> from the Extracellular Electrophysiology Tutorial.</p><h2 id="25">Raw Acquisition Data</h2><p>Each ALM-3 session is associated with a large number of raw voltage data grouped by trial ID. To map this data to NWB, each trial is created as its own <b>ElectricalSeries</b> object under the name 'trial n' where 'n' is the trial ID.  The trials are then linked to the <tt>trials</tt> dynamic table for easy referencing.</p><pre class="codeinput">fprintf(<span class="string">'Processing Raw Acquisition Data from `%s` (will take a while)\n'</span>, rawdata_loc);
untarLoc = fullfile(pwd, identifier);
<span class="keyword">if</span> 7 ~= exist(untarLoc, <span class="string">'dir'</span>)
    untar(rawdata_loc, pwd);
<span class="keyword">end</span>

rawfiles = dir(untarLoc);
rawfiles = fullfile(untarLoc, {rawfiles(~[rawfiles.isdir]).name});

nrows = length(nwb.general_extracellular_ephys_electrodes.id.data);
tablereg = types.core.DynamicTableRegion(<span class="keyword">...</span>
    <span class="string">'description'</span>,<span class="string">'Relevent Electrodes for this Electrical Series'</span>,<span class="keyword">...</span>
    <span class="string">'table'</span>,types.untyped.ObjectView(<span class="string">'/general/extracellular_ephys/electrodes'</span>),<span class="keyword">...</span>
    <span class="string">'data'</span>,(1:nrows) - 1);
objrefs = cell(size(rawfiles));
trials_idx = nwb.intervals_trials;
endTimestamps = trials_idx.start_time.data;
<span class="keyword">for</span> i=1:length(rawfiles)
    tnumstr = regexp(rawfiles{i}, <span class="string">'_trial_(\d+)\.mat$'</span>, <span class="string">'tokens'</span>, <span class="string">'once'</span>);
    tnumstr = tnumstr{1};
    rawdata = load(rawfiles{i}, <span class="string">'ch_MUA'</span>, <span class="string">'TimeStamps'</span>);
    tnum = str2double(tnumstr);

    <span class="keyword">if</span> tnum &gt; length(endTimestamps)
        <span class="keyword">continue</span>; <span class="comment">% sometimes there are extra trials without an associated start time.</span>
    <span class="keyword">end</span>

    es = types.core.ElectricalSeries(<span class="keyword">...</span>
        <span class="string">'data'</span>, rawdata.ch_MUA,<span class="keyword">...</span>
        <span class="string">'description'</span>, [<span class="string">'Raw Voltage Acquisition for trial '</span> tnumstr],<span class="keyword">...</span>
        <span class="string">'electrodes'</span>, tablereg,<span class="keyword">...</span>
        <span class="string">'timestamps'</span>, rawdata.TimeStamps);
    tname = [<span class="string">'trial '</span> tnumstr];
    nwb.acquisition.set(tname, es);

    endTimestamps(tnum) = endTimestamps(tnum) + rawdata.TimeStamps(end);
    objrefs{tnum} = types.untyped.ObjectView([<span class="string">'/acquisition/'</span> tname]);
<span class="keyword">end</span>

<span class="comment">%Link to the raw data by adding the acquisition column with ObjectViews</span>
<span class="comment">%to the data</span>
emptyrefs = cellfun(<span class="string">'isempty'</span>, objrefs);
objrefs(emptyrefs) = {types.untyped.ObjectView(<span class="string">''</span>)};
trials_idx.colnames{end+1} = <span class="string">'acquisition'</span>;
trials_idx.vectordata.set(<span class="string">'acquisition'</span>, types.core.VectorData(<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'soft link to acquisition data for this trial'</span>,<span class="keyword">...</span>
    <span class="string">'data'</span>, [objrefs{:}]));
trials_idx.stop_time = types.core.VectorData(<span class="keyword">...</span>
    <span class="string">'data'</span>, endTimestamps,<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'the end time of each trial'</span>);
</pre><pre class="codeoutput">Processing Raw Acquisition Data from `data\RawVoltageTraces\ANM255201_20141125.tar` (will take a while)
</pre><h2 id="26">Export</h2><pre class="codeinput"><span class="comment">%first, we'll format and store |trial_timeseries| into |intervals_trials|.</span>
<span class="comment">% note that |timeseries_index| data is 0-indexed.</span>
ts_len = cellfun(<span class="string">'length'</span>, trial_timeseries);
empties = ts_len == 0;
trial_timeseries(empties) = {struct(<span class="string">'timeseries'</span>, {}, <span class="string">'idx_start'</span>, {}, <span class="string">'count'</span>, {})};

nwb.intervals_trials.timeseries_index.data = cumsum(ts_len);
nwb.intervals_trials.timeseries.data = cell2mat(trial_timeseries);

outDest = fullfile(outloc, [identifier <span class="string">'.nwb'</span>]);
nwbExport(nwb, outDest);
</pre><pre class="codeoutput">Warning: Overwriting
out\ANM255201_20141125.nwb 
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% NWB File Conversion Tutorial
% How to convert trial-based experimental data to the Neurodata Without Borders file format using MatNWB.
% This example uses the <https://crcns.org/data-sets/motor-cortex/alm-3 CRCNS ALM-3>
% data set.  Information on how to download the data can be found on the 
% <https://crcns.org/data-sets/motor-cortex/download CRCNS Download Page>.  One should
% first familiarize themselves with the file format, which can be found on the
% <https://crcns.org/data-sets/motor-cortex/alm-3/about-alm-3 ALM-3 About Page> under
% the Documentation files.
% 
%  author: Lawrence Niu
%  contact: lawrence@vidriotech.com
%  last updated: Jan 11, 2019

%% Script Configuration
% The following details configuration parameters specific to the publishing script,
% and can be skipped when implementing your own conversion.
% The parameters can be changed to fit any of the available sessions.

animal = 'ANM255201';
session = '20141125';

identifier = [animal '_' session];

metadata_loc = fullfile('data','metadata', ['meta_data_' identifier '.mat']);
datastructure_loc = fullfile('data','data_structure_files',...
    ['data_structure_' identifier '.mat']);
rawdata_loc = fullfile('data', 'RawVoltageTraces', [identifier '.tar']);
%%
% The animal and session specifier can be changed with the |animal| and |session|
% variable name respectively.  |metadata_loc|, |datastructure_loc|, and |rawdata_loc|
% should refer to the metadata .mat file, the data structure .mat file, 
% and the raw .tar file.

outloc = 'out';

if 7 ~= exist(outloc, 'dir')
    mkdir(outloc);
end

source_file = [mfilename() '.m'];
[~, source_script, ~] = fileparts(source_file);
%%
% The NWB file will be saved in the output directory indicated by |outdir|

%% General Information

nwb = NwbFile();
nwb.identifier = identifier;
nwb.general_source_script = source_script;
nwb.general_source_script_file_name = source_file;
nwb.general_lab = 'Svoboda';
nwb.general_keywords = {'Network models', 'Premotor cortex', 'Short-term memory'};
nwb.general_institution = ['Janelia Research Campus,'...
    ' Howard Huges Medical Institute, Ashburn, Virginia 20147, USA'];
nwb.general_related_publications = ...
    ['Li N, Daie K, Svoboda K, Druckmann S (2016).',...
    ' Robust neuronal dynamics in premotor cortex during motor planning.',...
    ' Nature. 7600:459-64. doi: 10.1038/nature17643'];
nwb.general_stimulus = 'photostim';
nwb.general_protocol = 'IACUC';
nwb.general_surgery = ['Mice were prepared for photoinhibition and ',...
    'electrophysiology with a clear-skull cap and a headpost. ',...
    'The scalp and periosteum over the dorsal surface of the skull were removed. ',...
    'A layer of cyanoacrylate adhesive (Krazy glue, Elmer''s Products Inc.) ',...
    'was directly applied to the intact skull. A custom made headpost ',...
    'was placed on the skull with its anterior edge aligned with the suture lambda ',...
    '(approximately over cerebellum) and cemented in place ',...
    'with clear dental acrylic (Lang Dental Jet Repair Acrylic; 1223-clear). ',...
    'A thin layer of clear dental acrylic was applied over the cyanoacrylate adhesive ',...
    'covering the entire exposed skull, ',...
    'followed by a thin layer of clear nail polish (Electron Microscopy Sciences, 72180).'];
nwb.session_description = sprintf('Animal `%s` on Session `%s`', animal, session);
%%
% All properties with the prefix |general| contain context for the entire experiment
% such as lab, institution, and experimentors.  For session-delimited data from the
% same experiment, these fields will all be the same.  Note that most of this
% information was pulled from the publishing paper and not from any of the downloadable data.
%%
% The only required property is the |identifier|, which distinguishes one session from
% another within an experiment.  In our case, the ALM-3 data uses a combination of
% session date and animal ID.

%% The ALM-3 File Structure
% Each ALM-3 session has three files: a metadata .mat file describing the experiment, a
% data structures .mat file containing analyzed data, and a raw .tar archive
% containing multiple raw electrophysiology data separated by trial as .mat files.
% All files will be merged into a single NWB file.

%% Metadata
% ALM-3 Metadata contains information about the reference times, experimental context,
% methodology, as well as details of the electrophysiology, optophysiology, and behavioral
% portions of the experiment.  A vast majority of these details are placed in |general|
% prefixed properties in NWB.
fprintf('Processing Meta Data from `%s`\n', metadata_loc);
loaded = load(metadata_loc, 'meta_data');
meta = loaded.meta_data;

%experiment-specific treatment for animals with the ReaChR gene modification
isreachr = any(cell2mat(strfind(meta.animalGeneModification, 'ReaChR')));

%sessions are separated by date of experiment.
nwb.general_session_id = meta.dateOfExperiment;

%ALM-3 data start time is equivalent to the reference time.
nwb.session_start_time = datetime([meta.dateOfExperiment meta.timeOfExperiment],...
    'InputFormat', 'yyyyMMddHHmmss');
nwb.timestamps_reference_time = nwb.session_start_time;

nwb.general_experimenter = strjoin(meta.experimenters, ', ');

%%
nwb.general_subject = types.core.Subject(...
    'species', meta.species{1}, ...
    'subject_id', meta.animalID{1}(1,:), ... %weird case with duplicate Animal ID
    'sex', meta.sex, ...
    'age', meta.dateOfBirth, ...
    'description', [...
        'Whisker Config: ' strjoin(meta.whiskerConfig, ', ') newline...
        'Animal Source: ' strjoin(meta.animalSource, ', ')]);
%%
% Ideally, if a raw data field does not correspond directly to a NWB field, one would
% create their own using a
% <https://pynwb.readthedocs.io/en/latest/extensions.html custom NWB extension class>.
% However, since these fields are mostly experimental annotations, we instead pack the
% extra values into the |description| field as a string.

%The formatStruct function simply prints the field and values given the struct.
%An optional cell array of field names specifies whitelist of fields to print.  This
%function is provided with this script in the tutorials directory.
nwb.general_subject.genotype = formatStruct(...
    meta, ...
    {'animalStrain'; 'animalGeneModification'; 'animalGeneCopy';...
    'animalGeneticBackground'});

weight = {};
if ~isempty(meta.weightBefore)
    weight{end+1} = 'weightBefore';
end
if ~isempty(meta.weightAfter)
    weight{end+1} = 'weightAfter';
end
weight = weight(~cellfun('isempty', weight));
if ~isempty(weight)
    nwb.general_subject.weight = formatStruct(meta, weight);
end

% general/experiment_description
nwb.general_experiment_description = [...
    formatStruct(meta, {'experimentType'; 'referenceAtlas'}), ...
    sprintf('\n'), ...
    formatStruct(meta.behavior, {'task_keyword'})];

% Miscellaneous collection information from ALM-3 that didn't quite fit any NWB properties
% are stored in general/data_collection.
nwb.general_data_collection = formatStruct(meta.extracellular,...
    {'extracellularDataType';'cellType';'identificationMethod';'amplifierRolloff';...
    'spikeSorting';'ADunit'});

% Device objects are essentially just a list of device names.  We store the probe
% and laser hardware names here.
probetype = meta.extracellular.probeType{1};
probeSource = meta.extracellular.probeSource{1};
deviceName = [probetype ' (' probeSource ')'];
nwb.general_devices.set(deviceName,...
    types.core.Device());

if isreachr
    laserName = 'laser-594nm (Cobolt Inc., Cobolt Mambo 100)';
else
    laserName = 'laser-473nm (Laser Quantum, Gem 473)';
end
nwb.general_devices.set(laserName, types.core.Device());

%%
structDesc = {'recordingCoordinates';'recordingMarker';'recordingType';'penetrationN';...
    'groundCoordinates'};
if ~isempty(meta.extracellular.referenceCoordinates)
    structDesc{end+1} = 'referenceCoordinates';
end
recordingLocation = meta.extracellular.recordingLocation{1};
egroup = types.core.ElectrodeGroup(...
    'description', formatStruct(meta.extracellular, structDesc),...
    'location', recordingLocation,...
    'device', types.untyped.SoftLink(['/general/devices/' deviceName]));
nwb.general_extracellular_ephys.set(deviceName, egroup);
%%
% The NWB *ElectrodeGroup* object stores experimental information regarding a group of
% probes.  Doing so requires a *SoftLink* to the probe specified under
% |general_devices|.  SoftLink objects are direct maps to
% <https://portal.hdfgroup.org/display/HDF5/H5L_CREATE_SOFT HDF5 Soft Links> on export,
% and thus, require a true HDF5 path.

%raw HDF5 path to the above electrode group.  Used in the DynamicTable below.
egroupPath = ['/general/extracellular_ephys/' deviceName];

etrodeNum = length(meta.extracellular.siteLocations);
etrodeMat = cell2mat(meta.extracellular.siteLocations .');
emptyStr = repmat({''}, etrodeNum,1);
dtColNames = {'x', 'y', 'z', 'imp', 'location', 'filtering','group',...
    'group_name'};
% you can specify column names and values as key-value arguments in the DynamicTable
% constructor.
dynTable = types.core.DynamicTable(...
    'colnames', dtColNames,...
    'description', 'Electrodes',...
    'id', types.core.ElementIdentifiers('data', int64(1:etrodeNum)),...
    'x', types.core.VectorData('data', etrodeMat(:,1),...
        'description', 'the x coordinate of the channel location'),...
    'y', types.core.VectorData('data', etrodeMat(:,2),...
        'description', 'the y coordinate of the channel location'),...
    'z', types.core.VectorData('data', etrodeMat(:,3),...
        'description','the z coordinate of the channel location'),...
    'imp', types.core.VectorData('data', zeros(etrodeNum,1),...
        'description','the impedance of the channel'),...
    'location', types.core.VectorData('data',...
        repmat({recordingLocation}, etrodeNum, 1),...
        'description', 'the location of channel within the subject e.g. brain region'),...
    'filtering', types.core.VectorData('data', emptyStr,...
        'description', 'description of hardware filtering'),...
    'group', types.core.VectorData('data',...
        repmat(types.untyped.ObjectView(egroupPath), etrodeNum, 1),...
        'description', 'a reference to the ElectrodeGroup this electrode is a part of'),...
    'group_name', types.core.VectorData('data', repmat({probetype}, etrodeNum, 1),...
        'description', 'the name of the ElectrodeGroup this electrode is a part of'));
%%
% The |group| column in the Dynamic Table contains an *ObjectView* to the previously
% created |ElectrodeGroup|.  An |ObjectView| can be best thought of as a direct
% pointer to another typed object.  It also directly maps to a 
% <https://portal.hdfgroup.org/display/HDF5/H5R_CREATE HDF5 Object Reference>,
% thus the HDF5 path requirement.  |ObjectViews| are slightly different from |SoftLinks|
% in that they can be stored in datasets (data columns, tables, and |data| fields in
% |NWBData| objects).

nwb.general_extracellular_ephys_electrodes = dynTable;
%%
% The |electrodes| property in |extracellular_ephys| is a special keyword in NWB that
% must be paired with a *Dynamic Table*.  These are tables which can have an unbounded
% number of columns and rows, each as their own dataset.  With the exception of the |id|
% column, all other columns must be *VectorData* or *VectorIndex* objects.  The |id|
% column, meanwhile, must be an *ElementIdentifiers* object.  The names of all used
% columns are specified in the in the |colnames| property as a cell array of strings.

% general/optogenetics/photostim
nwb.general_optogenetics.set('photostim', ...
    types.core.OptogeneticStimulusSite(...
    'excitation_lambda', meta.photostim.photostimWavelength{1}, ...
    'location', meta.photostim.photostimLocation{1}, ...
    'device', types.untyped.SoftLink(['/general/devices/' laserName]), ...
    'description', formatStruct(meta.photostim, {...
    'stimulationMethod';'photostimCoordinates';'identificationMethod'})));
%% Analysis Data Structure
% The ALM-3 data structures .mat file contains analyzed spike data, trial-specific
% parameters, and behavioral analysis data.
%% Hashes
% ALM-3 stores its data structures in the form of *hashes* which are essentially the
% same as python's dictionaries or MATLAB's maps but where the keys and values
% are stored under separate struct fields.  Getting a hashed value from a key
% involves retrieving the array index that the key is in and applying it to the
% parallel array in the values field.
%%
% You can find more information about hashes and how they're used on the
% <https://crcns.org/data-sets/motor-cortex/alm-3/about-alm-3 ALM-3 about page>.
fprintf('Processing Data Structure `%s`\n', datastructure_loc);
loaded = load(datastructure_loc, 'obj');
data = loaded.obj;

%%
% The |timeseries| property of the |TimeIntervals| object is an example of a
% *compound data type*.  These types are essentially tables of data in HDF5 and can
% be represented by a MATLAB table, an array of structs, or a struct of arrays.
% Beware: validation of column lengths here is not guaranteed by the type checker
% until export.
%%
% *VectorIndex* objects index into a larger *VectorData* column.  The object that is
% being referenced is indicated by the |target| property, which uses an ObjectView.
% Each element in the VectorIndex marks the *last* element in the corresponding
% vector data object for the VectorIndex row.  Thus, the starting index for this
% row would be the previous index + 1.  Note that these indices must be 0-indexed
% for compatibility with pynwb.  You can see this in effect with the |timeseries|
% property which is indexed by the |timeseries_index| property.
trials_idx = types.core.TimeIntervals(...
    'start_time', types.core.VectorData('data', data.trialStartTimes,...
        'description', 'the start time of each trial'),...
    'colnames', [data.trialTypeStr; data.trialPropertiesHash.keyNames .';...
        {'start_time'; 'stop_time'}],... %stop_time will be determined later
    'description', 'trial data and properties', ...
    'id', types.core.ElementIdentifiers('data', data.trialIds),...
    'timeseries', types.core.VectorData(...
        'data', struct('idx_start', {}, 'count', {}, 'timeseries', {}),...
        'description', 'A group of timeseries'),...
    'timeseries_index', types.core.VectorIndex(...
        'data', [],...
        'target', types.untyped.ObjectView('/intervals/trials/timeseries')));
% we use a cell array here as a simple form of the VectorIndex -> VectorData pair.
% this data is populated and structured right before export.
trial_timeseries = cell(size(data.trialIds));

for i=1:length(data.trialTypeStr)
    trials_idx.vectordata.set(data.trialTypeStr{i}, ...
        types.core.VectorData('data', data.trialTypeMat(i,:),...
            'description', data.trialTypeStr{i}));
end

for i=1:length(data.trialPropertiesHash.keyNames)
    descr = data.trialPropertiesHash.descr{i};
    if iscellstr(descr)
        descr = strjoin(descr, newline);
    end
    trials_idx.vectordata.set(data.trialPropertiesHash.keyNames{i}, ...
        types.core.VectorData(...
        'data', data.trialPropertiesHash.value{i}, ...
        'description', descr));
end
nwb.intervals_trials = trials_idx;
%%
% NWB comes with default support for trial-based data.  These must be *TimeIntervals* that
% are placed in the |intervals| property.  Note that |trials| is a special
% keyword that is required for PyNWB compatibility.

ephus = data.timeSeriesArrayHash.value{1};
ephusUnit = data.timeUnitNames{data.timeUnitIds(ephus.timeUnit)};

% lick direction and timestamps trace
tsIdx = strcmp(ephus.idStr, 'lick_trace');
bts = types.core.BehavioralTimeSeries();

bts.timeseries.set('lick_trace_ts', ...
    types.core.TimeSeries(...
    'data', ephus.valueMatrix(:,tsIdx),...
    'data_unit', ephusUnit,...
    'description', ephus.idStrDetailed{tsIdx}, ...
    'timestamps', ephus.time, ...
    'timestamps_unit', ephusUnit));
nwb.acquisition.set('lick_trace', bts);
bts_ref = types.untyped.ObjectView('/acquisition/lick_trace/lick_trace_ts');

% acousto-optic modulator input trace
tsIdx = strcmp(ephus.idStr, 'aom_input_trace');
ts = types.core.TimeSeries(...
    'data', ephus.valueMatrix(:,tsIdx), ...
    'data_unit', 'Volts', ...
    'description', ephus.idStrDetailed{tsIdx}, ...
    'timestamps', ephus.time, ...
    'timestamps_unit', ephusUnit);
nwb.stimulus_presentation.set('aom_input_trace', ts);
ts_ref = types.untyped.ObjectView('/stimulus/presentation/aom_input_trace');

% laser power
tsIdx = strcmp(ephus.idStr, 'laser_power');
ots = types.core.OptogeneticSeries(...
    'data', ephus.valueMatrix(:,tsIdx), ...
    'data_unit', 'mW', ...
    'description', ephus.idStrDetailed{tsIdx}, ...
    'timestamps', ephus.time, ...
    'timestamps_unit', ephusUnit, ...
    'site', types.untyped.SoftLink('/general/optogenetics/photostim'));
nwb.stimulus_presentation.set('laser_power', ots);
ots_ref = types.untyped.ObjectView('/stimulus/presentation/laser_power');

% append trials timeseries references in order
[ephus_trials, ~, trials_to_data] = unique(ephus.trial);
for i=1:length(ephus_trials)
    i_loc = i == trials_to_data;
    t_start = find(i_loc, 1);
    t_count = sum(i_loc);
    trial = ephus_trials(i);
    
    trial_timeseries{trial}(end+(1:3)) = [...
        struct('timeseries', bts_ref, 'idx_start', t_start, 'count', t_count);...
        struct('timeseries', ts_ref, 'idx_start', t_start, 'count', t_count);...
        struct('timeseries', ots_ref, 'idx_start', t_start, 'count', t_count)];
end

%%
% Trial IDs, wherever they are used, are placed in a relevent |control| property in the
% data object and will indicate what data is associated with what trial as
% defined in |trials|'s |id| column.

nwb.units = types.core.Units('colnames',...
    {'spike_times', 'trials', 'waveforms'},...
    'description', 'Analysed Spike Events');
esHash = data.eventSeriesHash;
ids = regexp(esHash.keyNames, '^unit(\d+)$', 'once', 'tokens');
ids = str2double([ids{:}]);
nwb.units.id = types.core.ElementIdentifiers('data', ids);
nwb.units.spike_times_index = types.core.VectorIndex(...
    'target', types.untyped.ObjectView('/units/spike_times'));
nwb.units.spike_times = types.core.VectorData(...
    'description', 'timestamps of spikes');
%%
% Ephus spike data is separated into units which directly maps to the NWB property
% of the same name.  Each such unit contains a group of analysed waveforms and spike
% times, all linked to a different subset of trials IDs.
unitTrials = types.core.VectorData(...
    'description', 'A large group of trial IDs for each unit',...
    'data', []);

trials_idx = types.core.VectorIndex(...
    'data', [],...
    'target', types.untyped.ObjectView('/units/trials'));

wav_idx = types.core.VectorData('data',types.untyped.ObjectView.empty,...
    'description', 'waveform references');
%%
% The waveforms are placed in the |analysis| Set and are paired with their unit name
% ('unitx' where 'x' is some unit ID).

for i=1:length(ids)
    esData = esHash.value{i};
    % add trials ID reference
    
    good_trials_mask = ismember(esData.eventTrials, nwb.intervals_trials.id.data);
    eventTrials = esData.eventTrials(good_trials_mask);
    eventTimes = esData.eventTimes(good_trials_mask);
    waveforms = esData.waveforms(good_trials_mask,:);
    channel = esData.channel(good_trials_mask);
    
    unitTrials.data = [unitTrials.data; eventTrials];
    trials_idx.data(end+1) = length(unitTrials.data);
    
    % add spike times index and data.  note that these are also VectorIndex and VectorData pairs.
    nwb.units.spike_times.data = [nwb.units.spike_times.data;eventTimes];
    nwb.units.spike_times_index.data(end+1) = length(nwb.units.spike_times.data);
    
    % add waveform data to "unitx" and associate with "waveform" column as ObjectView.
    ses = types.core.SpikeEventSeries(...
        'control', ids(i),...
        'control_description', 'Units Table ID',...
        'data', waveforms .', ...
        'description', esHash.descr{i}, ...
        'timestamps', eventTimes, ...
        'timestamps_unit', data.timeUnitNames{data.timeUnitIds(esData.timeUnit)},...
        'electrodes', types.core.DynamicTableRegion(...
            'description', 'Electrodes involved with these spike events',...
            'table', types.untyped.ObjectView('/general/extracellular_ephys/electrodes'),...
            'data', channel - 1));
    ses_name = esHash.keyNames{i};
    ses_ref = types.untyped.ObjectView(['/analysis/', ses_name]);
    if ~isempty(esData.cellType)
        ses.comments = ['cellType: ' esData.cellType{1}];
    end
    nwb.analysis.set(ses_name, ses);
    wav_idx.data(end+1) = ses_ref;
    
    %add this timeseries into the trials table as well.
    [s_trials, ~, trials_to_data] = unique(eventTrials);
    for j=1:length(s_trials)
        trial = s_trials(j);
        j_loc = j == trials_to_data;
        t_start = find(j_loc, 1);
        t_count = sum(j_loc);
        
        trial_timeseries{trial}(end+1) = struct(...
            'timeseries', ses_ref, 'idx_start', t_start, 'count', t_count);
    end
end
nwb.units.vectorindex.set('trials_index', trials_idx);
nwb.units.vectordata.set('trials', unitTrials);
nwb.units.vectordata.set('waveforms', wav_idx);
%%
% To better understand how |spike_times_index| and |spike_times| map to each other, refer to
% <https://neurodatawithoutborders.github.io/matnwb/tutorials/html/ecephys.html#13 this
% diagram> from the Extracellular Electrophysiology Tutorial.

%% Raw Acquisition Data
% Each ALM-3 session is associated with a large number of raw voltage data grouped by
% trial ID. To map this data to NWB, each trial is created as its own *ElectricalSeries*
% object under the name 'trial n' where 'n' is the trial ID.  The trials are then linked
% to the |trials| dynamic table for easy referencing.
fprintf('Processing Raw Acquisition Data from `%s` (will take a while)\n', rawdata_loc);
untarLoc = fullfile(pwd, identifier);
if 7 ~= exist(untarLoc, 'dir')
    untar(rawdata_loc, pwd);
end

rawfiles = dir(untarLoc);
rawfiles = fullfile(untarLoc, {rawfiles(~[rawfiles.isdir]).name});

nrows = length(nwb.general_extracellular_ephys_electrodes.id.data);
tablereg = types.core.DynamicTableRegion(...
    'description','Relevent Electrodes for this Electrical Series',...
    'table',types.untyped.ObjectView('/general/extracellular_ephys/electrodes'),...
    'data',(1:nrows) - 1);
objrefs = cell(size(rawfiles));
trials_idx = nwb.intervals_trials;
endTimestamps = trials_idx.start_time.data;
for i=1:length(rawfiles)
    tnumstr = regexp(rawfiles{i}, '_trial_(\d+)\.mat$', 'tokens', 'once');
    tnumstr = tnumstr{1};
    rawdata = load(rawfiles{i}, 'ch_MUA', 'TimeStamps');
    tnum = str2double(tnumstr);
    
    if tnum > length(endTimestamps)
        continue; % sometimes there are extra trials without an associated start time.
    end
    
    es = types.core.ElectricalSeries(...
        'data', rawdata.ch_MUA,...
        'description', ['Raw Voltage Acquisition for trial ' tnumstr],...
        'electrodes', tablereg,...
        'timestamps', rawdata.TimeStamps);
    tname = ['trial ' tnumstr];
    nwb.acquisition.set(tname, es);
    
    endTimestamps(tnum) = endTimestamps(tnum) + rawdata.TimeStamps(end);
    objrefs{tnum} = types.untyped.ObjectView(['/acquisition/' tname]);
end

%Link to the raw data by adding the acquisition column with ObjectViews
%to the data
emptyrefs = cellfun('isempty', objrefs);
objrefs(emptyrefs) = {types.untyped.ObjectView('')};
trials_idx.colnames{end+1} = 'acquisition';
trials_idx.vectordata.set('acquisition', types.core.VectorData(...
    'description', 'soft link to acquisition data for this trial',...
    'data', [objrefs{:}]));
trials_idx.stop_time = types.core.VectorData(...
    'data', endTimestamps,...
    'description', 'the end time of each trial');

%% Export

%first, we'll format and store |trial_timeseries| into |intervals_trials|.
% note that |timeseries_index| data is 0-indexed.
ts_len = cellfun('length', trial_timeseries);
empties = ts_len == 0;
trial_timeseries(empties) = {struct('timeseries', {}, 'idx_start', {}, 'count', {})};

nwb.intervals_trials.timeseries_index.data = cumsum(ts_len);
nwb.intervals_trials.timeseries.data = cell2mat(trial_timeseries);

outDest = fullfile(outloc, [identifier '.nwb']);
nwbExport(nwb, outDest);
##### SOURCE END #####
--></body></html>