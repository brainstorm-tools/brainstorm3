function varargout = figure_connect( varargin )
% FIGURE_CONNECT: Creation and callbacks for connectivity figures.
%
% USAGE:  hFig = figure_connect('CreateFigure', FigureId)

% @=============================================================================
% This function is part of the Brainstorm software:
% https://neuroimage.usc.edu/brainstorm
% 
% Copyright (c)2000-2020 University of Southern California & McGill University
% This software is distributed under the terms of the GNU General Public License
% as published by the Free Software Foundation. Further details on the GPLv3
% license can be found at http://www.gnu.org/copyleft/gpl.html.
% 
% FOR RESEARCH PURPOSES ONLY. THE SOFTWARE IS PROVIDED "AS IS," AND THE
% UNIVERSITY OF SOUTHERN CALIFORNIA AND ITS COLLABORATORS DO NOT MAKE ANY
% WARRANTY, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
% MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, NOR DO THEY ASSUME ANY
% LIABILITY OR RESPONSIBILITY FOR THE USE OF THIS SOFTWARE.
%
% For more information type "brainstorm license" at command prompt.
% =============================================================================@
%
% Authors: Sebastien Dery, 2013; Francois Tadel, 2013-2014; Martin Cousineau, 2019

eval(macro_method);
end


%% ===== CREATE FIGURE =====
function hFig = CreateFigure(FigureId) %#ok<DEFNU>
	% Create new figure
    hFig = figure('Visible',               'off', ...
                  'NumberTitle',           'off', ...
                  'IntegerHandle',         'off', ...
                  'MenuBar',               'none', ...
                  'Toolbar',               'none', ...
                  'DockControls',          'off', ...earnadd
                  'Units',                 'pixels', ...
                  'Color',                 [0 0 0], ...
                  'Pointer',               'arrow', ...
                  'BusyAction',            'queue', ...
                  'Interruptible',         'off', ...
                  'HitTest',               'on', ...
                  'Tag',                   FigureId.Type, ...
                  'Renderer',              'opengl', ...
                  'CloseRequestFcn',       @(h,ev)bst_figures('DeleteFigure',h,ev), ...
                  'KeyPressFcn',           @(h,ev)bst_call(@FigureKeyPressedCallback,h,ev), ...
                  'KeyReleaseFcn',         @(h,ev)bst_call(@FigureKeyReleasedCallback,h,ev), ...
                  'WindowButtonDownFcn',   @FigureMouseDownCallback, ...
                  'WindowButtonMotionFcn', @FigureMouseMoveCallback, ...
                  'WindowButtonUpFcn',     @FigureMouseUpCallback, ...
                  'WindowScrollWheelFcn',  @(h,ev)FigureMouseWheelCallback(h,ev), ...
                  bst_get('ResizeFunction'), []);

	% === CREATE AXES ===
    % Because colormap functions have Axes check
    % (even though they don't actually need it...)
    %     hAxes = axes('Parent',   hFig, ...
    %                  'Units',    'normalized', ...
    %                  'Position', [.05 .05 .9 .9], ...
    %                  'Tag',      'AxesConnect', ...
    %                  'Visible',  'off', ...
    %                  'BusyAction',    'queue', ...
    %                  'Interruptible', 'off');

    % Disable the Java-related warnings after 2019b
    if (bst_get('MatlabVersion') >= 907)
        warning('off', 'MATLAB:ui:javacomponent:FunctionToBeRemoved');
    end
	% Create rendering panel
    [OGL, container] = javacomponent(java_create('org.brainstorm.connect.GraphicsFramework'), [0, 0, 500, 400], hFig);
    % Resize callback
    set(hFig, bst_get('ResizeFunction'), @(h,ev)ResizeCallback(hFig, container));
    % Java callbacks
    set(OGL, 'MouseClickedCallback',    @(h,ev)JavaClickCallback(hFig,ev));
    set(OGL, 'MousePressedCallback',    @(h,ev)FigureMouseDownCallback(hFig,ev));
    set(OGL, 'MouseDraggedCallback',    @(h,ev)FigureMouseMoveCallback(hFig,ev));
    set(OGL, 'MouseReleasedCallback',   @(h,ev)FigureMouseUpCallback(hFig,ev));
    set(OGL, 'KeyPressedCallback',      @(h,ev)FigureKeyPressedCallback(hFig,ev));
    set(OGL, 'KeyReleasedCallback',     @(h,ev)FigureKeyReleasedCallback(hFig,ev));
    
    % Prepare figure appdata
    setappdata(hFig, 'FigureId', FigureId);
    setappdata(hFig, 'hasMoved', 0);
    setappdata(hFig, 'isPlotEditToolbar', 0);
    setappdata(hFig, 'isStatic', 0);
    setappdata(hFig, 'isStaticFreq', 1);
    setappdata(hFig, 'Colormap', db_template('ColormapInfo'));
    setappdata(hFig, 'GraphSelection', []);
    
    % Time-freq specific appdata
    setappdata(hFig, 'Timefreq', db_template('TfInfo'));
    
    % J3D Container
    setappdata(hFig, 'OpenGLDisplay', OGL);
    setappdata(hFig, 'OpenGLContainer', container);
    setappdata(hFig, 'TextDisplayMode', 1);
    setappdata(hFig, 'NodeDisplay', 1);
    setappdata(hFig, 'HierarchyNodeIsVisible', 1);
    setappdata(hFig, 'MeasureLinksIsVisible', 1);
    setappdata(hFig, 'RegionLinksIsVisible', 0);
    setappdata(hFig, 'RegionFunction', 'mean');
    setappdata(hFig, 'LinkTransparency',  0);
        
    % Camera variables
    setappdata(hFig, 'CameraZoom', 6);
    setappdata(hFig, 'CamPitch', 0.5 * 3.1415);
    setappdata(hFig, 'CamYaw', -0.5 * 3.1415);
    setappdata(hFig, 'CameraPosition', [0 0 0]);
    setappdata(hFig, 'CameraTarget', [0 0 0]);
    
	% Add colormap
    bst_colormaps('AddColormapToFigure', hFig, 'connectn');
end


%% ===========================================================================
%  ===== TESTING JOGL CAPABILITIES ===========================================
%  ===========================================================================
function TestJogl()
    Vertices = [
        -4.3036, 0.55084, 0.37807, -4.2925, 0.46912, 0.34834, -4.3009, 0.52579, -0.080146, -4.2815, 0.65337, -0.11452, -4.2788, 0.55743, 0.18876, -4.2631, 0.77343, -0.32397, -4.2764, 0.33733, 0.58536, -4.2468, 0.81022, 0.20699, -4.2256, 1.1065, 0.068545, -4.2638, 0.18128, 0.52805, -4.2161, 0.62409, -0.45361, -4.2331, 1.088, -0.12387, -4.25, 0.35118, 0.42657, -4.2488, 0.41056, 0.27987, -4.2215, 0.54476, 0.66855, -4.2474, 0.38293, 0.36689, -4.2432, 0.63606, 0.095505, -4.241, 0.7016, 0.093118, -4.2389, 0.74776, 0.46698, -4.2372, 0.83206, -0.38836, -4.2632, 0.46707, 0.024778, -4.2516, 0.14892, 0.59353, -4.1807, 0.7041, -0.55281, -4.2282, 0.96437, 0.18337, -4.2253, 0.65428, 0.0098402, -4.2097, 0.31953, 0.22959, -4.1595, 1.0162, 0.44877, -4.1987, 0.24334, 0.76034, -4.2068, 0.26062, 0.35185, -4.2039, 1.0709, -0.24541, -4.1572, 0.37455, 0.82557, -4.1902, 0.43827, -0.30657, -4.242, 0.38697, 0.00090367, -4.1393, 0.83893, -0.60482, -4.1924, 0.032786, 0.52269, -4.1865, 0.13763, 0.28484, -4.1896, 0.32582, 0.34303, -4.189, 0.44227, 0.1296, -4.1848, 1.0749, 0.22713, -4.1751, 0.74906, 0.58987, -4.1805, 0.89891, -0.45508, -4.1216, 0.9659, -0.42562, -4.1663, 0.55127, -0.47302, -4.1581, 0.21253, 0.80164, -4.0828, 1.3807, -0.062288, -4.1364, 0.33454, 0.39353, -4.1767, 0.023359, 0.47284, -4.1484, 0.024352, 0.6052, -4.1481, 0.1815, 0.092151, -4.1788, 0.27416, -0.027737, -4.1417, 0.38401, -0.20343, -4.1411, 0.30918, -0.16216, -4.1318, 0.44132, -0.29866, -4.1823, 1.2057, 0.072625, -4.0723, 1.3355, 0.13744, -4.0479, 1.4047, -0.16731, -4.1007, 1.2441, -0.26942, -4.1137, 0.48603, 0.16379, -4.1408, 0.077415, 0.24204, -4.091, 0.43609, 0.88778, -4.1113, 0.75374, 0.62705, -4.1108, 0.32558, -0.32607, -4.0981, 0.5838, -0.52999, -4.1094, 0.6802, 0.76329, -4.0831, 0.99318, -0.37399, -4.103, 0.69417, -0.63829, -4.0871, 0.7229, 0.57939, -4.1025, 0.27533, -0.47193, -4.0113, 1.2671, 0.39373, -4.1405, 0.85439, 0.61641, -4.1006, 0.13544, -0.050065, -4.0984, 1.1336, 0.27313, -4.1158, 0.7139, 0.64498, -4.091, 0.37204, -0.59941, -4.0547, 0.41878, -0.3318, -4.1851, 0.44476, 0.19056, -4.0854, 0.47199, -0.58387, -4.1231, 0.95949, -0.5283, -4.083, 0.41403, 0.4021, -4.0741, 0.93098, -0.71005, -4.0704, 1.2321, 0.22991, -4.0692, 1.2073, -0.30387, -3.9854, 1.0058, 0.77244, -4.1167, 0.67149, 0.07173, -3.9801, 0.56104, 0.1242, -4.0559, 0.098795, 0.093543, -4.0779, 1.0657, 0.53441, -4.0534, 1.2182, 0.30028, -4.0485, 1.1055, 0.26398, -4.027, 0.083344, -0.035306, -4.0434, 0.80883, 0.8032, -4.0395, 1.266, -0.46829, -4.0932, 0.097656, -0.24291, -4.0499, 0.28423, -0.6658, -4.0252, 0.56707, -0.67331, -4.0867, 0.81645, -0.7156, -3.9989, 0.49138, 0.17146, -4.0233, 1.2606, -0.40859, -3.9667, 1.4784, 0.17901, ...
        -4.0535, 0.49313, -0.34448, -3.9604, 0.61627, -0.83424, -4.0131, 0.61834, 0.14486, -4.0129, 0.27018, 0.88635, -3.9776, 1.1686, -0.28607, -4.0316, 0.49946, 0.33185, -3.9626, 0.86313, 0.0020718, -3.9841, 0.50597, -0.27241, -4.0078, 1.0897, 0.56412, -4.067, 0.063689, 0.7271, -4.1171, 0.016355, 0.52667, -4.1161, 0.66945, 0.035485, -3.9908, 0.38284, -0.80604, -3.9905, 0.53484, 0.3571, -3.9875, 1.065, 0.62183, -3.9778, 0.52782, 0.20125, -3.9763, 1.1651, 0.49823, -4.0702, 0.061532, -0.19317, -3.9093, 1.1304, -0.92868, -4.0065, 0.054297, -0.17078, -3.9619, 0.53088, 0.32156, -3.9572, 1.5052, -0.0035126, -3.8748, 0.68955, 1.0227, -3.9011, 1.246, -0.88717, -3.9851, 0.843, -0.84228, -3.8739, 0.084947, -0.50178, -4.0055, 1.199, -0.61141, -3.9434, 1.3879, -0.21747, -3.9422, 0.19461, 0.83125, -3.938, 0.81202, 0.0091041, -3.9442, 1.4589, 0.26334, -3.8697, 1.2473, 0.70533, -3.9227, 0.34763, -0.85168, -3.8128, 1.3051, -0.19221, -3.9182, 1.5306, -0.35202, -3.8856, 1.2521, 0.6208, -3.9154, 1.476, -0.48175, -3.9719, 0.80158, -0.81432, -3.9845, 1.4482, -0.1732, -3.9416, 0.1684, -0.68642, -3.7915, 1.0787, 0.93631, -3.9033, 0.075103, 0.053297, -3.8973, 0.06023, 0.6892, -3.8702, 0.51964, 1.0354, -3.8576, 0.71149, 0.10498, -3.89, 0.66669, -0.90083, -3.8775, 1.3333, -0.60792, -3.8853, 1.1004, 0.54212, -3.8848, 1.3333, -0.67802, -3.8485, 1.6867, -0.15044, -3.8822, 1.4543, 0.30046, -3.9223, 0.2895, 0.85612, -3.8817, 0.31258, 0.79714, -3.9622, 0.65499, -0.76868, -3.8074, 0.094358, -0.33482, -3.9517, 0.56956, -0.335, -3.8755, 0.10722, 0.81115, -3.8784, 1.1095, 0.47665, -3.81, 0.38276, -0.88886, -3.8132, 1.0652, 0.47054, -3.8303, 1.4609, -0.83385, -3.8357, 0.33091, 0.78911, -3.8885, 1.436, -0.27996, -4.0723, 0.049236, 0.25381, -3.8972, 0.59169, -0.34504, -3.9114, 1.5022, 0.22227, -3.7194, 0.040691, 0.10062, -3.8462, 1.3555, 0.36836, -3.7418, 0.64189, 0.25867, -3.8025, 0.44237, -0.85535, -3.8086, 1.2633, 0.78394, -3.8647, 0.12461, -0.07116, -3.6998, 0.88578, -0.41864, -3.8402, 1.7052, -0.32016, -3.8379, 0.8469, -0.70105, -3.8334, 1.4601, -0.063736, -3.8308, 1.5036, 0.13301, -3.7484, 0.81449, -0.94911, -3.8174, 0.17414, 0.89761, -3.7197, 0.76188, 0.063444, -3.8231, 0.10021, -0.62843, -3.8142, 1.6924, -0.061733, -3.7645, 0.17053, -0.24287, -3.8026, 1.4304, -0.5842, -3.798, 0.1301, -0.0010502, -3.6227, 0.091273, 0.89823, -3.7605, 1.3728, 0.48717, -3.793, 0.25807, -0.043582, -3.7294, 0.74768, -0.9734, -3.7886, 1.7028, -0.4193, -3.7135, 1.0778, 0.34219, -3.785, 0.50129, 1.0361, -3.6903, 0.8757, -0.91456, -3.7776, 0.23276, -0.12767, -3.7417, 0.41832, 0.80876, -3.8776, 1.0666, -0.96352, -3.7712, 1.3545, -0.99672, -3.7663, 1.5553, -0.67974, -3.8393, 1.6437, -0.099391, -3.7648, 0.47299, -0.89321, ...
        -3.862, 0.038174, 0.36841, -3.762, 1.2858, 0.46424, -3.712, 0.68334, 0.18057, -3.7932, 0.70269, 1.0688, -3.8096, 1.4418, 0.27875, -3.7261, 0.66699, 1.0961, -3.7567, 0.46271, -0.79959, -3.7413, 1.436, 0.6195, -3.7181, 0.82422, -0.39811, -3.7401, 1.7777, -0.083011, -3.7579, 1.6475, -0.50067, -3.7316, 0.075535, -0.4218, -3.8102, 1.5143, -0.7713, -3.8248, 1.0141, -0.95124, -3.727, 0.85178, -0.55739, -3.6952, 0.31143, -0.23392, -3.7232, 0.98963, -0.85349, -3.7221, 0.095636, 0.042753, -3.6859, 1.3108, -0.071924, -3.7873, 0.19532, -0.011899, -3.7191, 1.8435, -0.2253, -3.7602, 0.2743, 0.92432, -3.5912, 0.97732, -0.75594, -3.6815, 0.94426, -0.46455, -3.6629, 1.431, 0.12349, -3.7153, 0.75007, 0.056773, -3.7775, 0.071663, -0.55527, -3.7119, 0.24297, -0.14068, -3.7352, 1.3932, -0.12323, -3.6499, 1.2209, 0.23397, -3.7038, 0.15345, -0.24977, -3.6934, 1.0055, -0.60833, -3.7122, 1.4865, -0.56364, -3.6923, 1.0401, 1.041, -3.6903, 1.03, -0.70103, -3.6893, 0.34701, 0.29135, -3.6658, 1.0463, -0.91898, -3.7591, 0.565, -0.94019, -3.6941, 0.40395, -0.17296, -3.6816, 0.43249, -0.92685, -3.6084, 1.6913, -0.93196, -3.4959, 1.956, -0.3224, -3.7706, 1.4453, 0.19113, -3.6799, 0.42534, 0.88545, -3.7198, 1.5971, 0.10485, -3.6769, 0.94906, -0.53393, -3.6694, 0.72019, 0.12574, -3.5857, 0.065048, 0.6985, -3.6754, 0.22123, 1.0497, -3.6746, 0.17749, -0.13805, -3.6716, 1.0299, -0.81259, -3.6699, 1.5726, 0.38503, -3.5539, 1.8303, -0.53116, -3.5475, 1.9472, -0.26506, -3.6567, 1.3656, 0.0054122, -3.591, 1.3158, 0.43023, -3.6484, 1.4913, 0.69012, -3.6425, 1.6505, 0.35317, -3.6452, 1.7153, 0.13451, -3.6448, 0.23046, -0.037974, -3.6421, 1.3196, 0.063218, -3.6384, 0.31523, 0.19042, -3.76, 0.444, 0.99113, -3.68, 0.33898, 1.01, -3.6322, 0.84188, 1.0456, -3.6308, 1.2432, 0.34186, -3.5812, 1.1164, 0.2285, -3.6257, 1.8061, -0.71562, -3.66, 0.49163, 0.80258, -3.4472, 1.0555, -0.86367, -3.6234, 0.962, 1.0839, -3.6233, 1.6082, 0.41816, -3.6499, 1.0942, 0.30503, -3.6214, 1.7944, -0.01096, -3.6184, 0.19042, 0.049029, -3.6183, 1.325, 0.36218, -3.5191, 0.1559, -0.79909, -3.6947, 0.13928, 0.96372, -3.613, 1.018, -0.78473, -3.6124, 0.20115, -0.858, -3.6117, 1.3126, 0.23261, -3.5203, 1.6547, -0.43012, -3.5998, 1.4258, 0.50734, -3.596, 1.416, 0.43116, -3.4588, 1.8054, -0.97979, -3.5949, 0.35598, 0.1792, -3.6115, 0.36269, 0.30214, -3.5907, 0.34176, 1.2108, -3.5615, 1.3012, 0.90557, -3.7071, 0.2639, 0.094043, -3.5912, 1.3054, 0.012864, -3.5183, 1.0798, 1.12, -3.6306, 0.65561, 1.048, -3.5841, 0.63997, 0.96256, -3.5808, 1.2133, 0.18541, -3.441, 1.2364, -1.0183, -3.5028, 0.41465, 0.2836, -3.5087, 1.7387, 0.34748, -3.5695, 0.85105, -0.9823, -3.5948, 0.5163, 1.0889, ...
        -3.452, 0.49516, -0.91234, -3.5644, 0.13967, -0.59928, -3.4887, 1.3767, 0.51671, -3.5713, 0.58852, 1.2252, -3.6059, 1.4838, 0.45741, -3.6617, 0.25687, 0.099566, -3.5546, 1.8292, -0.83568, -3.5533, 1.5877, 0.63926, -3.5519, 0.91383, 1.0303, -3.5518, 1.2579, 0.10251, -3.5491, 0.85278, 0.95932, -3.5465, 1.54, 0.76156, -3.5419, 0.12499, -0.17467, -3.5415, 0.61304, 0.79909, -3.546, 1.3655, -1.0705, -3.5314, 0.050042, 0.15404, -3.4451, 0.10612, 0.063856, -3.5177, 0.79889, 1.0882, -3.5292, 0.76029, 1.2876, -3.5162, 1.5571, 0.5451, -3.5139, 0.28379, -0.0066854, -3.455, 0.14399, 1.1922, -3.6181, 1.8131, -0.61604, -3.4792, 0.70805, 0.85926, -3.4783, 0.77286, 0.75182, -3.5007, 1.7511, 0.13103, -3.4978, 0.65863, 0.80037, -3.4169, 1.8271, -0.011441, -3.454, 0.80963, 0.87678, -3.5474, 0.042665, 0.48989, -3.4922, 1.0463, -0.81282, -3.5228, 0.94824, -0.95347, -3.32, 1.7943, 0.77106, -3.494, 1.3536, 0.48721, -3.5292, 0.82604, 1.2336, -3.3883, 0.35389, 1.4466, -3.4812, 0.88481, -0.95676, -3.4768, 0.18587, 1.2491, -3.3204, 1.0413, 1.0624, -3.4733, 0.14952, -0.39294, -3.4709, 0.84654, 0.78684, -3.4224, 1.9988, -0.80562, -3.4686, 1.141, -0.95501, -3.4769, 0.16405, -0.1486, -3.4653, 0.78524, 1.3714, -3.5242, 1.0505, -0.82544, -3.4496, 1.6214, 0.41385, -3.3931, 1.5171, 0.95559, -3.4557, 1.6705, 0.58914, -3.4529, 0.16128, -0.55331, -3.5113, 0.099111, -0.29105, -3.4497, 0.11606, 0.99633, -3.4476, 0.64549, -0.91649, -3.4587, 0.57056, 1.4063, -3.3936, 1.702, 0.058595, -3.442, 0.45418, 0.19421, -3.4407, 1.7782, -0.0032087, -3.4399, 1.2324, 1.0918, -3.4374, 0.35668, 0.15423, -3.4353, 1.0591, 1.116, -3.59, 0.27647, -0.90467, -3.4321, 0.87808, 0.99865, -3.4278, 0.10041, 0.77835, -3.3423, 2.1033, -0.60728, -3.5061, 0.13388, -0.68799, -3.4177, 1.691, -1.0256, -3.4174, 0.31379, -0.063671, -3.5142, 0.22731, -0.86942, -3.2946, 2.025, -0.13042, -3.4213, 1.3509, 0.50932, -3.3676, 1.3767, 0.47776, -3.4063, 0.14493, 0.66049, -3.4324, 0.8692, 0.78793, -3.3839, 1.3286, -1.049, -3.39, 0.91848, 0.76492, -3.3992, 1.9674, -0.89172, -3.3965, 0.50451, 0.26617, -3.3654, 0.16235, 0.58552, -3.3907, 2.0229, -0.1877, -3.3343, 0.30884, -0.33159, -3.3645, 0.16547, 0.91101, -3.3837, 0.11205, 0.50593, -3.3807, 1.4273, 0.4418, -3.4207, 0.17751, 0.048354, -3.3722, 0.2593, -0.37694, -3.4392, 1.9454, -0.45815, -3.3687, 1.1501, -0.80805, -3.3957, 0.42686, 0.050085, -3.2475, 0.90865, 1.4994, -3.3621, 0.39185, -0.87427, -3.3604, 1.3627, 1.0777, -3.3974, 0.78152, -0.87739, -3.3575, 1.787, -0.97528, -3.3534, 0.98898, -0.8799, -3.353, 0.17953, -0.41148, -3.3949, 1.7151, 0.33844, -3.3805, 0.2167, 0.65625, -3.351, 1.6027, -1.0322, -3.3555, 1.9191, 0.10794, -3.2835, 1.7036, 0.0046661, ...
        -3.3455, 0.26989, 1.4417, -3.3453, 0.75161, -0.85022, -3.375, 1.8001, -0.40133, -3.2617, 0.4824, 0.20753, -3.3422, 0.91998, 0.99537, -3.3774, 1.1357, 1.1225, -3.3392, 1.7391, 0.20661, -3.3288, 0.9429, 0.781, -3.2505, 1.6585, 0.30478, -3.4019, 2.0565, -0.53812, -3.441, 1.9289, -0.34748, -3.3147, 1.5152, 1.0032, -3.3225, 1.123, -0.81286, -3.3138, 1.7043, 0.44752, -3.3203, 0.63644, -0.90384, -3.3197, 1.0144, 1.355, -3.3467, 0.5248, 0.2688, -3.3188, 0.15708, 1.1764, -3.2805, 1.0132, -0.77036, -3.3135, 0.68192, 1.5173, -3.3119, 1.927, 0.3335, -3.3417, 0.98619, 0.9929, -3.2183, 1.4772, 0.36127, -3.3587, 1.2068, -0.92315, -3.3056, 1.7042, -0.8808, -3.2794, 0.18139, -0.089413, -3.3341, 1.2762, -1.0052, -3.297, 0.13576, 0.16873, -3.3014, 1.8165, 0.11694, -3.2481, 0.1942, 1.2253, -3.2248, 1.9684, -0.081461, -3.2976, 0.11305, 0.58335, -3.3674, 1.9168, 0.20154, -3.2959, 2.0232, 0.1319, -3.3325, 0.27285, 0.77736, -3.2723, 1.7455, 0.84855, -3.3054, 1.9411, -0.96, -3.3577, 0.9809, 1.209, -3.3415, 1.8233, 0.66612, -3.2268, 0.67409, 0.013843, -3.2872, 1.1416, -0.71775, -3.2867, 0.557, 0.23196, -3.286, 0.47622, -0.87765, -3.2837, 2.0156, -0.40356, -3.2475, 0.2239, 1.4174, -3.2732, 1.669, -0.7876, -3.3059, 0.42681, -0.2221, -3.2958, 1.8189, 0.50039, -3.2158, 1.7503, -0.020311, -3.2725, 0.495, 1.5795, -3.2725, 0.31922, 0.95942, -3.2495, 0.37701, -0.77928, -3.1652, 2.184, -0.44502, -3.2444, 0.50459, -0.040909, -3.267, 0.87351, -0.66465, -3.2008, 0.43323, 1.6338, -3.2412, 0.38363, -0.82995, -3.2646, 1.2348, 1.1156, -3.3235, 0.23752, 0.099228, -3.2603, 1.7765, 0.23187, -3.3185, 1.9263, 0.080309, -3.2367, 1.1826, -0.54654, -3.2831, 1.2254, -0.58179, -3.1659, 1.9021, -0.35257, -3.2545, 1.7439, -0.87522, -3.2484, 0.22883, -0.003545, -3.4217, 0.13097, -0.7307, -3.2524, 0.35803, 0.18371, -3.3058, 2.0321, 0.2633, -3.2633, 1.5517, -0.94724, -3.243, 0.94718, 0.83002, -3.2049, 0.20097, 0.27164, -3.1377, 0.93723, 0.98085, -3.24, 0.10127, 0.72691, -3.2399, 1.9326, 0.39176, -3.1354, 2.2238, -0.52903, -3.3715, 0.94857, 1.3778, -3.239, 2.0649, -0.26698, -3.1871, 1.1473, 1.3836, -3.1863, 2.0597, -0.02101, -3.1909, 0.7028, 0.17924, -3.2682, 1.3136, -0.95415, -3.2444, 1.411, -0.95441, -3.2229, 1.5852, 0.40589, -3.2021, 0.36641, 1.061, -3.273, 0.14033, -0.16443, -3.3209, 2.0515, -0.23165, -3.2636, 0.83126, -0.86184, -3.2144, 1.9108, -0.92429, -3.2951, 1.9842, -0.91013, -3.3891, 0.090868, 0.16436, -3.1575, 0.31275, 1.2635, -3.2226, 1.6694, 0.88825, -3.2076, 1.567, -0.73559, -3.2065, 1.049, 1.1624, -3.2844, 0.097913, 0.46965, -3.2787, 2.0697, -0.82263, -3.2044, 0.94385, -0.84056, -3.1718, 0.71013, 1.5174, -3.2799, 2.0052, 0.35971, ...
        -3.2359, 1.3701, 1.0881, -3.1352, 0.93483, 1.0639, -3.2329, 0.92506, -0.54384, -3.2644, 1.0806, 1.2986, -3.192, 1.8302, 0.33825, -3.1905, 1.9343, -0.03195, -3.1295, 0.27632, 1.4911, -3.1872, 1.1006, -0.44585, -3.2188, 0.24849, -0.79127, -3.1824, 1.4087, 1.0016, -3.2402, 1.274, -0.73269, -3.151, 1.1189, -0.845, -3.1748, 1.9114, -0.3797, -3.1075, 0.11189, 0.11427, -3.1817, 2.042, -0.083718, -3.2154, 1.6163, -0.82497, -3.1725, 0.50483, 0.092781, -3.1721, 0.30049, 0.38527, -3.0923, 0.16227, 0.19071, -3.1093, 1.3025, -0.60203, -3.1745, 1.8316, -0.030011, -3.2863, 1.2469, -0.68498, -3.17, 2.139, 0.077394, -3.1682, 1.6401, 1.026, -3.1662, 0.30469, 1.5685, -3.0833, 2.2329, 0.2532, -3.1635, 0.75271, 1.5413, -3.2095, 0.67139, 0.045152, -3.1624, 0.93233, -0.91289, -3.1108, 0.12398, 0.57186, -3.1608, 0.53273, 0.25662, -3.1601, 1.4774, 0.31775, -3.1151, 1.4802, -1.0113, -3.1056, 1.3967, -0.64393, -3.1587, 0.28824, 0.34039, -3.1585, 0.96131, 0.88886, -3.188, 1.6867, -1.0393, -3.1921, 1.9038, 0.53967, -3.151, 0.8749, 1.5821, -3.2325, 1.8427, 0.84581, -3.1502, 1.9226, -1.0318, -3.0464, 2.1802, -0.17612, -3.2046, 2.0904, 0.39155, -3.1625, 1.2251, 1.3386, -3.1429, 1.5917, 0.89484, -3.1402, 0.52063, 1.6775, -3.0956, 0.163, 0.49863, -3.1316, 1.4193, 0.86795, -3.1545, 0.090904, 0.74862, -3.0727, 0.64024, 1.5245, -3.138, 1.4726, 1.1573, -3.1374, 2.0123, -0.9421, -3.1373, 2.1692, -0.68211, -3.0576, 0.45089, 0.34543, -3.1094, 1.4957, 0.87429, -3.1548, 0.40388, 1.1383, -3.188, 1.0177, -0.46189, -3.1311, 2.0981, -0.80074, -3.1472, 0.1168, -0.35144, -3.1447, 1.0735, -0.93947, -3.0921, 1.1313, -0.37961, -3.1212, 2.1443, -0.12702, -3.0391, 2.1509, 0.50883, -3.0057, 0.14361, 1.1676, -3.1946, 1.1882, 1.0563, -3.1179, 1.4861, -0.67351, -2.961, 0.14433, -0.56371, -3.1164, 1.1659, -0.78585, -3.1007, 0.33721, 1.2602, -3.1159, 1.4503, 1.2686, -3.1148, 2.0074, 0.82964, -3.1121, 2.0335, 0.73281, -3.1114, 2.0034, -0.8357, -3.1616, 0.17575, 1.0346, -3.1087, 1.0897, -0.95478, -3.1082, 1.4087, 1.0934, -3.0966, 2.0407, -0.78179, -3.0783, 2.1055, -1.0409, -3.0206, 0.27725, -0.74409, -3.1599, 0.086139, -0.038143, -3.1093, 1.1656, -0.73862, -3.0026, 0.29219, 0.28219, -3.0553, 0.61088, 1.6066, -3.077, 0.60863, 1.6642, -3.1165, 1.8471, 1.0079, -3.0962, 0.61106, -0.86325, -3.1327, 1.0483, -0.55123, -3.0923, 2.0663, -0.29732, -2.9622, 1.9438, -0.3358, -3.089, 1.5382, 0.30259, -3.1466, 0.66484, 0.23191, -3.1054, 1.4355, 0.82403, -3.0822, 0.643, 0.21141, -3.132, 1.6329, -1.0716, -2.9476, 2.2683, 0.49039, -2.9801, 2.1547, -0.23217, -3.0758, 2.155, -0.74661, -3.0743, 1.3843, 1.1301, -3.0736, 0.28837, 0.49299, -3.072, 1.2463, -0.5288, ...
        -3.0704, 0.17634, 0.5844, -3.0864, 1.4131, -0.9738, -3.1784, 0.81101, -0.91057, -3.0537, 1.4045, -0.59093, -3.0623, 1.691, 0.33569, -3.0617, 0.18781, 1.2529, -2.9655, 2.2516, -0.044133, -2.9644, 1.6423, 0.38672, -3.1153, 1.6708, 1.1623, -3.0607, 1.0508, 0.85535, -3.0785, 0.46519, 1.7539, -3.0534, 1.3628, 0.8691, -2.8784, 0.32908, 1.8616, -3.0867, 0.55489, 0.17696, -3.05, 1.4005, -0.65006, -3.0492, 0.67609, 1.7373, -3.0469, 0.33334, 1.6664, -3.0464, 2.1949, 0.14407, -3.0385, 1.8205, 0.4365, -2.9803, 0.34199, 1.4586, -3.1112, 1.5349, -1.053, -3.04, 1.272, 0.8448, -3.0565, 0.96765, 0.06783, -3.0387, 1.1225, -0.37133, -2.9455, 2.102, 0.81121, -3.1992, 1.8141, 0.47765, -3.047, 1.5512, 0.32353, -3.0334, 0.19417, 0.7836, -3.0852, 0.3113, 0.56374, -3.0178, 1.0328, 0.81397, -3.0262, 2.1953, -0.99387, -3.0237, 1.6148, 0.32567, -3.0223, 1.1102, -0.50081, -2.9131, 2.0868, 0.72368, -3.1018, 1.5027, 1.2943, -2.9373, 0.31363, 1.6471, -3.0216, 0.1412, -0.29119, -3.0982, 1.1628, 1.4929, -2.9443, 0.14695, 0.248, -3.0313, 0.6756, 0.34718, -3.0173, 2.2654, -0.47393, -3.0018, 1.8566, 1.0785, -2.9495, 0.95643, -0.032375, -3.0133, 1.2736, 1.4895, -3.0787, 1.4215, 1.2878, -3.0567, 0.097652, 0.10741, -3.0049, 1.3016, -0.83238, -2.9676, 1.1308, 0.73905, -2.9264, 1.1756, 0.75669, -3.087, 1.1422, 1.0692, -3.0005, 1.1094, -0.3958, -2.9997, 0.29202, 0.44084, -2.9962, 1.0375, -0.94228, -2.9854, 0.33087, 1.7286, -2.9839, 0.3316, 0.79786, -2.9883, 2.2502, -0.69912, -2.9864, 0.51525, -0.78766, -2.986, 1.747, 1.2638, -2.897, 1.0445, 1.8735, -2.9824, 0.20318, -0.090913, -2.9717, 2.0585, 0.90714, -2.9821, 0.58409, 0.2267, -2.9795, 0.18995, -0.66477, -2.9759, 1.2849, -0.58088, -2.9754, 1.3217, 0.8837, -3.0294, 0.12591, 0.95934, -3.0293, 0.98563, 0.20189, -2.9173, 0.14965, 0.63889, -2.9699, 1.3598, 0.99941, -2.9695, 0.20361, -0.19838, -2.8028, 1.6644, 1.5987, -2.9684, 0.64263, 0.26832, -3.0142, 0.20303, 1.4354, -2.9675, 2.2533, -0.90721, -3.0423, 2.0763, -1.1097, -2.9622, 0.49802, -0.15597, -2.9873, 0.47543, 0.23458, -2.9605, 1.0386, 0.11372, -2.9057, 2.0943, 0.15177, -2.9703, 0.4288, -0.12293, -2.956, 0.1829, -0.0035258, -3.0494, 2.194, 0.075313, -2.954, 0.41745, 0.41118, -2.9529, 0.73881, 1.829, -2.9508, 0.9213, -0.0090938, -2.8999, 2.259, -0.079937, -2.9569, 0.567, 0.45774, -2.946, 0.38665, -0.69654, -2.9407, 1.8919, 1.044, -2.9417, 1.9939, -0.33073, -2.9395, 0.31893, 0.86098, -2.9337, 0.25294, 0.31369, -2.953, 0.33253, -0.083775, -2.907, 0.17961, -0.59566, -2.9633, 0.31353, -0.15385, -2.8468, 2.4001, 0.27516, -2.8804, 1.9936, -0.2742, -2.8834, 0.16524, 0.73883, -2.9319, 0.56638, -0.51414, -2.8145, 1.7876, 0.54111, ...
        -2.927, 0.16196, 1.0692, -2.9265, 0.13513, 0.13109, -2.9136, 0.59112, -0.48581, -2.9256, 1.3346, 1.1309, -2.9866, 0.94886, 0.22509, -2.9494, 0.48832, -0.32287, -3.0478, 0.79504, -0.89788, -2.9216, 0.24822, -0.078168, -3.0315, 1.3041, 1.3458, -2.9157, 0.2407, 0.93469, -2.9154, 0.5043, -0.68345, -2.8833, 0.17804, -0.5047, -2.8823, 1.823, 1.3379, -2.9107, 1.013, 0.0079002, -3.0533, 1.2543, 1.1214, -2.8827, 0.23058, -0.55778, -2.8268, 1.7748, 0.50382, -2.9063, 1.0515, 0.17358, -2.9061, 0.61533, 0.34519, -2.9051, 0.15359, 1.5656, -2.9079, 0.66795, -0.62054, -2.9192, 0.33619, 1.58, -2.907, 0.56796, -0.31598, -2.9007, 1.8105, 0.54703, -2.8975, 0.19394, 0.30262, -2.8956, 0.88992, 0.13715, -2.8747, 0.23853, -0.46399, -2.8912, 0.5725, -0.7717, -2.9411, 2.2913, 0.17658, -2.8693, 0.61536, 0.22991, -2.8161, 0.44952, 1.923, -2.6488, 1.4257, 1.5665, -2.886, 1.2757, 1.7265, -2.8848, 0.59659, -0.51011, -2.8823, 1.469, 1.52, -2.8806, 2.2666, -0.33859, -2.8026, 0.99836, -0.89538, -3.0729, 2.1669, -0.38019, -2.8236, 0.12172, 1.5829, -2.8501, 0.91618, 1.9012, -2.8673, 2.2317, 0.030528, -2.8744, 2.2574, 0.58738, -2.8719, 1.188, -0.44623, -2.8714, 0.38668, -0.35535, -2.7813, 2.4269, 0.5226, -2.8705, 2.2743, -0.90877, -2.8101, 0.11974, 0.60017, -2.8339, 1.3433, 1.5828, -2.9002, 1.2434, -0.93737, -2.9348, 2.0139, 1.0088, -2.8651, 1.1392, -0.43139, -2.9627, 1.1233, -0.90365, -2.8776, 1.2509, -0.64586, -3.112, 2.2092, 0.3465, -3.0387, 1.1609, -0.89424, -2.8583, 0.25669, 1.7154, -2.8548, 2.0644, -1.1539, -2.8947, 0.55592, -0.64222, -2.8108, 2.0638, 1.2113, -2.7712, 1.3551, 1.378, -2.7767, 0.94542, -0.88658, -2.8447, 1.1517, -0.58971, -2.8235, 0.37504, -0.6347, -2.8434, 0.29702, 0.41455, -2.8421, 2.2098, -1.1026, -2.8417, 2.2133, -0.29126, -2.8391, 0.42035, 0.25453, -3.0371, 2.075, 0.51745, -2.9105, 2.3127, -0.5131, -2.7881, 2.1176, -0.15163, -2.8312, 1.552, 1.6277, -2.8294, 0.89104, 0.0023992, -2.8279, 0.93746, 0.29248, -2.7986, 1.2412, 1.8634, -2.8196, 0.29456, -0.29957, -2.6763, 2.0889, 0.17269, -2.6957, 0.22412, 0.27966, -2.7993, 0.29195, -0.41828, -2.9195, 1.3144, -0.97768, -2.8283, 0.76006, 1.8284, -2.8421, 0.50409, -0.71667, -2.7256, 2.4005, 0.20994, -2.8391, 2.2374, -0.012049, -2.8076, 0.35611, 1.905, -2.6935, 1.423, 0.8142, -2.8575, 1.2588, 0.73387, -2.7237, 1.4232, 1.075, -2.8741, 2.102, 0.94939, -2.7963, 1.2349, -0.53158, -2.8785, 0.27449, 0.85581, -2.7177, 0.88468, 0.055584, -2.7933, 0.84914, 1.8497, -2.6805, 0.3698, 0.3431, -2.7872, 1.4635, 1.5927, -2.8507, 1.977, -0.27859, -2.8483, 1.3213, 1.6821, -2.8781, 0.50574, 0.39951, -2.658, 2.5124, 0.41233, -2.7733, 1.1287, -0.73483, -2.6913, 1.2144, -0.40933, ...
        -2.7422, 0.8362, 1.6877, -2.7685, 2.126, 0.98137, -2.7345, 1.2506, -0.56881, -2.7654, 2.0432, 0.12667, -2.7644, 0.77734, 1.7334, -2.8036, 0.61326, 0.20113, -2.7634, 0.92391, 1.984, -2.706, 1.8683, 0.57623, -2.8364, 2.0496, 0.71026, -2.7519, 0.22982, 1.7759, -2.7498, 2.2264, -1.0514, -2.7494, 0.83376, 1.5221, -2.7042, 1.4519, 1.8102, -2.809, 0.26658, 0.85131, -2.7307, 1.3351, 1.6054, -2.8014, 0.15626, -0.15223, -2.6457, 2.4954, 0.31845, -2.7451, 0.32847, -0.6789, -2.8402, 2.2901, 0.15724, -2.7951, 2.2527, -0.82706, -2.7384, 0.13847, 1.1482, -2.8191, 2.1421, 0.63804, -2.8273, 0.15685, 1.1025, -2.7378, 0.23956, -0.27108, -2.6612, 0.19523, 1.7077, -2.7336, 0.81836, 1.9033, -2.7507, 0.11892, 0.19504, -2.7318, 2.192, -0.78343, -2.7316, 1.529, 1.8064, -2.8098, 0.61108, 0.25694, -2.725, 0.77357, 1.4907, -2.7272, 0.42568, 1.8927, -2.7679, 0.23164, -0.44636, -2.7224, 2.0313, -0.1674, -2.6785, 1.4083, 0.85554, -2.787, 0.91029, -0.06645, -2.8591, 1.5039, -1.0169, -2.7152, 2.1636, 1.1259, -2.7149, 0.99322, 2.0454, -2.7569, 1.9865, 0.18376, -2.7124, 0.14945, 0.25769, -2.7118, 2.0332, -0.082246, -2.7117, 0.24044, -0.3501, -2.6206, 0.95417, 0.24228, -2.7083, 1.3387, 1.448, -2.6653, 1.2407, -0.43474, -2.7055, 2.2364, -0.31501, -2.7014, 2.1826, -0.87863, -2.7034, 1.5011, 1.0564, -2.6973, 0.19306, 0.76284, -2.6891, 1.855, -1.1478, -2.5098, 0.27148, 0.21402, -2.6596, 2.0185, -0.69909, -2.7141, 1.0319, 0.27479, -2.6591, 0.61183, 2.0094, -2.692, 2.3511, -0.067848, -2.6444, 0.77785, 1.2946, -2.6835, 1.2817, 1.8167, -2.6891, 1.1735, -0.53793, -2.6886, 0.20527, 0.82659, -2.7172, 2.3582, 0.74212, -2.6857, 2.1315, 1.0088, -2.6853, 2.0227, 0.055489, -2.7897, 1.7388, -1.1193, -2.6439, 1.9654, 0.73499, -2.8174, 1.4276, 1.3657, -2.6544, 1.4095, 1.7504, -2.786, 0.14061, 0.53223, -2.6619, 2.0512, 0.9203, -2.6737, 0.77896, 1.6452, -2.5816, 2.1821, 1.3416, -2.6714, 2.0967, -0.19155, -2.6703, 0.19582, -0.64211, -2.6692, 0.6987, 1.5243, -2.6691, 1.4752, 1.883, -2.7527, 0.13293, -0.070451, -2.5516, 2.0864, -1.1262, -2.6658, 2.1733, 0.97927, -2.6609, 1.9943, 0.15, -2.7742, 0.14586, 0.73121, -2.5808, 0.78225, 2.1494, -2.6587, 2.2583, 0.93686, -2.6584, 2.3027, -0.0044655, -2.7675, 0.10947, 1.5328, -2.5028, 0.2495, 0.30111, -2.6566, 0.24065, 1.7903, -2.6527, 0.36862, 1.8357, -2.6525, 0.91517, 0.22211, -2.5944, 1.464, 0.86107, -2.665, 0.45004, 0.13462, -2.6467, 1.0196, 0.26005, -2.646, 1.5444, -0.99431, -2.5319, 0.13032, 0.13284, -2.596, 1.7457, 1.7967, -2.6449, 2.0389, -0.77378, -2.6401, 1.0713, 2.057, -2.5284, 2.1485, -1.0664, -2.5849, 2.3114, 0.94296, -2.6891, 0.16698, -0.50734, -2.636, 1.4378, 1.0433, ...
        -2.6394, 1.9869, -0.075697, -2.6812, 2.0345, 1.4093, -2.5426, 0.19, 0.22433, -2.6295, 0.65036, 0.98744, -2.5367, 2.4132, 0.27128, -2.625, 2.2296, 1.0897, -2.6744, 2.1472, -0.56224, -2.624, 0.18705, -0.62102, -2.5162, 2.1633, -0.97904, -2.6654, 1.2943, 1.6366, -2.618, 0.14934, 0.8606, -2.5678, 0.4496, 2.0495, -2.6162, 1.2029, -0.46802, -2.5448, 1.4329, 0.91236, -2.6077, 0.79901, -0.78391, -2.5632, 0.33894, 0.33538, -2.523, 1.1333, 0.19149, -2.6312, 0.95215, -0.058436, -2.6707, 2.2987, -0.1061, -2.6594, 2.4543, -0.17644, -2.7287, 1.1055, 0.054277, -2.6021, 1.1558, 1.9892, -2.6666, 2.2329, -0.37477, -2.616, 1.9663, -0.61148, -2.6231, 0.67331, 0.91985, -2.652, 0.40926, 0.13823, -2.598, 0.87956, 2.1398, -2.7063, 0.80184, 1.4914, -2.5966, 1.0358, -0.054158, -2.594, 2.0248, -0.7821, -2.5933, 0.53757, 1.149, -2.5415, 1.1667, 1.4628, -2.618, 1.5622, -0.87529, -2.6373, 0.14171, -0.60954, -2.5912, 2.5344, 0.51382, -2.6791, 0.69487, 1.8971, -2.5903, 2.2396, -0.65908, -2.5898, 0.46086, 1.3306, -2.627, 1.3985, 1.1795, -2.546, 2.0158, 1.5518, -2.5637, 0.13513, 1.1935, -2.5856, 2.0088, -0.61555, -2.5854, 1.475, 1.2092, -2.6374, 1.5075, 1.066, -2.585, 0.70527, -0.77597, -2.5633, 0.35903, 1.4129, -2.5973, 2.0511, -0.71627, -2.5816, 0.14308, -0.16329, -2.5811, 2.5039, 0.60409, -2.5808, 2.4266, -0.34762, -2.5268, 1.5424, 1.9977, -2.5785, 1.9155, 0.089232, -2.5941, 0.2562, -0.31758, -2.576, 0.41973, 1.9652, -2.5755, 1.2185, -0.95801, -2.6536, 0.14868, 1.5696, -2.575, 0.15157, -0.57341, -2.5745, 0.24173, 1.69, -2.6755, 2.3875, -0.0046106, -2.6035, 0.4546, 1.7541, -2.5225, 0.51736, 1.5088, -2.5675, 1.4631, 1.3713, -2.5123, 1.5857, -0.86572, -2.5664, 0.14675, 0.7128, -2.5632, 2.4729, 0.29837, -2.5198, 2.1172, 0.12907, -2.5628, 1.9691, -1.1457, -2.5009, 1.909, -0.50308, -2.6672, 0.86138, -0.8526, -2.5592, 1.9284, -0.53091, -2.4377, 1.144, 0.15614, -2.5635, 0.75035, 1.2343, -2.4727, 2.513, 0.22687, -2.5511, 0.7967, -0.80152, -2.502, 1.2091, -0.51664, -2.5503, 2.0632, -0.79901, -2.5502, 0.73523, 0.84453, -2.5496, 1.9343, -0.038657, -2.5414, 0.11216, -0.55428, -2.5585, 0.3841, 0.22315, -2.6313, 0.94364, -0.87142, -2.5437, 0.39262, 1.9991, -2.5437, 1.3378, 1.8053, -2.5551, 2.2406, -0.87883, -2.4786, 2.656, -0.22991, -2.5418, 0.45784, 1.2402, -2.5384, 0.12355, -0.058652, -2.5374, 0.14964, -0.51232, -2.4968, 0.19595, 1.3212, -2.557, 2.2271, -0.55742, -2.5332, 1.1812, 0.067434, -2.491, 1.3719, 1.0021, -2.4947, 0.77371, 1.1027, -2.4145, 0.53671, 1.4984, -2.5423, 1.4022, 1.6242, -2.4808, 2.5367, -0.67699, -2.5296, 1.6393, -0.97699, -2.5274, 0.28067, 1.4682, -2.5201, 1.3901, 1.7076, -2.5239, 0.33612, 1.5536, ...
        -2.5228, 0.28938, -0.28263 ];
    Indices = [
        449, 490, 554, 449, 554, 483, 449, 428, 490, 428, 379, 416, 449, 483, 433, 449, 433, 395, 449, 395, 379, 449, 379, 428, 370, 395, 376, 370, 376, 380, 370, 380, 328, 370, 328, 361, 370, 361, 379, 370, 379, 395, 328, 350, 361, 552, 685, 638, 552, 638, 589, 552, 589, 529, 552, 681, 685, 681, 650, 762, 681, 795, 685, 529, 440, 402, 516, 545, 627, 516, 627, 533, 516, 533, 545, 678, 674, 693, 678, 693, 691, 678, 691, 742, 922, 968, 905, 922, 905, 851, 922, 851, 928, 922, 928, 940, 922, 966, 968, 940, 966, 922, 928, 851, 893, 709, 686, 714, 709, 714, 725, 709, 725, 704, 709, 704, 697, 709, 697, 756, 709, 756, 779, 709, 779, 726, 719, 756, 697, 719, 697, 701, 532, 602, 564, 532, 518, 602, 518, 509, 520, 518, 520, 598, 532, 564, 492, 564, 514, 492, 460, 461, 439, 460, 439, 417, 460, 417, 501, 230, 233, 215, 230, 215, 173, 411, 417, 439, 411, 392, 417, 417, 390, 453, 411, 439, 385, 411, 330, 392, 778, 790, 799, 778, 799, 803, 778, 729, 682, 778, 682, 738, 778, 738, 790, 997, 993, 730, 997, 730, 865, 997, 865, 981, 981, 865, 811, 730, 993, 960, 956, 998, 996, 956, 996, 954, 956, 954, 823, 996, 987, 954, 823, 954, 882, 823, 882, 737, 799, 868, 810, 799, 810, 803, 810, 868, 926, 634, 652, 754, 634, 754, 720, 634, 720, 618, 634, 618, 505, 634, 505, 615, 582, 614, 609, 582, 609, 544, 582, 544, 581, 582, 581, 548, 582, 548, 525, 582, 525, 614, 544, 454, 448, 954, 987, 939, 954, 939, 882, 864, 730, 960, 960, 941, 847, 960, 847, 864, 567, 505, 618, 505, 428, 443, 936, 902, 929, ...
        936, 929, 984, 936, 984, 944, 819, 882, 939, 562, 737, 819, 562, 604, 718, 562, 718, 737, 604, 562, 572, 864, 596, 643, 490, 567, 554, 490, 428, 505, 490, 505, 567, 942, 847, 941, 942, 887, 847, 902, 923, 929, 847, 783, 667, 847, 667, 864, 699, 821, 708, 699, 708, 664, 699, 664, 562, 699, 562, 819, 699, 819, 821, 667, 783, 784, 667, 784, 663, 663, 784, 620, 350, 320, 416, 416, 379, 350, 320, 443, 416, 783, 847, 887, 708, 653, 626, 708, 626, 664, 653, 627, 626, 337, 534, 420, 664, 626, 599, 664, 599, 547, 190, 261, 142, 190, 142, 204, 190, 204, 291, 190, 291, 261, 261, 150, 142, 312, 292, 323, 312, 323, 325, 312, 267, 261, 312, 261, 292, 261, 291, 292, 307, 373, 339, 307, 339, 309, 307, 337, 420, 307, 420, 373, 745, 878, 962, 962, 878, 848, 193, 160, 261, 193, 261, 267, 160, 150, 261, 494, 430, 472, 494, 472, 547, 246, 350, 328, 246, 184, 350, 184, 246, 141, 184, 141, 155, 246, 199, 141, 150, 160, 151, 150, 151, 127, 150, 127, 102, 127, 151, 160, 528, 599, 545, 528, 494, 547, 528, 547, 599, 528, 545, 489, 638, 685, 717, 638, 717, 670, 494, 528, 489, 494, 489, 380, 494, 380, 376, 494, 376, 430, 328, 380, 314, 891, 985, 825, 891, 825, 839, 891, 839, 901, 825, 637, 839, 825, 985, 874, 839, 637, 723, 109, 141, 199, 109, 47, 108, 109, 108, 141, 989, 919, 716, 989, 716, 915, 915, 716, 852, 426, 533, 470, 426, 489, 545, 426, 545, 533, 199, 246, 328, 199, 328, 314, 199, 314, 165, 700, 874, 679, 700, 637, 825, 700, 825, 874, 700, 644, 637, 679, 874, 814, 679, 814, 706, 470, 533, 457, ...
        470, 457, 426, 199, 165, 162, 199, 162, 109, 676, 919, 712, 676, 716, 919, 676, 712, 621, 676, 665, 716, 234, 260, 285, 285, 295, 234, 644, 578, 512, 578, 484, 512, 201, 143, 167, 201, 245, 178, 315, 457, 382, 315, 489, 426, 315, 426, 457, 315, 382, 216, 112, 167, 143, 112, 143, 104, 104, 78, 112, 112, 78, 119, 162, 85, 58, 162, 58, 46, 162, 46, 109, 85, 48, 58, 438, 445, 386, 101, 83, 75, 101, 75, 104, 101, 104, 143, 101, 143, 83, 143, 201, 178, 143, 128, 83, 83, 24, 17, 635, 578, 644, 635, 644, 658, 635, 658, 668, 658, 691, 693, 658, 693, 668, 386, 365, 284, 386, 445, 378, 140, 183, 170, 140, 170, 118, 140, 118, 89, 140, 89, 85, 140, 85, 162, 140, 162, 165, 140, 165, 216, 140, 216, 183, 89, 70, 85, 311, 342, 349, 311, 349, 210, 311, 210, 248, 311, 248, 258, 248, 210, 229, 973, 844, 911, 844, 973, 801, 798, 844, 787, 798, 787, 741, 741, 749, 798, 557, 635, 565, 557, 484, 578, 557, 578, 635, 557, 393, 484, 349, 225, 210, 559, 598, 520, 559, 520, 460, 559, 460, 506, 559, 649, 622, 338, 349, 378, 338, 378, 383, 383, 300, 349, 383, 349, 338, 565, 692, 661, 565, 710, 692, 710, 714, 692, 453, 486, 501, 557, 465, 363, 557, 363, 348, 557, 348, 393, 393, 348, 383, 348, 363, 300, 557, 565, 465, 222, 230, 171, 171, 230, 154, 171, 154, 163, 99, 50, 154, 99, 62, 52, 99, 52, 50, 52, 62, 31, 62, 42, 31, 575, 551, 556, 575, 556, 595, 595, 556, 629, 595, 629, 654, 595, 551, 575, 551, 495, 556, 556, 495, 488, 300, 225, 349, 225, 278, 179, 655, 584, 577, ...
        655, 577, 686, 655, 686, 709, 655, 709, 726, 453, 501, 417, 173, 154, 230, 509, 518, 480, 509, 480, 422, 509, 422, 520, 173, 62, 99, 173, 99, 154, 62, 65, 42, 42, 65, 22, 450, 455, 441, 450, 441, 388, 450, 388, 455, 455, 388, 507, 329, 422, 344, 344, 277, 221, 344, 221, 329, 275, 278, 225, 275, 225, 300, 275, 300, 363, 835, 862, 592, 835, 592, 619, 435, 463, 487, 435, 487, 488, 435, 391, 423, 435, 423, 463, 488, 374, 435, 391, 435, 283, 391, 283, 364, 136, 123, 62, 136, 62, 173, 136, 212, 123, 123, 65, 62, 215, 235, 212, 215, 212, 136, 215, 136, 173, 235, 249, 344, 235, 344, 294, 235, 294, 212, 249, 235, 215, 249, 215, 233, 249, 277, 344, 956, 823, 884, 956, 884, 885, 956, 885, 958, 884, 782, 830, 884, 830, 885, 856, 920, 794, 856, 794, 813, 856, 813, 908, 959, 958, 803, 959, 803, 872, 803, 810, 829, 803, 829, 872, 930, 908, 843, 843, 908, 813, 843, 813, 758, 930, 843, 937, 829, 855, 872, 829, 810, 926, 855, 970, 872, 970, 855, 991, 707, 758, 746, 642, 707, 731, 642, 731, 636, 642, 542, 707, 702, 707, 542, 702, 542, 713, 912, 898, 833, 833, 647, 784, 833, 784, 783, 867, 860, 800, 867, 800, 807, 867, 807, 863, 867, 876, 860, 360, 403, 436, 360, 436, 333, 403, 471, 500, 403, 500, 436, 471, 403, 406, 469, 534, 471, 469, 471, 406, 599, 626, 627, 599, 627, 545, 933, 815, 963, 933, 796, 815, 724, 789, 886, 724, 886, 771, 724, 771, 703, 703, 665, 621, 295, 375, 354, 295, 415, 375, 295, 285, 357, 285, 260, 357, 354, 386, 284, 45, 28, 36, 781, 840, 861, 781, 768, 840, ...
        840, 768, 793, 840, 832, 899, 768, 781, 684, 724, 683, 770, 724, 703, 621, 724, 621, 683, 770, 683, 641, 770, 641, 834, 770, 789, 724, 621, 641, 683, 621, 712, 641, 75, 57, 104, 104, 57, 96, 75, 83, 16, 57, 37, 84, 201, 84, 224, 201, 167, 119, 201, 119, 84, 167, 112, 119, 259, 217, 289, 259, 289, 308, 259, 308, 293, 259, 293, 241, 259, 241, 175, 259, 175, 174, 259, 174, 217, 175, 164, 120, 175, 120, 137, 175, 137, 174, 164, 98, 120, 725, 668, 693, 725, 693, 704, 725, 714, 710, 668, 725, 710, 217, 174, 137, 217, 137, 126, 126, 132, 217, 977, 955, 932, 977, 932, 955, 977, 955, 986, 905, 921, 818, 921, 767, 818, 905, 818, 826, 555, 649, 559, 555, 559, 506, 555, 506, 460, 555, 460, 501, 649, 555, 631, 501, 486, 585, 871, 932, 906, 871, 816, 761, 871, 761, 831, 906, 932, 955, 818, 767, 744, 744, 654, 672, 818, 744, 846, 818, 846, 826, 753, 750, 797, 753, 797, 857, 753, 857, 760, 735, 797, 750, 579, 566, 753, 579, 753, 760, 579, 760, 631, 631, 585, 579, 931, 890, 961, 890, 931, 995, 571, 575, 556, 571, 556, 488, 571, 488, 487, 571, 487, 550, 550, 487, 539, 744, 809, 846, 809, 895, 907, 809, 907, 846, 532, 481, 480, 532, 480, 518, 532, 492, 481, 750, 573, 651, 750, 651, 735, 750, 753, 573, 753, 566, 558, 753, 558, 573, 400, 413, 486, 400, 486, 453, 400, 453, 390, 400, 390, 351, 400, 351, 413, 351, 390, 335, 875, 755, 965, 965, 755, 849, 481, 425, 480, 468, 423, 391, 468, 391, 364, 468, 364, 396, 853, 952, 934, 853, 910, 952, 853, 934, 824, 805, 837, 879, 805, 879, 853, ...
        805, 853, 824, 615, 523, 611, 615, 611, 652, 615, 652, 634, 615, 505, 523, 537, 657, 614, 537, 614, 525, 792, 733, 769, 792, 769, 811, 792, 811, 865, 792, 865, 730, 792, 730, 733, 669, 892, 827, 669, 827, 769, 454, 544, 609, 454, 609, 611, 454, 611, 523, 769, 633, 669, 769, 733, 568, 769, 568, 633, 733, 730, 568, 669, 633, 607, 900, 757, 869, 900, 869, 938, 900, 938, 711, 671, 718, 604, 636, 477, 542, 636, 542, 642, 636, 537, 477, 643, 568, 730, 643, 730, 864, 904, 757, 836, 904, 836, 860, 904, 860, 876, 904, 876, 880, 785, 707, 702, 785, 758, 707, 656, 640, 687, 656, 687, 711, 656, 711, 669, 656, 669, 607, 640, 656, 583, 656, 607, 538, 656, 538, 583, 567, 618, 671, 567, 671, 604, 567, 604, 572, 567, 572, 483, 542, 477, 502, 898, 937, 785, 785, 833, 898, 937, 898, 912, 757, 748, 786, 757, 786, 836, 502, 414, 436, 502, 436, 493, 502, 477, 414, 493, 436, 500, 896, 904, 880, 414, 333, 436, 414, 475, 333, 702, 833, 785, 702, 713, 833, 333, 317, 302, 909, 858, 812, 909, 812, 821, 876, 820, 880, 880, 820, 740, 880, 740, 859, 786, 632, 800, 786, 748, 659, 786, 659, 623, 786, 623, 632, 748, 711, 687, 748, 687, 659, 632, 807, 800, 863, 876, 867, 863, 807, 698, 863, 806, 820, 863, 820, 876, 896, 880, 859, 538, 522, 491, 522, 538, 607, 522, 607, 633, 491, 434, 538, 583, 538, 569, 247, 262, 286, 247, 286, 276, 262, 247, 220, 276, 184, 155, 276, 155, 177, 276, 177, 247, 247, 177, 220, 389, 356, 287, 389, 287, 346, 356, 139, 287, 356, 232, 139, 863, 698, 806, 553, 574, 590, 553, 590, 546, ...
        472, 572, 562, 472, 562, 664, 472, 664, 547, 572, 472, 430, 433, 483, 572, 325, 322, 298, 325, 298, 242, 325, 242, 312, 298, 262, 242, 371, 373, 406, 371, 406, 403, 371, 403, 360, 371, 360, 327, 327, 323, 371, 371, 323, 339, 371, 339, 373, 220, 193, 242, 220, 242, 262, 139, 82, 169, 169, 82, 130, 570, 536, 632, 570, 632, 623, 570, 623, 569, 632, 536, 624, 169, 310, 287, 169, 287, 139, 121, 142, 59, 743, 752, 796, 743, 796, 933, 743, 933, 859, 933, 947, 859, 820, 561, 740, 820, 806, 766, 820, 766, 561, 740, 561, 593, 740, 593, 743, 740, 743, 859, 437, 446, 536, 437, 536, 570, 437, 570, 569, 437, 569, 538, 437, 538, 331, 220, 127, 160, 220, 160, 193, 220, 177, 127, 177, 155, 127, 437, 347, 446, 437, 331, 347, 267, 242, 193, 267, 312, 242, 395, 433, 572, 395, 572, 430, 395, 430, 376, 597, 533, 627, 597, 627, 666, 597, 666, 650, 597, 650, 533, 306, 318, 347, 306, 347, 331, 306, 331, 310, 306, 310, 255, 318, 306, 281, 306, 255, 206, 306, 206, 185, 306, 185, 281, 130, 134, 206, 130, 206, 169, 752, 524, 694, 752, 743, 593, 694, 524, 727, 369, 381, 421, 368, 332, 369, 368, 369, 301, 978, 924, 888, 978, 888, 914, 34, 21, 47, 34, 47, 109, 34, 46, 21, 21, 46, 35, 21, 35, 9, 6, 14, 30, 6, 30, 27, 6, 27, 21, 6, 0, 14, 752, 593, 541, 752, 467, 524, 524, 616, 727, 467, 752, 541, 467, 541, 498, 886, 789, 916, 517, 637, 512, 637, 644, 512, 580, 517, 464, 314, 380, 489, 431, 397, 432, 431, 432, 467, 431, 467, 498, 431, 498, 419, 432, 397, 459, 86, 68, 115, ...
        68, 86, 26, 68, 71, 87, 18, 26, 69, 18, 69, 39, 21, 27, 47, 591, 526, 479, 591, 479, 589, 591, 612, 526, 415, 402, 440, 415, 295, 357, 415, 357, 402, 200, 189, 271, 200, 271, 264, 200, 264, 254, 78, 104, 119, 927, 916, 834, 250, 243, 256, 250, 303, 282, 521, 478, 560, 521, 560, 605, 521, 605, 680, 521, 680, 616, 521, 616, 524, 521, 524, 467, 521, 467, 432, 521, 432, 478, 616, 680, 677, 605, 560, 540, 560, 478, 513, 353, 398, 405, 353, 405, 324, 405, 458, 407, 405, 407, 394, 405, 394, 296, 405, 296, 324, 296, 256, 257, 296, 257, 324, 257, 256, 243, 257, 272, 324, 38, 71, 68, 38, 68, 26, 38, 26, 23, 1, 0, 6, 1, 6, 12, 1, 12, 15, 12, 28, 45, 12, 45, 15, 15, 45, 36, 15, 36, 13, 15, 13, 1, 605, 684, 680, 605, 540, 684, 304, 260, 288, 304, 288, 218, 304, 218, 273, 273, 218, 216, 218, 183, 216, 129, 54, 98, 129, 98, 164, 129, 164, 149, 129, 68, 54, 23, 26, 18, 23, 18, 0, 23, 0, 7, 7, 16, 17, 917, 854, 881, 854, 957, 881, 438, 526, 515, 438, 515, 452, 452, 445, 438, 245, 224, 178, 223, 243, 279, 223, 279, 289, 223, 289, 253, 223, 253, 227, 223, 227, 197, 223, 197, 243, 279, 274, 264, 4, 7, 0, 4, 0, 1, 4, 1, 13, 13, 75, 16, 13, 16, 4, 4, 16, 7, 918, 854, 948, 918, 957, 854, 257, 208, 272, 257, 243, 180, 257, 180, 208, 180, 243, 197, 272, 208, 377, 54, 53, 98, 54, 80, 38, 80, 71, 38, 540, 594, 684, 594, 540, 586, 560, 513, 485, 560, 485, 540, 445, 452, 378, 452, 515, 464, ...
        53, 11, 44, 53, 54, 38, 53, 38, 8, 53, 8, 11, 7, 8, 23, 844, 798, 911, 773, 841, 776, 773, 776, 742, 773, 742, 706, 773, 706, 814, 773, 814, 822, 773, 822, 841, 217, 253, 289, 217, 132, 227, 217, 227, 253, 635, 668, 710, 635, 710, 565, 248, 229, 226, 248, 226, 258, 226, 229, 214, 226, 237, 192, 197, 227, 161, 70, 49, 48, 70, 48, 85, 48, 49, 32, 831, 776, 841, 476, 409, 586, 476, 586, 540, 476, 540, 485, 476, 485, 409, 485, 367, 377, 586, 409, 401, 424, 484, 393, 424, 393, 378, 378, 393, 383, 219, 252, 377, 219, 377, 208, 219, 208, 148, 227, 132, 161, 44, 55, 120, 44, 120, 98, 44, 98, 53, 55, 56, 137, 55, 29, 56, 32, 49, 2, 32, 2, 20, 32, 20, 25, 639, 474, 767, 639, 767, 734, 639, 734, 736, 639, 736, 451, 639, 451, 474, 442, 451, 736, 442, 736, 587, 442, 587, 511, 451, 442, 384, 3, 5, 8, 3, 8, 7, 3, 7, 17, 8, 5, 11, 857, 911, 798, 857, 798, 749, 857, 749, 760, 761, 756, 719, 761, 719, 732, 761, 732, 742, 761, 742, 776, 761, 776, 831, 761, 816, 779, 761, 779, 756, 751, 662, 787, 751, 787, 801, 751, 645, 662, 662, 645, 613, 602, 662, 613, 602, 518, 598, 602, 598, 662, 172, 188, 252, 172, 252, 219, 172, 219, 148, 188, 172, 209, 408, 362, 474, 408, 474, 451, 408, 451, 384, 945, 940, 928, 751, 747, 645, 124, 153, 210, 124, 138, 116, 153, 124, 118, 133, 135, 172, 133, 172, 148, 133, 148, 197, 133, 197, 161, 172, 135, 209, 161, 97, 133, 461, 460, 520, 244, 230, 222, 244, 222, 207, 244, 207, 213, 207, 152, 213, ...
        207, 163, 152, 645, 600, 514, 645, 514, 613, 613, 564, 602, 600, 645, 747, 579, 510, 566, 579, 585, 510, 510, 558, 566, 221, 277, 244, 221, 244, 213, 277, 230, 244, 486, 496, 585, 496, 510, 585, 492, 514, 463, 492, 463, 444, 444, 463, 423, 463, 514, 535, 94, 152, 163, 94, 163, 74, 76, 94, 74, 76, 74, 61, 76, 61, 73, 221, 268, 329, 514, 600, 531, 514, 531, 535, 556, 550, 576, 556, 576, 629, 556, 575, 571, 556, 571, 550, 94, 76, 100, 100, 152, 94, 600, 747, 777, 600, 777, 619, 535, 539, 487, 535, 487, 463, 539, 535, 673, 191, 176, 330, 191, 330, 268, 191, 268, 221, 191, 221, 152, 152, 100, 144, 152, 144, 176, 152, 176, 191, 952, 992, 934, 873, 811, 827, 868, 799, 824, 868, 824, 934, 824, 799, 790, 611, 609, 782, 782, 609, 729, 868, 934, 992, 746, 813, 794, 746, 794, 731, 746, 731, 707, 746, 758, 813, 944, 998, 936, 944, 996, 998, 882, 819, 737, 711, 748, 757, 428, 416, 443, 836, 800, 860, 836, 786, 800, 500, 648, 493, 713, 542, 502, 713, 502, 493, 713, 493, 648, 574, 549, 568, 574, 568, 596, 596, 667, 663, 549, 574, 553, 549, 553, 522, 549, 522, 633, 833, 713, 647, 812, 788, 708, 812, 708, 821, 788, 696, 653, 648, 500, 628, 648, 647, 713, 316, 322, 327, 316, 333, 302, 316, 302, 298, 316, 298, 322, 689, 788, 653, 689, 653, 708, 689, 708, 788, 262, 298, 302, 262, 302, 286, 858, 962, 848, 858, 909, 962, 648, 628, 647, 628, 500, 471, 628, 471, 534, 628, 534, 608, 608, 646, 628, 543, 491, 522, 543, 522, 553, 327, 360, 333, 327, 333, 316, 610, 620, 590, 610, 590, 574, ...
        610, 574, 596, 610, 596, 663, 610, 663, 620, 807, 632, 624, 647, 646, 784, 628, 646, 647, 406, 420, 469, 406, 373, 420, 807, 722, 698, 698, 715, 806, 722, 624, 698, 666, 627, 653, 666, 653, 696, 666, 696, 745, 722, 807, 624, 323, 327, 322, 323, 322, 325, 685, 795, 717, 698, 606, 715, 698, 624, 606, 650, 666, 745, 650, 745, 866, 791, 795, 762, 791, 762, 883, 791, 883, 914, 791, 914, 888, 791, 888, 828, 842, 889, 852, 842, 852, 771, 842, 771, 886, 842, 969, 889, 889, 915, 852, 762, 795, 681, 536, 446, 624, 624, 446, 412, 301, 332, 368, 301, 318, 281, 301, 281, 254, 130, 82, 113, 113, 82, 86, 113, 134, 130, 82, 69, 26, 82, 26, 86, 889, 969, 915, 815, 780, 963, 963, 780, 903, 791, 828, 717, 791, 717, 795, 828, 728, 670, 828, 670, 717, 650, 681, 552, 650, 552, 533, 318, 421, 482, 318, 482, 412, 318, 301, 369, 318, 369, 421, 412, 446, 347, 412, 347, 318, 852, 716, 665, 852, 665, 703, 852, 703, 771, 625, 482, 421, 625, 630, 606, 606, 624, 412, 606, 412, 482, 606, 482, 625, 185, 206, 134, 185, 134, 200, 146, 189, 134, 146, 134, 113, 146, 113, 107, 146, 107, 158, 146, 158, 189, 134, 189, 200, 60, 66, 72, 60, 72, 39, 60, 39, 69, 60, 69, 72, 60, 72, 66, 877, 774, 838, 877, 838, 802, 877, 802, 861, 877, 861, 950, 888, 728, 804, 888, 804, 828, 838, 677, 802, 694, 780, 815, 694, 815, 796, 694, 796, 752, 694, 727, 780, 530, 588, 625, 530, 625, 421, 780, 817, 903, 838, 774, 817, 189, 228, 265, 185, 254, 281, 185, 200, 254, 817, 780, 727, 817, 727, 616, 677, 838, 817, ...
        677, 817, 616, 665, 676, 621, 274, 279, 243, 274, 243, 250, 274, 250, 282, 466, 533, 552, 466, 552, 529, 466, 529, 402, 466, 402, 382, 466, 382, 457, 466, 457, 533, 265, 293, 264, 265, 264, 271, 264, 293, 279, 271, 189, 265, 46, 34, 109, 9, 28, 12, 9, 12, 6, 9, 6, 21, 9, 35, 28, 679, 706, 691, 679, 691, 658, 679, 658, 644, 679, 644, 700, 427, 398, 519, 427, 519, 459, 427, 459, 397, 427, 397, 431, 427, 431, 458, 427, 458, 405, 427, 405, 398, 519, 504, 459, 308, 279, 293, 308, 289, 279, 87, 88, 80, 88, 87, 71, 87, 80, 54, 87, 54, 68, 88, 71, 80, 504, 519, 513, 114, 84, 119, 114, 119, 104, 114, 104, 96, 114, 96, 84, 96, 57, 84, 999, 951, 822, 951, 841, 822, 793, 768, 695, 447, 519, 398, 478, 432, 459, 478, 459, 504, 315, 216, 165, 315, 165, 314, 315, 314, 489, 35, 58, 48, 35, 46, 58, 35, 48, 32, 25, 35, 32, 25, 75, 13, 25, 13, 36, 25, 36, 28, 25, 28, 35, 946, 822, 814, 946, 814, 874, 793, 832, 840, 691, 706, 742, 273, 382, 357, 273, 357, 304, 273, 216, 382, 357, 260, 304, 357, 382, 402, 8, 38, 23, 594, 768, 684, 594, 695, 768, 674, 678, 742, 674, 742, 721, 721, 742, 732, 186, 288, 258, 186, 258, 226, 186, 226, 192, 192, 237, 214, 178, 224, 128, 178, 128, 143, 224, 110, 128, 128, 110, 105, 424, 378, 452, 424, 452, 464, 218, 288, 186, 218, 186, 192, 218, 192, 170, 218, 170, 183, 83, 128, 105, 16, 83, 17, 622, 749, 741, 622, 649, 749, 622, 741, 559, 749, 649, 760, 649, 631, 760, 586, 587, 695, 586, 695, 594, ...
        897, 841, 951, 897, 951, 986, 897, 986, 955, 897, 955, 932, 897, 831, 841, 462, 587, 586, 462, 586, 401, 462, 511, 587, 485, 377, 252, 485, 252, 240, 485, 240, 409, 214, 237, 226, 148, 180, 197, 148, 208, 180, 106, 74, 163, 106, 50, 51, 106, 51, 61, 106, 61, 74, 940, 945, 935, 940, 935, 988, 897, 932, 871, 897, 871, 831, 103, 81, 56, 132, 103, 97, 132, 97, 161, 103, 64, 97, 137, 120, 55, 11, 29, 55, 11, 55, 44, 29, 41, 56, 2, 10, 5, 741, 787, 662, 741, 662, 598, 741, 598, 559, 280, 401, 409, 280, 409, 209, 409, 240, 209, 207, 222, 171, 207, 171, 163, 116, 92, 70, 116, 70, 89, 116, 89, 118, 116, 118, 124, 3, 17, 24, 3, 24, 2, 3, 2, 5, 585, 631, 555, 585, 555, 501, 240, 252, 188, 81, 132, 126, 81, 126, 137, 81, 137, 56, 81, 103, 132, 64, 103, 56, 64, 56, 41, 64, 41, 77, 92, 67, 61, 92, 61, 51, 92, 51, 49, 92, 49, 70, 51, 50, 49, 31, 10, 2, 31, 2, 49, 31, 49, 50, 31, 50, 52, 974, 982, 945, 974, 945, 928, 974, 928, 893, 972, 913, 943, 972, 967, 913, 654, 744, 767, 654, 767, 474, 654, 474, 595, 654, 629, 672, 383, 348, 300, 408, 384, 251, 408, 251, 321, 408, 321, 362, 362, 321, 340, 321, 305, 340, 280, 209, 231, 280, 231, 251, 816, 943, 726, 816, 726, 779, 816, 871, 943, 851, 905, 826, 851, 826, 846, 851, 846, 893, 692, 714, 686, 692, 686, 577, 692, 577, 661, 551, 595, 474, 551, 474, 495, 19, 40, 41, 19, 41, 29, 19, 29, 11, 19, 11, 5, 19, 33, 40, 507, 661, 577, 507, 565, 661, ...
        209, 240, 188, 116, 138, 92, 92, 138, 93, 91, 135, 133, 91, 133, 97, 31, 42, 10, 979, 759, 967, 943, 913, 967, 943, 967, 726, 726, 967, 705, 726, 705, 655, 321, 266, 305, 182, 231, 209, 182, 209, 145, 209, 135, 145, 225, 179, 124, 225, 124, 210, 145, 147, 182, 145, 135, 125, 91, 97, 64, 91, 64, 77, 67, 92, 93, 67, 93, 73, 67, 73, 61, 465, 565, 507, 465, 507, 366, 465, 366, 275, 465, 275, 363, 507, 388, 359, 507, 359, 366, 340, 495, 474, 340, 474, 362, 495, 340, 488, 340, 374, 488, 213, 152, 221, 22, 33, 19, 22, 19, 5, 22, 5, 10, 10, 42, 22, 22, 65, 33, 759, 735, 651, 759, 651, 705, 759, 705, 967, 705, 651, 601, 321, 251, 196, 321, 196, 211, 321, 211, 266, 211, 159, 239, 211, 239, 266, 251, 231, 196, 179, 138, 124, 125, 135, 91, 125, 91, 77, 125, 77, 79, 77, 33, 79, 77, 41, 40, 77, 40, 33, 953, 777, 747, 835, 890, 862, 705, 584, 655, 441, 577, 584, 441, 584, 705, 441, 455, 507, 441, 507, 577, 705, 413, 441, 496, 558, 510, 496, 527, 558, 268, 330, 411, 268, 411, 385, 268, 385, 329, 233, 277, 249, 233, 230, 277, 835, 619, 777, 763, 744, 672, 763, 672, 629, 763, 629, 673, 763, 809, 744, 763, 673, 755, 573, 601, 651, 573, 558, 601, 601, 558, 527, 366, 359, 278, 366, 278, 275, 211, 196, 147, 211, 147, 159, 159, 195, 239, 138, 131, 93, 93, 131, 111, 862, 965, 849, 531, 600, 619, 527, 486, 601, 527, 496, 486, 601, 486, 413, 601, 413, 705, 299, 388, 441, 299, 441, 413, 299, 413, 351, 392, 330, 335, 392, 335, 390, 392, 390, 417];
    hFig = figure;

    % Create rendering panel
    [OGL, container] = javacomponent(java_create('org.brainstorm.connect.GraphicsFramework'), [0, 0, 500, 400], hFig);

    OGL.addPolygon(Vertices, Indices, 1);
    OGL.setPolygonVisible(0, 1);
    OGL.addRadialBox([0, 1, 0], [0, 0, 1], [0, 0, 0], [0, 1, 2]);
    OGL.renderInQuad(0);
    OGL.setPolygonTransparency(0, 0.1);

    OGL.start();
    OGL.setClearColor(0, 0, 0, 0);
    OGL.zoom(3);
    OGL.lookAt(0, 0, 1, 0, 0, 0, 0, 1, 0);
    OGL.repaint();
end


%% ===========================================================================
%  ===== FIGURE CALLBACKS ====================================================
%  ===========================================================================
%% ===== COLORMAP CHANGED CALLBACK =====
function ColormapChangedCallback(hFig) %#ok<DEFNU>
    UpdateColormap(hFig);
end

%% ===== CURRENT TIME CHANGED =====
function CurrentTimeChangedCallback(hFig)   %#ok<DEFNU>
    % If no time in this figure
    if getappdata(hFig, 'isStatic')
        return;
    end
    % If there is time in this figure
    UpdateFigurePlot(hFig);
end

%% ===== CURRENT FREQ CHANGED =====
function CurrentFreqChangedCallback(hFig)   %#ok<DEFNU>
    % If no frequencies in this figure
    if getappdata(hFig, 'isStaticFreq')
        return;
    end
    % Update figure
    UpdateFigurePlot(hFig);
end


%% ===== SELECTED ROW CHANGED =====
function SelectedRowChangedCallback(iDS, iFig) %#ok<DEFNU>
%     global GlobalData;
%     % Get figure appdata
%     hFig = GlobalData.DataSet(iDS).Figure(iFig).hFigure;
%     % Get current selection for the figure
%     curSelRows = figure_timeseries('GetFigSelectedRows', hFig);
%     % Get new selection that the figure should show (keep only the ones available for this figure)
%     allFigRows = GlobalData.DataSet(iDS).Figure(iFig).Handles.LinesLabels;
%     newSelRows = intersect(GlobalData.DataViewer.SelectedRows, allFigRows);
%     % Sensors to select
%     rowsToSel = setdiff(newSelRows, curSelRows);
%     if ~isempty(rowsToSel)
%         figure_timeseries('SetFigSelectedRows', hFig, rowsToSel, 1);
%     end
%     % Sensors to unselect
%     rowsToUnsel = setdiff(curSelRows, newSelRows);
%     if ~isempty(rowsToUnsel)
%         figure_timeseries('SetFigSelectedRows', hFig, rowsToUnsel, 0);
%     end
end


%% ===== DISPOSE FIGURE =====
function Dispose(hFig) %#ok<DEFNU>
    SetBackgroundColor(hFig, [1 1 1]);
    OGL = getappdata(hFig, 'OpenGLDisplay');
    set(OGL, 'MouseClickedCallback',    []);
    set(OGL, 'MousePressedCallback',    []);
    set(OGL, 'MouseDraggedCallback',    []);
    set(OGL, 'MouseReleasedCallback',   []);
    set(OGL, 'KeyReleasedCallback',     []);
    set(OGL, 'KeyPressedCallback',      []);
    set(OGL, 'MouseWheelMovedCallback', []);
    OGL.resetDisplay();
    delete(OGL);
    setappdata(hFig, 'OpenGLDisplay', []);
end


%% ===== RESET DISPLAY =====
function ResetDisplay(hFig)
    % Reset display
    OGL = getappdata(hFig, 'OpenGLDisplay');
    OGL.resetDisplay();
    % Defaults value
    setappdata(hFig, 'DisplayOutwardMeasure', 1);
    setappdata(hFig, 'DisplayInwardMeasure', 0);
    setappdata(hFig, 'DisplayBidirectionalMeasure', 0);
    setappdata(hFig, 'DataThreshold', 0.5);
    setappdata(hFig, 'DistanceThreshold', 0);
    setappdata(hFig, 'TextDisplayMode', 1);
    setappdata(hFig, 'NodeDisplay', 1);
    setappdata(hFig, 'HierarchyNodeIsVisible', 1);
    if isappdata(hFig, 'DataPair')
        rmappdata(hFig, 'DataPair');
    end
    if isappdata(hFig, 'HierarchyNodesMask')
        rmappdata(hFig, 'HierarchyNodesMask');
    end
    if isappdata(hFig, 'GroupNodesMask')
        rmappdata(hFig, 'GroupNodesMask');
    end
    if isappdata(hFig, 'NodeData')
        rmappdata(hFig, 'NodeData');
    end
    if isappdata(hFig, 'DataMinMax')
        rmappdata(hFig, 'DataMinMax');
    end
end

%% ===== GET BACKGROUND COLOR =====
function backgroundColor = GetBackgroundColor(hFig)
    backgroundColor = getappdata(hFig, 'BgColor');
    if isempty(backgroundColor)
        backgroundColor = [0 0 0];
    end
end

%% ===== RESIZE CALLBACK =====
function ResizeCallback(hFig, container)
    % Update Title     
    RefreshTitle(hFig);
    % Update OpenGL container size
    UpdateContainer(hFig, container);
end

function UpdateContainer(hFig, container)
    % Get figure position
    figPos = get(hFig, 'Position');
    % Get colorbar handle
    hColorbar = findobj(hFig, '-depth', 1, 'Tag', 'Colorbar');
    % Get title handle
    TitlesHandle = getappdata(hFig, 'TitlesHandle');
    titleHeight = 0;
    if (~isempty(TitlesHandle))
        titlePos = get(TitlesHandle(1), 'Position'); 
        titleHeight = titlePos(4);
    end
    % Scale figure
    Scaling = bst_get('InterfaceScaling') / 100;
    % Define constants
    colorbarWidth = 15 .* Scaling;
    marginHeight  = 25 .* Scaling;
    marginWidth   = 45 .* Scaling;
    % If there is a colorbar 
    if ~isempty(hColorbar)
        % Reposition the colorbar
        set(hColorbar, 'Units',    'pixels', ...
                       'Position', [figPos(3) - marginWidth, ...
                                    marginHeight, ...
                                    colorbarWidth, ...
                                    max(1, min(90, figPos(4) - marginHeight - 3 .* Scaling))]);
        % Reposition the container
        marginAxes = 0;
        if ~isempty(container)
            set(container, 'Units',    'pixels', ...
                           'Position', [marginAxes, ...
                                        marginAxes, ...
                                        max(1, figPos(3) - colorbarWidth - marginWidth - marginAxes), ... 
                                        max(1, figPos(4) - 2*marginAxes - titleHeight)]);
        end
        uistack(hColorbar,'top',1);
    else
        if ~isempty(container)
            % Java container can take all the figure space
            set(container, 'Units',    'normalized', ...
                           'Position', [.05, .05, .9, .9]);
        end
    end
end

function HasTitle = RefreshTitle(hFig)
    Title = [];
    DisplayInRegion = getappdata(hFig, 'DisplayInRegion');
    if (DisplayInRegion)
        % Organisation level
        OrganiseNode = bst_figures('GetFigureHandleField', hFig, 'OrganiseNode');
        % Label 
        hTitle = getappdata(hFig, 'TitlesHandle');
        % If data are hierarchicaly organised and we are not
        % already at the whole cortical view
        if (~isempty(OrganiseNode) && OrganiseNode ~= 1)
            % Get where we are textually
            PathNames = VerticeToFullName(hFig, OrganiseNode);
            Recreate = 0;
            nLevel = size(PathNames,2);
            if (nLevel ~= size(hTitle,2) || size(hTitle,2) == 0)
                Recreate = 1;
                for i=1:size(hTitle,2)
                    delete(hTitle(i));
                end
                hTitle = [];
            end
            backgroundColor = GetBackgroundColor(hFig);
            figPos = get(hFig, 'Position');
            Width = 1;
            Height = 25;
            X = 10;
            Y = figPos(4) - Height;
            for i=1:nLevel
                Title = PathNames{i};
                if (Recreate)
                    hTitle(i) = uicontrol( ...
                                       'Style',               'pushbutton', ...
                                       'Enable',              'inactive', ...
                                       'String',              Title, ...
                                       'Units',               'Pixels', ...
                                       'Position',            [0 0 1 1], ...
                                       'HorizontalAlignment', 'center', ...
                                       'FontUnits',           'points', ...
                                       'FontSize',            bst_get('FigFont'), ...
                                       'ForegroundColor',     [0 0 0], ...
                                       'BackgroundColor',     backgroundColor, ...
                                       'HitTest',             'on', ...
                                       'Parent',              hFig, ...
                                       'Callback', @(h,ev)bst_call(@SetExplorationLevelTo,hFig,nLevel-i));
                    set(hTitle(i), 'ButtonDownFcn', @(h,ev)bst_call(@SetExplorationLevelTo,hFig,nLevel-i), ...
                                   'BackgroundColor',     backgroundColor);
                end
                X = X + Width;
                Size = get(hTitle(i), 'extent');
                Width = Size(3) + 10;
                % Minimum width so all buttons look the same
                if (Width < 50)
                    Width = 50;
                end
                set(hTitle(i), 'String',            Title, ...
                               'Position',          [X Y Width Height], ...
                               'BackgroundColor',   backgroundColor);
            end
        else
            for i=1:size(hTitle,2)
                delete(hTitle(i));
            end
            hTitle = [];
        end
        setappdata(hFig, 'TitlesHandle', hTitle);
        UpdateContainer(hFig, getappdata(hFig, 'OpenGLContainer'));
    end    
    HasTitle = size(Title,2) > 0;
end

%% ===========================================================================
%  ===== KEYBOARD AND MOUSE CALLBACKS ========================================
%  ===========================================================================

%% ===== FIGURE MOUSE CLICK CALLBACK =====
function FigureMouseDownCallback(hFig, ev)   
    % Check if MouseUp was executed before MouseDown: Should ignore this MouseDown event
    if isappdata(hFig, 'clickAction') && strcmpi(getappdata(hFig,'clickAction'), 'MouseDownNotConsumed')
        return;
    end
    % Click on the Java canvas
    if ~isempty(ev)
        if isjava(ev)
            if ((ev.getButton() == ev.BUTTON3) || (ev.getButton() == ev.BUTTON2))
                clickAction = 'popup';
            else
                clickAction = 'rotate';
            end
            clickPos = [ev.getX() ev.getY()];
        else
            if strcmpi(get(hFig, 'SelectionType'), 'alt')
                clickAction = 'popup';
            else
                clickAction = 'rotate';
            end
            clickPos = get(hFig, 'CurrentPoint');
        end
    % Click on the Matlab colorbar
    else
        if strcmpi(get(hFig, 'SelectionType'), 'alt')
            clickAction = 'popup';
        else
            clickAction = 'colorbar';
        end
        clickPos = get(hFig, 'CurrentPoint');
    end
    % Record action to perform when the mouse is moved
    setappdata(hFig, 'clickAction', clickAction);
    setappdata(hFig, 'clickSource', hFig);
    % Reset the motion flag
    setappdata(hFig, 'hasMoved', 0);
    % Record mouse location in the figure coordinates system
    setappdata(hFig, 'clickPositionFigure', clickPos);
end


%% ===== FIGURE MOUSE MOVE CALLBACK =====
function FigureMouseMoveCallback(hFig, ev)
    % Get current mouse action
    clickAction = getappdata(hFig, 'clickAction');   
    clickSource = getappdata(hFig, 'clickSource');
    % If no source, or source is not the same as the current figure: Ignore
    if isempty(clickAction) || isempty(clickSource) || (clickSource ~= hFig)
        return
    end
    % If MouseUp was executed before MouseDown: Ignore Move event
    if strcmpi(clickAction, 'MouseDownNotConsumed') || isempty(getappdata(hFig, 'clickPositionFigure'))
        return
    end
    % Click on the Java canvas
    if ~isempty(ev) && isjava(ev)
        curPos = [ev.getX() ev.getY()];
    % Click on the Matlab colorbar
    else
        curPos = get(hFig, 'CurrentPoint');
    end
    % Motion from the previous event
    motionFigure = 0.3 * (curPos - getappdata(hFig, 'clickPositionFigure'));
    % Update click point location
    setappdata(hFig, 'clickPositionFigure', curPos);
    % Update the motion flag
    setappdata(hFig, 'hasMoved', 1);
    % Switch between different actions
    switch(clickAction)              
        case 'colorbar'
            % Get colormap type
            ColormapInfo = getappdata(hFig, 'Colormap');
            % Changes contrast            
            sColormap = bst_colormaps('ColormapChangeModifiers', ColormapInfo.Type, [motionFigure(1), motionFigure(2)] ./ 100, 0);
            set(hFig, 'Colormap', sColormap.CMap);
        case 'rotate'
             MouseMoveCamera = getappdata(hFig, 'MouseMoveCamera');
             if isempty(MouseMoveCamera)
                 MouseMoveCamera = 0;
             end
             if (MouseMoveCamera)
                 motion = -motionFigure * 0.05;
                 MoveCamera(hFig, [motion(1) -motion(2) 0]);
             else
                 % ENABLE THE CODE BELOW TO ENABLE THE ROTATION
                 %motion = -motionFigure * 0.01;
                 %RotateCameraAlongAxis(hFig, -motion(2), motion(1));
             end
    end
end


%% ===== FIGURE MOUSE UP CALLBACK =====
function FigureMouseUpCallback(hFig, varargin)
    % Get application data (current user/mouse actions)
    clickAction = getappdata(hFig, 'clickAction');
    hasMoved = getappdata(hFig, 'hasMoved');
    % Remove mouse appdata (to stop movements first)
    setappdata(hFig, 'hasMoved', 0);
    if isappdata(hFig, 'clickPositionFigure')
        rmappdata(hFig, 'clickPositionFigure');
    end
    if isappdata(hFig, 'clickAction')
        rmappdata(hFig, 'clickAction');
    else
        setappdata(hFig, 'clickAction', 'MouseDownNotConsumed');
    end

    % Update display panel
    bst_figures('SetCurrentFigure', hFig, 'TF');
    
    % ===== SIMPLE CLICK =====
    if ~hasMoved
        if strcmpi(clickAction, 'popup')
            DisplayFigurePopup(hFig);
        end
    % ===== MOUSE HAS MOVED =====
    else
        if strcmpi(clickAction, 'colorbar')
            % Apply new colormap to all figures
            ColormapInfo = getappdata(hFig, 'Colormap');
            bst_colormaps('FireColormapChanged', ColormapInfo.Type);
        end
    end
end


%% ===== FIGURE KEY PRESSED CALLBACK =====
function FigureKeyPressedCallback(hFig, keyEvent)
    global ConnectKeyboardMutex;
    % Convert to Matlab key event
    [keyEvent, tmp, tmp] = gui_brainstorm('ConvertKeyEvent', keyEvent);
    if isempty(keyEvent.Key)
        return;
    end
    % Set a mutex to prevent to enter twice at the same time in the routine
    if (isempty(ConnectKeyboardMutex))
        tic;
        % Set mutex
        ConnectKeyboardMutex = 0.1;
        % Process event
        switch (keyEvent.Key)
            case 'a'
                SetSelectedNodes(hFig, [], 1, 1);
            case 'b'
                ToggleBlendingMode(hFig);
            case 'l'
                ToggleTextDisplayMode(hFig);
            case 'h'
                HierarchyNodeIsVisible = getappdata(hFig, 'HierarchyNodeIsVisible');
                HierarchyNodeIsVisible = 1 - HierarchyNodeIsVisible;
                SetHierarchyNodeIsVisible(hFig, HierarchyNodeIsVisible);
            case 'd'
                ToggleDisplayMode(hFig);
            case 'm'
                ToggleMeasureToRegionDisplay(hFig)
            case 'q'
                RenderInQuad = 1 - getappdata(hFig, 'RenderInQuad');
                setappdata(hFig, 'RenderInQuad', RenderInQuad)
                OGL = getappdata(hFig, 'OpenGLDisplay');
                OGL.renderInQuad(RenderInQuad)
                OGL.repaint();
            case {'+', 'add'}
                panel_display('ConnectKeyCallback', keyEvent);
            case {'-', 'subtract'}
                panel_display('ConnectKeyCallback', keyEvent);
            case 'leftarrow'
                ToggleRegionSelection(hFig, 1);
            case 'rightarrow'
                ToggleRegionSelection(hFig, -1);
            case 'uparrow'
                ZoomCamera(hFig, -10);
            case 'downarrow'
                ZoomCamera(hFig, 10);
            case 'escape'
                SetExplorationLevelTo(hFig, 1);
            case 'shift'
                setappdata(hFig, 'MouseMoveCamera', 1);
        end
        %ConnectKeyboardMutex = [];
    else
        % Release mutex if last keypress was processed more than one 2s ago
        t = toc;
        if (t > ConnectKeyboardMutex)
            ConnectKeyboardMutex = [];
        end
    end
end

function FigureKeyReleasedCallback(hFig, keyEvent)
    % Convert to Matlab key event
    keyEvent = gui_brainstorm('ConvertKeyEvent', keyEvent);
    if isempty(keyEvent.Key)
        return;
    end
    % Process event
    switch (keyEvent.Key)
        case 'shift'
            setappdata(hFig, 'MouseMoveCamera', 0);
    end
end

function SetExplorationLevelTo(hFig, Level)
    % Last reorganisation
    OrganiseNode = bst_figures('GetFigureHandleField', hFig, 'OrganiseNode');
    if (isempty(OrganiseNode) || OrganiseNode == 1)
        return;
    end
    Paths = bst_figures('GetFigureHandleField', hFig, 'NodePaths');
    Path = Paths{OrganiseNode};
    NextAgregatingNode = Path(find(Path == OrganiseNode) + Level);
    if (NextAgregatingNode ~= OrganiseNode)
        bst_figures('SetFigureHandleField', hFig, 'OrganiseNode', NextAgregatingNode);
        UpdateFigurePlot(hFig);
    end
end

function NextNode = getNextCircularRegion(hFig, Node, Inc)
    % Construct Spiral Index
    Levels = bst_figures('GetFigureHandleField', hFig, 'Levels');
    DisplayNode = find(bst_figures('GetFigureHandleField', hFig, 'DisplayNode'));
    CircularIndex = [];
    for i=1:size(Levels,1)
        CircularIndex = [CircularIndex; Levels{i}];
    end
    CircularIndex(~ismember(CircularIndex,DisplayNode)) = [];
    if isempty(Node)
        NextIndex = 1;
    else
        % Find index
        NextIndex = find(CircularIndex(:) == Node) + Inc;
        nIndex = size(CircularIndex,1);
        if (NextIndex > nIndex)
            NextIndex = 1;
        elseif (NextIndex < 1)
            NextIndex = nIndex;
        end
    end
    % 
    NextNode = CircularIndex(NextIndex);
end

function ToggleRegionSelection(hFig, Inc)
    % Get selected nodes
    selNodes = bst_figures('GetFigureHandleField', hFig, 'SelectedNodes');
    % Get number of AgregatingNode
    AgregatingNodes = bst_figures('GetFigureHandleField', hFig, 'AgregatingNodes');
    % 
    if (isempty(selNodes))
        % Get first node
        NextNode = getNextCircularRegion(hFig, [], Inc);
    else
        % Remove previous links
        SetSelectedNodes(hFig, selNodes, 0, 1); 
        % Remove agregating node from selection
        SelectedNode = selNodes(1);
        %
        NextNode = getNextCircularRegion(hFig, SelectedNode, Inc);
    end
    % Is node an agregating node
    IsAgregatingNode = ismember(NextNode, AgregatingNodes);
    if (IsAgregatingNode)
        % Get agregated nodes
        AgregatedNodeIndex = getAgregatedNodesFrom(hFig, NextNode); 
        if (~isempty(AgregatedNodeIndex))
            % Select agregated node
            SetSelectedNodes(hFig, AgregatedNodeIndex, 1, 1);
        end    
    end
    % Select node
    SetSelectedNodes(hFig, NextNode, 1, 1);
end


%% ===== JAVA MOUSE CLICK CALLBACK =====
function JavaClickCallback(hFig, ev)
    % Retrieve button
    ButtonClicked = ev.get('Button');
    ClickCount = ev.get('ClickCount');
    if (ButtonClicked == 1)
        % OpenGL handle
        OGL = getappdata(hFig,'OpenGLDisplay');
        % Minimum distance. 1 is difference between level order of distance
        minimumDistanceThreshold = 0.2;
        % '+1' is to account for the different indexing in Java and Matlab
        nodeIndex = OGL.raypickNearestNode(ev.getX(), ev.getY(), minimumDistanceThreshold) + 1;
        % If a visible node is clicked on
        if (nodeIndex > 0)
            DisplayNode = bst_figures('GetFigureHandleField', hFig, 'DisplayNode');
            if (DisplayNode(nodeIndex) == 1)
                % Get selected nodes
                selNodes = bst_figures('GetFigureHandleField', hFig, 'SelectedNodes');
                % Get agregating nodes
                MeasureNodes    = bst_figures('GetFigureHandleField', hFig, 'MeasureNodes');
                AgregatingNodes = bst_figures('GetFigureHandleField', hFig, 'AgregatingNodes');
                % Is the node already selected ?
                AlreadySelected = any(selNodes == nodeIndex);
                % Is the node an agregating node ?
                IsAgregatingNode = any(AgregatingNodes == nodeIndex);

                if (ClickCount == 1)
                    % If node is already select
                    if AlreadySelected
                        % If all the nodes are selected, then select only this one
                        if all(ismember(MeasureNodes, selNodes))
                            SetSelectedNodes(hFig, [], 0);
                            AlreadySelected = 0;
                        % If it's the only selected node, then select all
                        elseif (length(selNodes) == 1)
                            SetSelectedNodes(hFig, [], 1);
                            return;
                        end
                        % Aggragtive nodes: select blocks of nodes
                        if IsAgregatingNode
                            % Get agregated nodes
                            AgregatedNodeIndex = getAgregatedNodesFrom(hFig, nodeIndex);
                            % How many are already selected
                            NodeAlreadySelected = ismember(AgregatedNodeIndex, selNodes);
                            % Get selected agregated nodes
%                             AgregatingNodeAlreadySelected = ismember(AgregatingNodes, selNodes);
                            % If the agregating node and his measure node are the only selected nodes, then select all
                            if (sum(NodeAlreadySelected) == size(selNodes,1))
                                SetSelectedNodes(hFig, [], 1);
                                return;
                            end
                        end
                    end
                    
                    % Select picked node
                    Select = 1;
                    if (AlreadySelected)
                        % Deselect picked node
                        Select = 0;
                    end

                    % If shift is not pressed, deselect all node
                    isShiftDown = ev.get('ShiftDown');
                    if (strcmp(isShiftDown,'off'))
                        % Deselect
                        SetSelectedNodes(hFig, selNodes, 0, 1);
                        % Deselect picked node
                        Select = 1;
                    end
                
                    if (IsAgregatingNode)
                        % Get agregated nodes
                        SelectNodeIndex = getAgregatedNodesFrom(hFig, nodeIndex);
                        % Select
                        SetSelectedNodes(hFig, [SelectNodeIndex(:); nodeIndex], Select);
                        % Go up the hierarchy
                        UpdateHierarchySelection(hFig, nodeIndex, Select);
                    else
                        SetSelectedNodes(hFig, nodeIndex, Select);
                    end
                else
                    disp('BST> Zoom into a region: Feature disabled until fixed.');
                    return;
                    
                    if (IsAgregatingNode)
                        OrganiseNode = bst_figures('GetFigureHandleField', hFig, 'OrganiseNode');
                        if isempty(OrganiseNode)
                            OrganiseNode = 1;
                        end
                        % If it's the same, don't reload for nothing..
                        if (OrganiseNode == nodeIndex)
                            return;
                        end
                        % If there's only one node, useless update
                        AgregatedNodeIndex = getAgregatedNodesFrom(hFig, nodeIndex);
                        Invalid = ismember(AgregatedNodeIndex, AgregatingNodes);
                        Invalid = Invalid | ismember(AgregatedNodeIndex, OrganiseNode);
                        if (size(AgregatedNodeIndex(~Invalid),1) == 1)
                            return;
                        end
                        % There's no exploration in 3D
                        is3DDisplay = getappdata(hFig, 'is3DDisplay');
                        if (~is3DDisplay)
                            bst_figures('SetFigureHandleField', hFig, 'OrganiseNode', nodeIndex);
                            UpdateFigurePlot(hFig);
                        end
                    end
                end
            end
        else
            if (ClickCount == 2)
                DefaultCamera(hFig);
            end
        end
    end
end

function DefaultCamera(hFig)
    setappdata(hFig, 'CameraZoom', 6);
    setappdata(hFig, 'CamPitch', 0.5 * 3.1415);
    setappdata(hFig, 'CamYaw', -0.5 * 3.1415);
    setappdata(hFig, 'CameraPosition', [0 0 0]);
    setappdata(hFig, 'CameraTarget', [0 0 0]);
    RotateCameraAlongAxis(hFig, 0, 0);
end


function UpdateHierarchySelection(hFig, NodeIndex, Select)
    % Incorrect data
    if (size(NodeIndex,1) > 1 || isempty(NodeIndex ))
        return
    end
    % 
    if (NodeIndex == 1)
        return
    end
    % Go up the hierarchy
    NodePaths = bst_figures('GetFigureHandleField', hFig, 'NodePaths');
    PathToCenter = NodePaths{NodeIndex};
    % Retrieve Agregating node
    AgregatingNode = PathToCenter(find(PathToCenter == NodeIndex) + 1);
    % Get selected nodes
    selNodes = bst_figures('GetFigureHandleField', hFig, 'SelectedNodes');
    % Get agregated nodes
    AgregatedNodesIndex = getAgregatedNodesFrom(hFig, AgregatingNode);
    % Is everything selected ?
    if (size(AgregatedNodesIndex,1) == sum(ismember(AgregatedNodesIndex, selNodes)))
        SetSelectedNodes(hFig, AgregatingNode, Select);
        UpdateHierarchySelection(hFig, AgregatingNode, Select);
    end
end

%% ===== JAVA MOUSE WHEEL CALLBACK =====
function FigureMouseWheelCallback(hFig, ev)
    % Control Zoom
    CameraZoom = getappdata(hFig, 'CameraZoom');
    % 0.1 Factor is too much (6 Dec 2013). Now 0.05
    CameraZoom = CameraZoom + (double(ev.VerticalScrollCount) * double(ev.VerticalScrollAmount)) * 0.05;
    if (CameraZoom <= 0)
        CameraZoom = 0;
    end
    setappdata(hFig, 'CameraZoom', CameraZoom);
    UpdateCamera(hFig);
end


%% ===== POPUP MENU =====
function DisplayFigurePopup(hFig)
    import java.awt.event.KeyEvent;
    import java.awt.Dimension;
    import javax.swing.KeyStroke;
    import javax.swing.JLabel;
    import javax.swing.JSlider;
    import org.brainstorm.icon.*;
    % Get figure description
    hFig = bst_figures('GetFigure', hFig);
    % Get axes handles
    hAxes = getappdata(hFig, 'clickSource');
    if isempty(hAxes)
        return
    end
    
    DisplayInRegion = getappdata(hFig, 'DisplayInRegion');
    is3DDisplay = getappdata(hFig, 'is3DDisplay');
    
    % Create popup menu
    jPopup = java_create('javax.swing.JPopupMenu');
    
    % ==== MENU: COLORMAP =====
    bst_colormaps('CreateAllMenus', jPopup, hFig, 0);
    
    % ==== MENU: SNAPSHOT ====
    jPopup.addSeparator();
%     jMenuSave = gui_component('Menu', jPopup, [], 'Snapshots', IconLoader.ICON_SNAPSHOT);
%         % === SAVE AS IMAGE ===
%         jItem = gui_component('MenuItem', jMenuSave, [], 'Save as image', IconLoader.ICON_SAVE, [], @(h,ev)bst_call(@out_figure_image, hFig));
%         jItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_I, KeyEvent.CTRL_MASK));
%         % === OPEN AS IMAGE ===
%         jItem = gui_component('MenuItem', jMenuSave, [], 'Open as image', IconLoader.ICON_IMAGE, [], @(h,ev)bst_call(@out_figure_image, hFig, 'Viewer'));
%         jItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_J, KeyEvent.CTRL_MASK));       
%     jPopup.add(jMenuSave);
    
    % ==== MENU: 2D LAYOUT ====
    jGraphMenu = gui_component('Menu', jPopup, [], 'Display options', IconLoader.ICON_CONNECTN);
        % Check Matlab version: Works only for R2007b and newer
        if (bst_get('MatlabVersion') >= 705)
            if is3DDisplay
                % == MODIFY CORTEX TRANSPARENCY ==
                jPanelModifiers = gui_river([0 0], [3, 18, 3, 2]);
                Transparency = GetCortexTransparency(hFig);
                % Label
                jPanelModifiers.add(JLabel('Cortex Opacity'));
                % Slider
                jSliderContrast = JSlider(0,250,250);
                jSliderContrast.setValue(round(Transparency * 1000));
                jSliderContrast.setPreferredSize(java_scaled('dimension',100,23));
                %jSliderContrast.setToolTipText(tooltipSliders);
                jSliderContrast.setFocusable(0);
                jSliderContrast.setOpaque(0);
                jPanelModifiers.add('tab hfill', jSliderContrast);
                % Value (text)
                jLabelContrast = JLabel(sprintf('%0.2f', Transparency));
                jLabelContrast.setPreferredSize(java_scaled('dimension',50,23));
                jLabelContrast.setHorizontalAlignment(JLabel.LEFT);
                jPanelModifiers.add(jLabelContrast);
                % Slider callbacks
                java_setcb(jSliderContrast.getModel(), 'StateChangedCallback', @(h,ev)CortexTransparencySliderModifying_Callback(hFig, ev, jLabelContrast));
                jGraphMenu.add(jPanelModifiers);
            end
            
            % == MODIFY LINK TRANSPARENCY ==
            jPanelModifiers = gui_river([0 0], [3, 18, 3, 2]);
            Transparency = getappdata(hFig, 'LinkTransparency');
            % Label
            gui_component('label', jPanelModifiers, '', 'Link transp');
            % Slider
            jSliderContrast = JSlider(0,100,100);
            jSliderContrast.setValue(round(Transparency * 100));
            jSliderContrast.setPreferredSize(java_scaled('dimension',100,23));
            %jSliderContrast.setToolTipText(tooltipSliders);
            jSliderContrast.setFocusable(0);
            jSliderContrast.setOpaque(0);
            jPanelModifiers.add('tab hfill', jSliderContrast);
            % Value (text)
            jLabelContrast = gui_component('label', jPanelModifiers, '', sprintf('%.0f %%', Transparency * 100));
            jLabelContrast.setPreferredSize(java_scaled('dimension',50,23));
            jLabelContrast.setHorizontalAlignment(JLabel.LEFT);
            jPanelModifiers.add(jLabelContrast);
            % Slider callbacks
            % java_setcb(jSliderContrast, 'MouseReleasedCallback', @(h,ev)SliderModifiersValidate_Callback(h, ev, ColormapType, 'Contrast', jLabelContrast));
            java_setcb(jSliderContrast.getModel(), 'StateChangedCallback', @(h,ev)TransparencySliderModifiersModifying_Callback(hFig, ev, jLabelContrast));
            jGraphMenu.add(jPanelModifiers);

            % == MODIFY LINK SIZE ==
            jPanelModifiers = gui_river([0 0], [3, 18, 3, 2]);
            LinkSize = GetLinkSize(hFig);
            % Label
            gui_component('label', jPanelModifiers, '', 'Link size');
            % Slider
            jSliderContrast = JSlider(0,5,5);
            jSliderContrast.setValue(LinkSize);
            jSliderContrast.setPreferredSize(java_scaled('dimension',100,23));
            %jSliderContrast.setToolTipText(tooltipSliders);
            jSliderContrast.setFocusable(0);
            jSliderContrast.setOpaque(0);
            jPanelModifiers.add('tab hfill', jSliderContrast);
            % Value (text)
            jLabelContrast = gui_component('label', jPanelModifiers, '', sprintf('%.0f', round(LinkSize)));
            jLabelContrast.setPreferredSize(java_scaled('dimension',50,23));
            jLabelContrast.setHorizontalAlignment(JLabel.LEFT);
            jPanelModifiers.add(jLabelContrast);
            % Slider callbacks
            % java_setcb(jSliderContrast, 'MouseReleasedCallback', @(h,ev)SliderModifiersValidate_Callback(h, ev, ColormapType, 'Contrast', jLabelContrast));
            java_setcb(jSliderContrast.getModel(), 'StateChangedCallback', @(h,ev)SizeSliderModifiersModifying_Callback(hFig, ev, jLabelContrast));
            jGraphMenu.add(jPanelModifiers);
        end
        
        % === TOGGLE BACKGROUND WHITE/BLACK ===
        jGraphMenu.addSeparator();
        BackgroundColor = getappdata(hFig, 'BgColor');
        isWhite = all(BackgroundColor == [1 1 1]);
        jItem = gui_component('CheckBoxMenuItem', jGraphMenu, [], 'White background', [], [], @(h, ev)ToggleBackground(hFig));
        jItem.setSelected(isWhite);
        
        % === TOGGLE BLENDING OPTIONS ===
        BlendingEnabled = getappdata(hFig, 'BlendingEnabled');
        jItem = gui_component('CheckBoxMenuItem', jGraphMenu, [], 'Color blending', [], [], @(h, ev)ToggleBlendingMode(hFig));
        jItem.setSelected(BlendingEnabled);
        jItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_B, 0));
        jGraphMenu.addSeparator();
        
        % === TOGGLE BLENDING OPTIONS ===
        TextDisplayMode = getappdata(hFig, 'TextDisplayMode');
        jLabelMenu = gui_component('Menu', jGraphMenu, [], 'Labels Display');
            jItem = gui_component('CheckBoxMenuItem', jLabelMenu, [], 'Measure Nodes', [], [], @(h, ev)SetTextDisplayMode(hFig, 1));
            jItem.setSelected(ismember(1,TextDisplayMode));
            if (DisplayInRegion)
                jItem = gui_component('CheckBoxMenuItem', jLabelMenu, [], 'Region Nodes', [], [], @(h, ev)SetTextDisplayMode(hFig, 2));
                jItem.setSelected(ismember(2,TextDisplayMode));
            end
            jItem = gui_component('CheckBoxMenuItem', jLabelMenu, [], 'Selection only', [], [], @(h, ev)SetTextDisplayMode(hFig, 3));
            jItem.setSelected(ismember(3,TextDisplayMode));

        % === TOGGLE HIERARCHY NODE VISIBILITY ===
        if (DisplayInRegion)
            HierarchyNodeIsVisible = getappdata(hFig, 'HierarchyNodeIsVisible');
            jItem = gui_component('CheckBoxMenuItem', jGraphMenu, [], 'Hide region nodes', [], [], @(h, ev)SetHierarchyNodeIsVisible(hFig, 1 - HierarchyNodeIsVisible));
            jItem.setSelected(~HierarchyNodeIsVisible);
            jItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_H, 0));
        end
        
        % === TOGGLE BINARY LINK STATUS ===
        Method = getappdata(hFig, 'Method');
        if ismember(Method, {'granger'}) || ismember(Method, {'spgranger'})
            IsBinaryData = getappdata(hFig, 'IsBinaryData');
            jItem = gui_component('CheckBoxMenuItem', jGraphMenu, [], 'Binary Link Display', IconLoader.ICON_CHANNEL_LABEL, [], @(h, ev)SetIsBinaryData(hFig, 1 - IsBinaryData));
            jItem.setSelected(IsBinaryData);
            jItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_M, 0));
        end

    % ==== MENU: GRAPH DISPLAY ====
    jGraphMenu = gui_component('Menu', jPopup, [], 'Graph options', IconLoader.ICON_CONNECTN);
        % === SELECT ALL THE NODES ===
        jItem = gui_component('MenuItem', jGraphMenu, [], 'Select all the nodes', [], [], @(h, n, s, r)SetSelectedNodes(hFig, [], 1, 1));
        jItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_A, 0));
        % === SELECT NEXT REGION ===
        jItem = gui_component('MenuItem', jGraphMenu, [], 'Select next region', [], [], @(h, ev)ToggleRegionSelection(hFig, 1));
        jItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0));
        % === SELECT PREVIOUS REGION===
        jItem = gui_component('MenuItem', jGraphMenu, [], 'Select previous region', [], [], @(h, ev)ToggleRegionSelection(hFig, -1));
        jItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0));
        jGraphMenu.addSeparator();

        if (DisplayInRegion)
%             % === UP ONE LEVEL IN HIERARCHY ===
%             jItem = gui_component('MenuItem', jGraphMenu, [], 'One Level Up', [], [], @(h, ev)SetExplorationLevelTo(hFig, 1), []);
%             jItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0));
%             jGraphMenu.addSeparator();
%             
            % === TOGGLE DISPLAY REGION MEAN ===
            RegionLinksIsVisible = getappdata(hFig, 'RegionLinksIsVisible');
            RegionFunction = getappdata(hFig, 'RegionFunction');
            jItem = gui_component('CheckBoxMenuItem', jGraphMenu, [], ['Display region ' RegionFunction], [], [], @(h, ev)ToggleMeasureToRegionDisplay(hFig));
            jItem.setSelected(RegionLinksIsVisible);
            jItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_M, 0));
            
            % === TOGGLE REGION FUNCTIONS===
            IsMean = strcmp(RegionFunction, 'mean');
            jLabelMenu = gui_component('Menu', jGraphMenu, [], 'Region function');
                jItem = gui_component('CheckBoxMenuItem', jLabelMenu, [], 'Mean', [], [], @(h, ev)SetRegionFunction(hFig, 'mean'));
                jItem.setSelected(IsMean);
                jItem = gui_component('CheckBoxMenuItem', jLabelMenu, [], 'Max', [], [], @(h, ev)SetRegionFunction(hFig, 'max'));
                jItem.setSelected(~IsMean);
        end
    
    % Display Popup menu
    gui_popup(jPopup, hFig);
end

% Cortex transparency slider
function CortexTransparencySliderModifying_Callback(hFig, ev, jLabel)
    % Update Modifier value
    newValue = double(ev.getSource().getValue()) / 1000;
    % Setting newValue to 0 will automatically disable Blending
    if (newValue < eps)
        newValue = eps;
    end
    % Update text value
    jLabel.setText(sprintf('%0.2f', newValue));
    %
    SetCortexTransparency(hFig, newValue);
end

% Link transparency slider
function TransparencySliderModifiersModifying_Callback(hFig, ev, jLabel)
    % Update Modifier value
    newValue = double(ev.getSource().getValue()) / 100;
    % Update text value
    jLabel.setText(sprintf('%.0f %%', newValue * 100));
    %
    SetLinkTransparency(hFig, newValue);
end

% Link size slider
function SizeSliderModifiersModifying_Callback(hFig, ev, jLabel)
    % Update Modifier value
    newValue = ev.getSource().getValue();
    % Update text value
    jLabel.setText(sprintf('%.0f', round(newValue)));
    %
    SetLinkSize(hFig, newValue);
end


%% ===========================================================================
%  ===== PLOT FUNCTIONS ======================================================
%  ===========================================================================

%% ===== GET FIGURE DATA =====
function [Time, Freqs, TfInfo, TF, RowNames, DataType, Method, FullTimeVector] = GetFigureData(hFig)
    global GlobalData;
    % === GET FIGURE INFO ===
    % Get selected frequencies and rows
    TfInfo = getappdata(hFig, 'Timefreq');
    if isempty(TfInfo)
        return
    end
    % Get data description
    [iDS, iTimefreq] = bst_memory('GetDataSetTimefreq', TfInfo.FileName);
    if isempty(iDS)
        return
    end
    
    % ===== GET TIME =====
    [Time, iTime] = bst_memory('GetTimeVector', iDS, [], 'CurrentTimeIndex');
    Time = Time(iTime);
    FullTimeVector = Time;
    % If it is a static figure: keep only the first and last times
    if getappdata(hFig, 'isStatic')
        Time = Time([1,end]);
    end
    
    % ===== GET FREQUENCIES =====
    % Get the current freqency
    TfInfo.iFreqs = GlobalData.UserFrequencies.iCurrentFreq;
    if isempty(TfInfo.iFreqs)
        Freqs = GlobalData.DataSet(iDS).Timefreq(iTimefreq).Freqs;
    elseif ~iscell(GlobalData.DataSet(iDS).Timefreq(iTimefreq).Freqs)
       if (GlobalData.DataSet(iDS).Timefreq(iTimefreq).Freqs == 0)
           Freqs = [];
           TfInfo.iFreqs = 1;
       else
           Freqs = GlobalData.DataSet(iDS).Timefreq(iTimefreq).Freqs(TfInfo.iFreqs);
           if (size(Freqs,1) ~= 1)
               Freqs = Freqs';
           end
       end
    else
        % Get a set of frequencies (freq bands)
        Freqs = GlobalData.DataSet(iDS).Timefreq(iTimefreq).Freqs(TfInfo.iFreqs);
    end
        
    % ===== GET DATA =====
    RowNames = GlobalData.DataSet(iDS).Timefreq(iTimefreq).RowNames;
    % Only if requested
    if (nargout >= 4)
        % Get TF values
        [TF, iTimeBands] = bst_memory('GetTimefreqValues', iDS, iTimefreq, [], TfInfo.iFreqs, iTime, TfInfo.Function);
        % Get connectivity matrix
        TF = bst_memory('ReshapeConnectMatrix', iDS, iTimefreq, TF);
        % Get time bands
        if ~isempty(iTimeBands)
            Time = GlobalData.DataSet(iDS).Timefreq(iTimefreq).TimeBands(iTimeBands,:);
        end
        % Data type
        DataType = GlobalData.DataSet(iDS).Timefreq(iTimefreq).DataType;
        % Method
        Method = GlobalData.DataSet(iDS).Timefreq(iTimefreq).Method;
    end
end

function IsDirectional = IsDirectionalData(hFig)
    % If directional data
    IsDirectional = getappdata(hFig, 'IsDirectionalData');
    % Ensure variable
    if isempty(IsDirectional)
        IsDirectional = 0;
    end
end

function DataPair = LoadConnectivityData(hFig, Options, Atlas, Surface)
    % Parse input
    if (nargin < 2)
        Options = struct();
    end
    if (nargin < 3)
        Atlas = [];
        Surface = [];
    end
    % Maximum number of data allowed
    MaximumNumberOfData = 5000;
   
    % === GET DATA ===
    [Time, Freqs, TfInfo, M, RowNames, DataType, Method, FullTimeVector] = GetFigureData(hFig);
    % Zero-out the diagonal because its useless
    M = M - diag(diag(M));
    % If the matrix is symetric and Not directional
    if (isequal(M, M') && ~IsDirectionalData(hFig))
        % We don't need the upper half
        for i = 1:size(M,1)
            M(i,i:end) = 0;
        end
    end
    
    % === THRESHOLD ===
    if ((size(M,1) * size(M,2)) > MaximumNumberOfData)
        % Validity mask
        Valid = ones(size(M));
        Valid(M == 0) = 0;
        Valid(diag(ones(size(M)))) = 0;
        
        % === ZERO-OUT NEIGHBORS VALUES ===
%         if isfield(Options,'Neighbours') && Options.Neighbours
%             % Do we have data to work with ?
%             if ~isempty(Atlas) && ~isempty(Surface)
%                 % Because
%                 VertConn = full(Surface.VertConn);
%                 % 
%                 nScouts = length(Atlas.Scouts);
%                 % If sources are elemental dipole
%                 if (nScouts == size(Surface.Vertices,1))
%                     Valid = Valid & ~VertConn;
%                 else
%                     CellIndex = cellfun(@(V,I) repmat(I,1,length(V)), {Atlas.Scouts.Vertices}, num2cell(1:length(Atlas.Scouts)), 'UniformOutput', 0);
%                     Index = zeros(size(Surface.Vertices,1),1);
%                     Index([Atlas.Scouts.Vertices]) = [CellIndex{:}];
%                     % 
%                     for i=1:nScouts
%                         Idx = unique(Index(any(VertConn(Atlas.Scouts(i).Vertices,:),1)));
%                         Idx(Idx == i) = [];
%                         Idx(Idx == 0) = [];
%                         Valid(i,Idx) = 0;
%                     end
%                 end
%             end
%         end
        
        % === ZERO-OUT DISTANCE ===
%         if isfield(Options,'Distance') && Options.Distance
%             if isempty(Atlas)
%                 [n,dims] = size(Surface.Vertices);
%                 a = reshape(Surface.Vertices,1,n,dims);
%                 b = reshape(Surface.Vertices,n,1,dims);
%                 dmat = sqrt(sum((a(ones(n,1),:,:) - b(:,ones(n,1),:)).^2,3));
%                 DistanceFactor = getappdata(hFig, 'MeasureDistanceFactor');
%                 dmat = dmat .* DistanceFactor;
%                 Valid = Valid & (dmat > 20);
%             else
%             end
%         end
        
        % === ZERO-OUT LOWEST VALUES ===
        if isfield(Options,'Highest') && Options.Highest
            % Retrieve min/max
            DataMinMax = [min(M(:)), max(M(:))];
            % Keep highest values only
            if (DataMinMax(1) >= 0)
                [tmp,tmp,s] = find(M(Valid == 1));
                B = sort(s, 'descend');
                if length(B) > MaximumNumberOfData
                    t = B(MaximumNumberOfData);
                    Valid = Valid & (M >= t);
                end
            else
                [tmp,tmp,s] = find(M(Valid == 1));
                B = sort(abs(s), 'descend');
                if length(B) > MaximumNumberOfData
                    t = B(MaximumNumberOfData);
                    Valid = Valid & ((M <= -t) | (M >= t));
                end
            end
        end
        
        % 
        M(~Valid) = 0;
    end

    % Convert matrixu to data pair
    DataPair = MatrixToDataPair(hFig, M);
    
    fprintf('%.0f Connectivity measure loaded\n', size(DataPair,1));

    % ===== MATRIX STATISTICS ===== 
    DataMinMax = [min(DataPair(:,3)), max(DataPair(:,3))];
    if isempty(DataMinMax)
        DataMinMax = [0 1];
    elseif (DataMinMax(1) == DataMinMax(2))
        if (DataMinMax(1) > 0)
            DataMinMax = [0 DataMinMax(2)];
        elseif (DataMinMax(2) < 0)
            DataMinMax = [DataMinMax(1), 0];
        else
            DataMinMax = [0 1];
        end
    end
    % Update figure variable
    bst_figures('SetFigureHandleField', hFig, 'DataMinMax', DataMinMax);
    
    % Clear memory
    clear M;
end


function aDataPair = MatrixToDataPair(hFig, mMatrix)
    % Reshape
    [i,j,s] = find(mMatrix);
    i = i';
    j = j';
    mMatrix = reshape([i;j],1,[]);
    % Convert to datapair structure
    aDataPair = zeros(size(mMatrix,2)/2,3);
    aDataPair(1:size(mMatrix,2)/2,1) = mMatrix(1:2:size(mMatrix,2));
    aDataPair(1:size(mMatrix,2)/2,2) = mMatrix(2:2:size(mMatrix,2));
    aDataPair(1:size(mMatrix,2)/2,3) = s(:);
    % Add offset
    nAgregatingNode = size(bst_figures('GetFigureHandleField', hFig, 'AgregatingNodes'),2);
    aDataPair(:,1:2) = aDataPair(:,1:2) + nAgregatingNode;
end


%% ===== UPDATE FIGURE PLOT =====
function LoadFigurePlot(hFig) %#ok<DEFNU>
    global GlobalData;
    % Necessary for data initialization
    ResetDisplay(hFig);
    % Get figure description
    [hFig, tmp, iDS] = bst_figures('GetFigure', hFig);
    % Get connectivity matrix
    [Time, Freqs, TfInfo] = GetFigureData(hFig);
    % Get the file descriptor in memory
    iTimefreq = bst_memory('GetTimefreqInDataSet', iDS, TfInfo.FileName);
    % Data type
    DataType = GlobalData.DataSet(iDS).Timefreq(iTimefreq).DataType;
    RowNames = GlobalData.DataSet(iDS).Timefreq(iTimefreq).RowNames;
    % ===== GET REGION POSITIONS AND HIERARCHY =====
    % Inialize variables
    sGroups = repmat(struct('Name', [], 'RowNames', [], 'Region', []), 0);
    SurfaceMat = [];
    Vertices = [];
    RowLocs = [];
    Atlas = [];
    % Technique to get the hierarchy depends on the data type
    switch (DataType)
        case 'data'
            % ===== CHANNEL =====
            % Get selections
            sSelect = panel_montage('GetMontagesForFigure', hFig);
            % Check if all the rows to display are in the selections (if not: ignore selections)
            if ~isempty(sSelect)
                AllRows = cat(2, sSelect.ChanNames);
                if ~all(ismember(RowNames, AllRows))
                    sSelect = [];
                    disp('Oops select');
                end
            end
            % Use selections
            if ~isempty(sSelect)
                for iSel = 1:length(sSelect)
                    groupRows = intersect(RowNames, sSelect(iSel).ChanNames);
                    if ~isempty(groupRows)
                        % Detect region based on name
                        Name = upper(sSelect(iSel).Name);
                        Region = [];
                        switch Name
                            case {'CTF LF'}
                                Region = 'LF';
                            case {'CTF LT'}
                                Region = 'LT';
                            case {'CTF LP'}
                                Region = 'LP';
                            case {'CTF LC'}
                                Region = 'LC';
                            case {'CTF LO'}
                                Region = 'LO';
                            case {'CTF RF'}
                                Region = 'RF';
                            case {'CTF RT'}
                                Region = 'RT';
                            case {'CTF RP'}
                                Region = 'RP';
                            case {'CTF RC'}
                                Region = 'RC';
                            case {'CTF RO'}
                                Region = 'RO';
                            case {'CTF ZC'}
                                Region = 'UU';
                            case {'LEFT-TEMPORAL'}
                                Region = 'LT';
                            case {'RIGHT-TEMPORAL'}
                                Region = 'RT';
                            case {'LEFT-PARIETAL'}
                                Region = 'LP';
                            case {'RIGHT-PARIETAL'}
                                Region = 'RP';
                            case {'LEFT-OCCIPITAL'}
                                Region = 'LO';
                            case {'RIGHT-OCCIPITAL'}
                                Region = 'RO';
                            case {'LEFT-FRONTAL'}
                                Region = 'LF';
                            case {'RIGHT-FRONTAL'}
                                Region = 'RF';
                        end
                        if (~isempty(Region))
                            iGroup = length(sGroups) + 1;
                            sGroups(iGroup).Name = sSelect(iSel).Name;
                            sGroups(iGroup).RowNames = groupRows;
                            sGroups(iGroup).Region = Region;
                        end
                    end
                end
            end
            % Sensors positions
            selChan = zeros(1, length(RowNames));
            for iRow = 1:length(RowNames)
                % Get indice in the 
                selChan(iRow) = find(strcmpi({GlobalData.DataSet(iDS).Channel.Name}, RowNames{iRow}));
            end
            RowLocs = figure_3d('GetChannelPositions', iDS, selChan);

        case {'results', 'matrix'}
            % Get the file information file
            SurfaceFile = GlobalData.DataSet(iDS).Timefreq(iTimefreq).SurfaceFile;
            Atlas       = GlobalData.DataSet(iDS).Timefreq(iTimefreq).Atlas;
            % Load surface
            if ~isempty(SurfaceFile) && ischar(SurfaceFile)
                SurfaceMat = in_tess_bst(SurfaceFile);
                Vertices = SurfaceMat.Vertices;
            end
            % If an atlas is available
            if ~isempty(Atlas) && ~isempty(SurfaceFile) && ~isempty(Vertices)
                % Create groups using the file atlas
                sGroups = GroupScouts(Atlas);
                % Get the position of each scout: use the seed position
                RowLocs = Vertices([Atlas.Scouts.Seed], :);
            elseif ~isempty(Vertices)
                RowLocs = Vertices;
            end

        otherwise
            error('Unsupported');
    end

    is3DDisplay = getappdata(hFig, 'is3DDisplay');
    if isempty(is3DDisplay) || isempty(RowLocs) || isempty(SurfaceMat)
        is3DDisplay = 0;
    end
    DisplayInCircle = 0;
    DisplayInRegion = 0;
    
    % Assign generic name if necessary
    if isempty(RowNames)
        RowNames = cellstr(num2str((1:size(Vertices,1))'));
    end
    % Ensure proper alignment
    if (size(RowNames,2) > size(RowNames,1))
        RowNames = RowNames';
    end
    % Ensure proper type
    if isa(RowNames, 'double')
        RowNames = cellstr(num2str(RowNames));
    end
    
    %% === ASSIGN GROUPS: CRUCIAL STEP ===
    if is3DDisplay
        % 3D display uses groups to speed the pathway computation
        if isempty(sGroups)
            % Assign groups
            sGroups = AssignGroupBasedOnCentroid(RowLocs, RowNames, sGroups, SurfaceMat);
        end
    else
        % If no hierarchy is defined, display in circle
        if isempty(sGroups)
            % No data to arrange in groups
            if isempty(RowLocs) || isempty(SurfaceMat)
                DisplayInCircle = 1;
                % Create a group for each node
                sGroups = repmat(struct('Name', [], 'RowNames', [], 'Region', []), 0);
                for i=1:length(RowNames)
                    sGroups(1).Name = RowNames{i};
                    sGroups(1).RowNames = [sGroups(1).RowNames {num2str(RowNames{i})}];
                    sGroups(1).Region = 'UU';
                end
            else
                % We have location data so we can aim for
                % a basic 4 quadrants display
                DisplayInRegion = 1;            
                sGroups = AssignGroupBasedOnCentroid(RowLocs, RowNames, sGroups, SurfaceMat);
            end
        else
            % Display in region
            DisplayInRegion = 1;
            % Force basic Anterior/Posterior if necessary
            if (length(sGroups) == 2 && ...
                strcmp(sGroups(1).Region(2), 'U') == 1 && ...
                strcmp(sGroups(2).Region(2), 'U') == 1)
                sGroups = AssignGroupBasedOnCentroid(RowLocs, RowNames, sGroups, SurfaceMat);
            end
        end
    end
    setappdata(hFig, 'DisplayInCircle', DisplayInCircle);
    setappdata(hFig, 'DisplayInRegion', DisplayInRegion);
    setappdata(hFig, 'is3DDisplay', is3DDisplay);

    % IsBinaryData -> Granger
    % IsDirectionalData -> Granger
    setappdata(hFig, 'DefaultRegionFunction', 'max');
    setappdata(hFig, 'DisplayOutwardMeasure', 1);
    setappdata(hFig, 'DisplayInwardMeasure', 1);
    setappdata(hFig, 'HasLocationsData', ~isempty(RowLocs));
    setappdata(hFig, 'MeasureDistanceFactor', 1000); % mm to m
    
    % Retrieve scout colors if possible
    RowColors = BuildNodeColorList(RowNames, Atlas);
    
    % Keep a copy of these variable for figure updates
    bst_figures('SetFigureHandleField', hFig, 'Groups', sGroups);
    bst_figures('SetFigureHandleField', hFig, 'RowNames', RowNames);
    bst_figures('SetFigureHandleField', hFig, 'RowLocs', RowLocs);
    bst_figures('SetFigureHandleField', hFig, 'RowColors', RowColors);
    
    OGL = getappdata(hFig, 'OpenGLDisplay');
        
    %% ===== ORGANISE VERTICES =====    
    if DisplayInCircle
        [Vertices Paths Names] = OrganiseNodeInCircle(hFig, RowNames, sGroups);
    elseif DisplayInRegion
        [Vertices Paths Names] = OrganiseNodesWithConstantLobe(hFig, RowNames, sGroups, RowLocs, 1);
    elseif is3DDisplay
        % === 3D DISPLAY IS A PROTOTYPE ===
        % Copy cortex Vertices and Faces
        V = SurfaceMat.Vertices;
        F = SurfaceMat.Faces;
        % Scale vertex to stay inside viewing space
        CameraZoom = getappdata(hFig, 'CameraZoom');
        VertexScale3D = (CameraZoom + 1) / (max(sqrt(sum(V.^2,2))));
        % Centroid offset is used to center the model
        Centroid = sum(V,1) / size(V,1);
        V = V - repmat(Centroid, size(V,1), 1);
        V = V * VertexScale3D;
        % Reassign
        TempSurf = SurfaceMat;
        TempSurf.Vertices = V;
        
        % Both variables are needed in OrganiseChannelsIn3D
        setappdata(hFig, 'VertexScale3D', VertexScale3D);
        setappdata(hFig, 'VertexInitCentroid', Centroid);
        
        % Add polygon to Java
        OGL.addPolygon(reshape(V',[],1), reshape(F',[],1) - 1, 1);
        % Typical rendering options
        SetCortexTransparency(hFig, 0.025);
        OGL.setPolygonColor(0, 0, 0, 0);
        OGL.setPolygonVisible(0, 1);
        
%        Atlas = GlobalData.DataSet(iDS).Timefreq(iTimefreq).Atlas;
%        nScouts = size(Atlas.Scouts,2);
%        for i=1:nScouts
%             sV = Atlas.Scouts(i).Vertices;
%             vIndex = zeros(size(V,1),1);
%             vIndex(sV) = find(sV);
%             mF = ismember(F,sV);
%             sF = F(sum(mF,2) == 3,:);
%             sF = vIndex(sF(:,:));
%             
%             OGL.addPolygon(reshape(V(sV,:)',[],1), reshape(sF',[],1) - 1, 1);
%             OGL.setPolygonColor(i - 1, rand(1,1), rand(1,1), rand(1,1));
%             OGL.setPolygonTransparency(i - 1, 0.2);
% 
%             Outlines = ComputePolygonOutline(SurfaceMat, Atlas.Scouts(i));
%             O = Outlines{1};
%             OGL.addRegionOutline(V(sV(O),1), V(sV(O),2), V(sV(O),3));
%             OGL.setRegionOutlineColor(i - 1, rand(1,1), rand(1,1), rand(1,1));
%             OGL.setRegionOutlineTransparency(i - 1, 0.3);
%             OGL.setRegionOutlineThickness(i - 1, 0.5);
%        end

         % 3D agregating node connectivity map
        Conn = zeros(24);
        Connected = [1 2; 1 3; 1 17; 1 18; 1 20; 1 21;
                     2 1; 2 4; 2 18; 2 19; 2 21; 2 22;
                     3 1; 3 4; 3 7; 3 8; 3 10; 3 11;
                     4 2; 4 3; 4 8; 4 9; 4 11; 4 12;
                     ...
                     5 6; 5 8;
                     6 8;
                     7 8; 7 10;
                     8 9; 8 11;
                     9 12;
                     10 11;
                     11 12; 11 13; 11 14;
                     12 14;
                     13 14;
                     14 13;
                     ...
                     15 16; 15 18;
                     16 18;
                     17 18; 17 20;
                     18 19; 18 21;
                     19 22;
                     20 21;
                     21 22; 21 23; 21 24;
                     22 24;
                     23 24;
                     24 23];
        
        idx = sub2ind(size(Conn), Connected(:,1), Connected(:,2));
        idx2 = sub2ind(size(Conn), Connected(:,2), Connected(:,1));
        Conn([idx;idx2]) = 1;
        % Cost function is favoring middle lines (better display)
        Cost = ones(size(Conn));
        C = [8 5; 8 6; 8 11;
             11 13; 11 14; 11 8;
             18 15; 18 16; 18 21;
             21 23; 21 24; 21 18];
        idx = sub2ind(size(Cost), C(:,1), C(:,2));
        idx2 = sub2ind(size(Cost), C(:,2), C(:,1));
        Conn([idx;idx2]) = 1;% * 0.5;
        % Dijkstra 
        [tmp, AgregatingNodeConnectMap] = jk_dijkstra(Conn, Cost);
        bst_figures('SetFigureHandleField', hFig, 'AgregatingNodeConnectMap', AgregatingNodeConnectMap);
        % 
        [Vertices Paths Names] = OrganiseChannelsIn3D(hFig, sGroups, RowNames, RowLocs, TempSurf);
    else
        disp('Unsupported display. Contact administrator, sorry for the inconvenience');
    end
    
    % Keep graph data
    bst_figures('SetFigureHandleField', hFig, 'NumberOfNodes', size(Vertices,1));
    bst_figures('SetFigureHandleField', hFig, 'Vertices', Vertices);
    bst_figures('SetFigureHandleField', hFig, 'NodePaths', Paths);
    bst_figures('SetFigureHandleField', hFig, 'Names', Names);
    bst_figures('SetFigureHandleField', hFig, 'DisplayNode', ones(size(Vertices,1),1));
    bst_figures('SetFigureHandleField', hFig, 'ValidNode', ones(size(Vertices,1),1));
    
    % Add nodes to Java
    %   This also defines some data-based display parameters
    ClearAndAddChannelsNode(hFig, Vertices, Names);
    
    % Background color :
    %   White is for publications
    %   Black for visualization (default)
    BackgroundColor = GetBackgroundColor(hFig);
    SetBackgroundColor(hFig, BackgroundColor);

    % Prototype (Not working)
    % Compute and add radial region for selection
    % if (is3DDisplay == 0 && DisplayInCircle == 0)
    %    SetupRadialRegion(hFig, Vertices, sGroups, RowNames, RowLocs);
    % end
    
    %% ===== Compute Links =====
    % Data cleaning options
    Options.Neighbours = 0;
    Options.Distance = 0;
    Options.Highest = 1;
    setappdata(hFig, 'LoadingOptions', Options);
    % Clean and compute Datapair
    DataPair = LoadConnectivityData(hFig, Options, Atlas, SurfaceMat);    
    bst_figures('SetFigureHandleField', hFig, 'DataPair', DataPair);
    
    % Compute distance between regions
    MeasureDistance = [];
    if ~isempty(RowLocs)
        MeasureDistance = ComputeEuclideanMeasureDistance(hFig, DataPair, RowLocs);
    end
    bst_figures('SetFigureHandleField', hFig, 'MeasureDistance', MeasureDistance);
    
    % Build path based on region
    if is3DDisplay
        MeasureLinks = BuildRegionPath3D(hFig, Paths, DataPair, Vertices);
    else
        MeasureLinks = BuildRegionPath(hFig, Paths, DataPair);
    end
    
    % Compute spline based on MeasureLinks
    aSplines = ComputeSpline(hFig, MeasureLinks, Vertices);
    if ~isempty(aSplines)
        % Add on Java side
        OGL.addPrecomputedMeasureLinks(aSplines);
        % Get link size
        LinkSize = getappdata(hFig, 'LinkSize');
        % Set link width
        SetLinkSize(hFig, LinkSize);
        % Set link transparency
        if (is3DDisplay)
            SetLinkTransparency(hFig, 0.75);
        else
            SetLinkTransparency(hFig, 0.00);
        end
    end
        
    %% ===== Init Filters =====
    % 
    MinThreshold = 0.9;
    if is3DDisplay
        MinThreshold = 0.5;        
    end
    
    % Don't refresh display for each filter at loading time
    Refresh = 0;
    
    % Clear filter masks
    bst_figures('SetFigureHandleField', hFig, 'MeasureDistanceMask', zeros(size(DataPair,1),1));
    bst_figures('SetFigureHandleField', hFig, 'MeasureThresholdMask', zeros(size(DataPair,1),1));
    bst_figures('SetFigureHandleField', hFig, 'MeasureAnatomicalMask', zeros(size(DataPair,1),1));
    bst_figures('SetFigureHandleField', hFig, 'MeasureDisplayMask', zeros(size(DataPair,1),1));
    
    % Application specific display filter
    SetMeasureDisplayFilter(hFig, ones(size(DataPair,1), Refresh));
    % Min/Max distance filter
    SetMeasureDistanceFilter(hFig, 20, 150, Refresh);
    % Anatomy filter
    SetMeasureAnatomicalFilterTo(hFig, 0, Refresh);
    % Fiber filter
    SetMeasureFiberFilterTo(hFig, 0, Refresh);
    % Causality direction filter
    IsDirectionalData = getappdata(hFig, 'IsDirectionalData');
    if (IsDirectionalData)
        setDisplayMeasureMode(hFig, 1, 1, 1, Refresh);
    end
    % Threshold in absolute values
    if isempty(DataPair)
        ThresholdMinMax = [0 0];
    else
        ThresholdAbsoluteValue = getappdata(hFig, 'ThresholdAbsoluteValue');
        if isempty(ThresholdAbsoluteValue) || ~ThresholdAbsoluteValue
            ThresholdMinMax = [min(DataPair(:,3)), max(DataPair(:,3))];
        else
            ThresholdMinMax = [min(abs(DataPair(:,3))), max(abs(DataPair(:,3)))];
        end
    end
    bst_figures('SetFigureHandleField', hFig, 'ThresholdMinMax', ThresholdMinMax);
    % Minimum measure filter
    SetMeasureThreshold(hFig, ThresholdMinMax(1) + MinThreshold * (ThresholdMinMax(2) - ThresholdMinMax(1)), Refresh);

    % Region links
    SetRegionFunction(hFig, getappdata(hFig, 'DefaultRegionFunction'));
    
    %% ===== Rendering option =====
    % Select all
    SetSelectedNodes(hFig, [], 1);
    % Blending
    SetBlendingMode(hFig, 0);
    
    % OpenGL Constant
    % GL_LIGHTING = 2896
    % GL_COLOR_MATERIAL 2903
    % GL_DEPTH_TEST = 2929
    
    % These options are necessary for proper display
    if ~is3DDisplay
        OGL.OpenGLDisable(2896);
        OGL.OpenGLDisable(2903);
        SetHierarchyNodeIsVisible(hFig, 1);
        RenderInQuad = 1;
    else
        OGL.OpenGLEnable(2896);
        OGL.OpenGLEnable(2903);
        SetHierarchyNodeIsVisible(hFig, 0);
        setappdata(hFig, 'TextDisplayMode', []);
        RenderInQuad = 0;
    end
    % 
    OGL.renderInQuad(RenderInQuad);
    setappdata(hFig, 'RenderInQuad', RenderInQuad);
    
    % Update colormap
    UpdateColormap(hFig);
    % 
    RefreshTextDisplay(hFig);
    % Last minute hiding
    HideLonelyRegionNode(hFig);
    % Position camera
    DefaultCamera(hFig);
    % Make sure we have a final request for redraw
    OGL.repaint();
end

function NodeColors = BuildNodeColorList(RowNames, Atlas)
    % We assume RowNames and Scouts are in the same order
    if ~isempty(Atlas)
        NodeColors = reshape([Atlas.Scouts.Color], 3, length(Atlas.Scouts))';
    else
        % Default neutral color
        NodeColors = 0.5 * ones(length(RowNames),3);
    end
end

function sGroups = AssignGroupBasedOnCentroid(RowLocs, RowNames, sGroups, Surface)
    % Compute centroid
    Centroid = sum(Surface.Vertices,1) / size(Surface.Vertices,1);
    % Split in hemisphere first if necessary
    if isempty(sGroups)
        % 
        sGroups(1).Name = 'Left';
        sGroups(1).Region = 'LU';
        sGroups(2).Name = 'Right';
        sGroups(2).Region = 'RU';
        % 
        sGroups(1).RowNames = RowNames(RowLocs(:,2) >= Centroid(2));    
        sGroups(2).RowNames = RowNames(RowLocs(:,2) < Centroid(2));
    end
    % For each hemisphere
    for i=1:2
        OriginalGroupRows = ismember(RowNames, [sGroups(i).RowNames]);
        Posterior = RowLocs(:,1) >= Centroid(1) & OriginalGroupRows;
        Anterior = RowLocs(:,1) < Centroid(1) & OriginalGroupRows;
        % Posterior assignment
        sGroups(i).Name = [sGroups(i).Name ' Posterior'];
        sGroups(i).RowNames = RowNames(Posterior)';
        sGroups(i).Region = [sGroups(i).Region(1) 'P'];
        % Anterior assignment
        sGroups(i+2).Name = [sGroups(i).Name ' Anterior'];
        sGroups(i+2).RowNames = RowNames(Anterior)';
        sGroups(i+2).Region = [sGroups(i).Region(1) 'A'];
    end
end


function UpdateFigurePlot(hFig)
    % Progress bar
    bst_progress('start', 'Functional Connectivity Display', 'Updating figures...');
    % Get selected rows
    selNodes = bst_figures('GetFigureHandleField', hFig, 'SelectedNodes');
    % Get OpenGL handle
    OGL = getappdata(hFig, 'OpenGLDisplay');
    % Clear links
    OGL.clearLinks();
    % 3D display ?
    is3DDisplay = getappdata(hFig, 'is3DDisplay');
    % Get Rowlocs
    RowLocs = bst_figures('GetFigureHandleField', hFig, 'RowLocs');

    OrganiseNode = bst_figures('GetFigureHandleField', hFig, 'OrganiseNode');
    if ~isempty(OrganiseNode)
        % Reset display
        OGL.resetDisplay();
        % Back to Default camera
        DefaultCamera(hFig);
        % Which hierarchy level are we ?
        NodeLevel = 1;
        Levels = bst_figures('GetFigureHandleField', hFig, 'Levels');
        for i=1:size(Levels,1)
            if ismember(OrganiseNode,Levels{i})
                NodeLevel = i;
            end
        end
        % 
        Groups = bst_figures('GetFigureHandleField', hFig, 'Groups');
        RowNames = bst_figures('GetFigureHandleField', hFig, 'RowNames');
        nAgregatingNodes = size(bst_figures('GetFigureHandleField', hFig, 'AgregatingNodes'),2);
        % 
        Nodes = getAgregatedNodesFrom(hFig, OrganiseNode);
        % 
        Channels = ismember(RowNames, [Groups.RowNames]);
        Index = find(Channels) + nAgregatingNodes;
        InGroups = Index(ismember(Index,Nodes)) - nAgregatingNodes;
        NamesOfNodes = RowNames(InGroups);
        
        GroupsIWant = [];
        for i=1:size(Groups,2)
            if (sum(ismember(Groups(i).RowNames, NamesOfNodes)) > 0)
                GroupsIWant = [GroupsIWant i];
            end
        end
        
        if (OrganiseNode == 1)
            % Return to first display
            DisplayInCircle = getappdata(hFig, 'DisplayInCircle');
            if (~isempty(DisplayInCircle) && DisplayInCircle == 1)
                Vertices = OrganiseNodeInCircle(hFig, RowNames, Groups);
            else
                Vertices = OrganiseNodesWithConstantLobe(hFig, RowNames, Groups, RowLocs, 1);
            end
        else
            % 
            Vertices = ReorganiseNodeAroundInCircle(hFig, Groups(GroupsIWant), RowNames, NodeLevel);
        end
        % 
        bst_figures('SetFigureHandleField', hFig, 'Vertices', Vertices);
        % 
        nVertices = size(Vertices,1);
        Visible = sum(Vertices(:,1:3) ~= repmat([0 0 -5], nVertices,1),2) >= 1;
        % 
        DisplayNode = zeros(nVertices,1);
        DisplayNode(OrganiseNode) = 1;
        DisplayNode(Visible) = 1;
        % 
        bst_figures('SetFigureHandleField', hFig, 'DisplayNode', DisplayNode);
        bst_figures('SetFigureHandleField', hFig, 'ValidNode', DisplayNode);
        % Add the nodes to Java
        ClearAndAddChannelsNode(hFig, Vertices, bst_figures('GetFigureHandleField', hFig, 'Names'));
    else
        % We assume that if 3D display, we did not unload the polygons
        % so we simply need to load new data
    end
    
    Options = getappdata(hFig, 'LoadingOptions');
    % Clean and Build Datapair
    DataPair = LoadConnectivityData(hFig, Options);
    % Update structure
    bst_figures('SetFigureHandleField', hFig, 'DataPair', DataPair);
        
    % Update measure distance
    MeasureDistance = [];
    if ~isempty(RowLocs)
        MeasureDistance = ComputeEuclideanMeasureDistance(hFig, DataPair, RowLocs);
    end
    % Update figure variable
    bst_figures('SetFigureHandleField', hFig, 'MeasureDistance', MeasureDistance);
    
    % Get computed vertices
    Vertices = bst_figures('GetFigureHandleField', hFig, 'Vertices');
    % Get computed vertices paths to center
    NodePaths = bst_figures('GetFigureHandleField', hFig, 'NodePaths');
    % Build Datapair path based on region
    if is3DDisplay
        MeasureLinks = BuildRegionPath3D(hFig, NodePaths, DataPair, Vertices);
    else
        MeasureLinks = BuildRegionPath(hFig, NodePaths, DataPair);
    end
    % Compute spline for MeasureLinks based on Vertices position
    aSplines = ComputeSpline(hFig, MeasureLinks, Vertices);
    if ~isempty(aSplines)
        % Add on Java side
        OGL.addPrecomputedMeasureLinks(aSplines);
        % Set link width
        SetLinkSize(hFig, getappdata(hFig, 'LinkSize'));
        % Set link transparency
        SetLinkTransparency(hFig, getappdata(hFig, 'LinkTransparency'));
    end
    
    %% ===== FILTERS =====
    Refresh = 0;
    
    % Init Filter variables
    bst_figures('SetFigureHandleField', hFig, 'MeasureDistanceMask', zeros(size(DataPair,1),1));
    bst_figures('SetFigureHandleField', hFig, 'MeasureThresholdMask', zeros(size(DataPair,1),1));
    bst_figures('SetFigureHandleField', hFig, 'MeasureAnatomicalMask', zeros(size(DataPair,1),1));
    bst_figures('SetFigureHandleField', hFig, 'MeasureDisplayMask', zeros(size(DataPair,1),1));
    
    % Threshold 
    if isempty(DataPair)
        ThresholdMinMax = [0 0];
    else
        ThresholdAbsoluteValue = getappdata(hFig, 'ThresholdAbsoluteValue');
        if isempty(ThresholdAbsoluteValue) || ~ThresholdAbsoluteValue
            ThresholdMinMax = [min(DataPair(:,3)), max(DataPair(:,3))];
        else
            ThresholdMinMax = [min(abs(DataPair(:,3))), max(abs(DataPair(:,3)))];
        end
    end
    bst_figures('SetFigureHandleField', hFig, 'ThresholdMinMax', ThresholdMinMax);

    % Reset filters using the same thresholds
    SetMeasureDisplayFilter(hFig, ones(size(DataPair,1),1), Refresh);
    SetMeasureDistanceFilter(hFig, bst_figures('GetFigureHandleField', hFig, 'MeasureMinDistanceFilter'), ...
        bst_figures('GetFigureHandleField', hFig, 'MeasureMaxDistanceFilter'), ...
        Refresh);
    SetMeasureAnatomicalFilterTo(hFig, bst_figures('GetFigureHandleField', hFig, 'MeasureAnatomicalFilter'), Refresh);
    SetMeasureThreshold(hFig, bst_figures('GetFigureHandleField', hFig, 'MeasureThreshold'), Refresh);
    
    % Update region datapair if possible
    RegionFunction = getappdata(hFig, 'RegionFunction');
    if isempty(RegionFunction)
        RegionFunction = getappdata(hFig, 'DefaultRegionFunction');
    end
    SetRegionFunction(hFig, RegionFunction);

    HierarchyNodeIsVisible = getappdata(hFig, 'HierarchyNodeIsVisible');
    SetHierarchyNodeIsVisible(hFig, HierarchyNodeIsVisible);
    
    RenderInQuad = getappdata(hFig, 'RenderInQuad');
    OGL.renderInQuad(RenderInQuad);
    
    RefreshTitle(hFig);
    
    % Set background color
    SetBackgroundColor(hFig, GetBackgroundColor(hFig));
    % Update colormap
    UpdateColormap(hFig);
    % Redraw selected nodes
    SetSelectedNodes(hFig, selNodes, 1, 1);
    % Update panel
    panel_display('UpdatePanel', hFig);
    % 
    bst_progress('stop');
end

function SetDisplayNodeFilter(hFig, NodeIndex, IsVisible)
    % Get OpenGL handle
	OGL = getappdata(hFig, 'OpenGLDisplay');
    % Update variable
    if (IsVisible == 0)
        IsVisible = -1;
    end
    DisplayNode = bst_figures('GetFigureHandleField', hFig, 'DisplayNode');
    DisplayNode(NodeIndex) = DisplayNode(NodeIndex) + IsVisible;
    bst_figures('SetFigureHandleField', hFig, 'DisplayNode', DisplayNode);
    % Update java
    if (IsVisible <= 0)       
        Index = find(DisplayNode <= 0);
    else
        Index = find(DisplayNode > 0);
    end
    for i=1:size(Index,1)
        OGL.setNodeVisibility(Index(i) - 1, DisplayNode(Index(i)) > 0);
    end
    % Redraw
    OGL.repaint();
end

function HideLonelyRegionNode(hFig)
    %
    DisplayInRegion = getappdata(hFig, 'DisplayInRegion');
    if (DisplayInRegion)
        % Get Nodes
        AgregatingNodes = bst_figures('GetFigureHandleField', hFig, 'AgregatingNodes');
%        MeasureNodes = bst_figures('GetFigureHandleField', hFig, 'MeasureNodes');
        ChannelData = bst_figures('GetFigureHandleField', hFig, 'ChannelData');
        for i=1:size(AgregatingNodes,2)
            % Hide nodes with only one measure node
            Search = find(ChannelData(i,:) ~= 0, 1, 'first');
            if (~isempty(Search))
%             Sum = sum(ismember(ChannelData(MeasureNodes,Search), ChannelData(i,Search)));
%             if ~isempty(Sum)
%                 if (Sum <= 1)
%                     OGL.setNodeVisibility(i - 1, 0);
%                    % DisplayNode(i) = 0;
%                 end
%             end
                % Hide nodes with only one region node
                Member = ismember(ChannelData(AgregatingNodes,Search), ChannelData(i,Search));
                SameHemisphere = ismember(ChannelData(AgregatingNodes,3), ChannelData(i,3));
                Member = Member & SameHemisphere;
                Member(i) = 0;
                % If there's only one sub-region, hide it
                if (sum(Member)== 1)
                    SetDisplayNodeFilter(hFig, find(Member), 0);
                end
            end
        end
    end
end


%% ===== FILTERS =====
function SetMeasureDisplayFilter(hFig, NewMeasureDisplayMask, Refresh)
    % Refresh by default
    if (nargin < 3)
        Refresh = 1;
    end
    % Get selected rows
    selNodes = bst_figures('GetFigureHandleField', hFig, 'SelectedNodes');
    if (Refresh)
        % Remove previous links
        SetSelectedNodes(hFig, selNodes, 0, 0);
    end
    % Update variable
    bst_figures('SetFigureHandleField', hFig, 'MeasureDisplayMask', NewMeasureDisplayMask);
    if (Refresh)
        % Redraw selected nodes
        SetSelectedNodes(hFig, selNodes, 1, Refresh);
    end
end

function SetMeasureThreshold(hFig, NewMeasureThreshold, Refresh)
    % Refresh by default
    if (nargin < 3)
        Refresh = 1;
    end
    % Get selected rows
    selNodes = bst_figures('GetFigureHandleField', hFig, 'SelectedNodes');
    % Get Datapair
    DataPair = bst_figures('GetFigureHandleField', hFig, 'DataPair');
    % Get threshold option
    ThresholdAbsoluteValue = getappdata(hFig, 'ThresholdAbsoluteValue');
    if (ThresholdAbsoluteValue)
        DataPair(:,3) = abs(DataPair(:,3));
    end
    % Compute new mask
    MeasureThresholdMask = DataPair(:,3) >= NewMeasureThreshold;
    if (Refresh)
        % Remove previous links
        SetSelectedNodes(hFig, selNodes, 0, 0);
    end
    % Update variable
    bst_figures('SetFigureHandleField', hFig, 'MeasureThreshold', NewMeasureThreshold);
    bst_figures('SetFigureHandleField', hFig, 'MeasureThresholdMask', MeasureThresholdMask);
    if (Refresh)
        % Redraw selected nodes
        SetSelectedNodes(hFig, selNodes, 1, Refresh);
    end
end

function SetMeasureAnatomicalFilterTo(hFig, NewMeasureAnatomicalFilter, Refresh)
    % Refresh by default
    if (nargin < 3)
        Refresh = 1;
    end
    DataPair = bst_figures('GetFigureHandleField', hFig, 'DataPair');
    % Get selected rows
    selNodes = bst_figures('GetFigureHandleField', hFig, 'SelectedNodes');
    % Compute new mask
    NewMeasureAnatomicalMask = GetMeasureAnatomicalMask(hFig, DataPair, NewMeasureAnatomicalFilter);
    if (Refresh)
        % Remove previous links
        SetSelectedNodes(hFig, selNodes, 0, 0);
    end
    % Update variable
    bst_figures('SetFigureHandleField', hFig, 'MeasureAnatomicalFilter', NewMeasureAnatomicalFilter);
    bst_figures('SetFigureHandleField', hFig, 'MeasureAnatomicalMask', NewMeasureAnatomicalMask);
    if (Refresh)
        % Redraw selected nodes
        SetSelectedNodes(hFig, selNodes, 1, Refresh);
    end
end

function SetMeasureFiberFilterTo(hFig, NewMeasureFiberFilter, Refresh)
    % Refresh by default
    if (nargin < 3)
        Refresh = 1;
    end
    DataPair = bst_figures('GetFigureHandleField', hFig, 'DataPair');
    % Get selected rows
    selNodes = bst_figures('GetFigureHandleField', hFig, 'SelectedNodes');
    % Compute new mask
    NewMeasureFiberMask = GetMeasureFiberMask(hFig, DataPair, NewMeasureFiberFilter);
    if (Refresh)
        % Remove previous links
        SetSelectedNodes(hFig, selNodes, 0, 0);
    end
    % Update variable
    bst_figures('SetFigureHandleField', hFig, 'MeasureFiberFilter', NewMeasureFiberFilter);
    bst_figures('SetFigureHandleField', hFig, 'MeasureFiberMask', NewMeasureFiberMask);
    if (Refresh)
        % Redraw selected nodes
        SetSelectedNodes(hFig, selNodes, 1, Refresh);
    end
end

function MeasureAnatomicalMask = GetMeasureAnatomicalMask(hFig, DataPair, MeasureAnatomicalFilter)
    ChannelData = bst_figures('GetFigureHandleField', hFig, 'ChannelData');
    MeasureAnatomicalMask = zeros(size(DataPair,1),1);
    switch (MeasureAnatomicalFilter)
        case 0 % 0 - All
            MeasureAnatomicalMask(:) = 1;
        case 1 % 1 - Between Hemisphere
            MeasureAnatomicalMask = ChannelData(DataPair(:,1),3) ~= ChannelData(DataPair(:,2),3);
        case 2 % 2 - Between Lobe == Not Same Region
            MeasureAnatomicalMask = ChannelData(DataPair(:,1),1) ~= ChannelData(DataPair(:,2),1);
    end
end

function MeasureFiberMask = GetMeasureFiberMask(hFig, DataPair, MeasureFiberFilter)
    global GlobalData;
    ChannelData = bst_figures('GetFigureHandleField', hFig, 'ChannelData');
    MeasureFiberMask = zeros(size(DataPair,1),1);
    
    % Only filter if there are fibers shown
    plotFibers = getappdata(hFig, 'plotFibers');
    hFigFib = bst_figures('GetFigureHandleField', hFig, 'hFigFib');
    if MeasureFiberFilter == 0 || isempty(plotFibers) || ~plotFibers || ~ishandle(hFigFib)
        MeasureFiberMask(:) = 1;
        return;
    end
    
    %% Get fibers information
    TfInfo = getappdata(hFig, 'Timefreq');
    TessInfo = getappdata(hFigFib, 'Surface');
    iTess = find(ismember({TessInfo.Name}, 'Fibers'));
    [FibMat, iFib] = bst_memory('LoadFibers', TessInfo(iTess).SurfaceFile);
    
    %% If fibers not yet assigned to atlas, do so now
    if isempty(FibMat.Scouts(1).ConnectFile) || ~ismember(TfInfo.FileName, {FibMat.Scouts.ConnectFile})
        ScoutNames     = bst_figures('GetFigureHandleField', hFig, 'RowNames');
        ScoutCentroids = bst_figures('GetFigureHandleField', hFig, 'RowLocs');
        FibMat = fibers_helper('AssignToScouts', FibMat, TfInfo.FileName, ScoutCentroids);
        % Save in memory to avoid recomputing
        GlobalData.Fibers(iFib) = FibMat;
    end
    
    % Get scout assignment
    iFile = find(ismember(TfInfo.FileName, {FibMat.Scouts.ConnectFile}));
    assign = FibMat.Scouts(iFile).Assignment;
    AgregatingNodes = bst_figures('GetFigureHandleField', hFig, 'AgregatingNodes');
    nAgregatingNode = size(AgregatingNodes, 2);
    DataPair = DataPair(:,1:2) - nAgregatingNode;
    
    %% Find nodes that have fiber assignments
    assignBsx = reshape(assign', [1 size(assign')]);
    % Get the matches for the pairs and for the flipped pairs
    indices =  all(bsxfun(@eq, DataPair, assignBsx), 2) | all( bsxfun(@eq, DataPair, flip(assignBsx,2)), 2);
    % Find the indices of the rows with a match
    MeasureFiberMask = any(indices,3);
        
    if MeasureFiberFilter == 2 % Anatomically inaccurate
        MeasureFiberMask = ~MeasureFiberMask;
    end
end

function SetMeasureDistanceFilter(hFig, NewMeasureMinDistanceFilter, NewMeasureMaxDistanceFilter, Refresh)
    % Refresh by default
    if (nargin < 4)
        Refresh = 1;
    end
    % Get selected rows
    selNodes = bst_figures('GetFigureHandleField', hFig, 'SelectedNodes');
    % Get distance measures
    MeasureDistance = bst_figures('GetFigureHandleField', hFig, 'MeasureDistance');
    if isempty(MeasureDistance)
        % Everything
        MeasureDistanceMask = ones(size(MeasureDistance));
    else
        % Compute intersection
        MeasureDistanceMask = (MeasureDistance <= NewMeasureMaxDistanceFilter) & (MeasureDistance(:) >= NewMeasureMinDistanceFilter);
    end
    if (Refresh)
        % Remove previous links
        SetSelectedNodes(hFig, selNodes, 0, 0);
    end
    % Update variable
    bst_figures('SetFigureHandleField', hFig, 'MeasureMinDistanceFilter', NewMeasureMinDistanceFilter);
    bst_figures('SetFigureHandleField', hFig, 'MeasureMaxDistanceFilter', NewMeasureMaxDistanceFilter);
    bst_figures('SetFigureHandleField', hFig, 'MeasureDistanceMask', MeasureDistanceMask);
    if (Refresh)
        % Redraw selected nodes
        SetSelectedNodes(hFig, selNodes, 1, Refresh);
    end
end

function mMeanDataPair = ComputeMeanMeasureMatrix(hFig, mDataPair)
    Levels = bst_figures('GetFigureHandleField', hFig, 'Levels');
    Regions = Levels{2};
    NumberOfNode = size(Regions,1);
    mMeanDataPair = zeros(NumberOfNode*NumberOfNode,3);
    %
    for i=1:NumberOfNode
        OutNode = getAgregatedNodesFrom(hFig, Regions(i));
        for y=1:NumberOfNode
            if (i ~= y)
                InNode = getAgregatedNodesFrom(hFig, Regions(y));
                Index = ismember(mDataPair(:,1),OutNode) & ismember(mDataPair(:,2),InNode);
                nValue = sum(Index);
                if (nValue > 0)
                    Mean = sum(mDataPair(Index,3)) / sum(Index);
                    mMeanDataPair(NumberOfNode * (i - 1) + y, :) = [Regions(i) Regions(y) Mean];
                end
            end
        end
    end
    mMeanDataPair(mMeanDataPair(:,3) == 0,:) = [];
end

function mMaxDataPair = ComputeMaxMeasureMatrix(hFig, mDataPair)
    Levels = bst_figures('GetFigureHandleField', hFig, 'Levels');
    Regions = Levels{2};
    NumberOfRegions = size(Regions,1);
    mMaxDataPair = zeros(NumberOfRegions*NumberOfRegions,3);
    
    % Precomputing this saves on processing time
    NodesFromRegions = cell(NumberOfRegions,1);
    for i=1:NumberOfRegions
        NodesFromRegions{i} = getAgregatedNodesFrom(hFig, Regions(i));
    end
    
    for i=1:NumberOfRegions
        for y=1:NumberOfRegions
            if (i ~= y)
                % Retrieve index
                Index = ismember(mDataPair(:,1),NodesFromRegions{i}) & ismember(mDataPair(:,2),NodesFromRegions{y});
                % If there is values
                if (sum(Index) > 0)
                    Max = max(mDataPair(Index,3));
                    mMaxDataPair(NumberOfRegions * (i - 1) + y, :) = [Regions(i) Regions(y) Max];
                end
            end
        end
    end
    % Eliminate empty data
    mMaxDataPair(mMaxDataPair(:,3) == 0,:) = [];
end


function MeasureDistance = ComputeEuclideanMeasureDistance(hFig, aDataPair, mLoc)
    % Correct offset
    nAgregatingNodes = size(bst_figures('GetFigureHandleField', hFig, 'AgregatingNodes'),2);
    aDataPair(:,1:2) = aDataPair(:,1:2) - nAgregatingNodes;
    % Compute Euclidean distance
    Minus = bsxfun(@minus, mLoc(aDataPair(:,1),:), mLoc(aDataPair(:,2),:));
    MeasureDistance = sqrt(sum(Minus(:,:) .^ 2,2));
    % Convert measure according to factor
    MeasureDistanceFactor = getappdata(hFig, 'MeasureDistanceFactor');
    if isempty(MeasureDistanceFactor)
        MeasureDistanceFactor = 1;
    end
    MeasureDistance = MeasureDistance * MeasureDistanceFactor;
end


%% ===== GET DATA MASK =====
function [DataPair, DataMask] = GetPairs(hFig)
    % Get figure data
    DataPair = bst_figures('GetFigureHandleField', hFig, 'DataPair');
    % Thresholded list
    if (nargout >= 2)
        MeasureDisplayMask = bst_figures('GetFigureHandleField', hFig, 'MeasureDisplayMask');
        MeasureDistanceMask = bst_figures('GetFigureHandleField', hFig, 'MeasureDistanceMask');
        MeasureAnatomicalMask = bst_figures('GetFigureHandleField', hFig, 'MeasureAnatomicalMask');
        MeasureFiberMask = bst_figures('GetFigureHandleField', hFig, 'MeasureFiberMask');
        MeasureThresholdMask = bst_figures('GetFigureHandleField', hFig, 'MeasureThresholdMask');
        
        DataMask = ones(size(DataPair,1),1);
        % Display specific filter
        if ~isempty(MeasureDisplayMask) && isequal(size(DataMask), size(MeasureDisplayMask))
            DataMask =  DataMask == 1 & MeasureDisplayMask == 1;
        end
        % Distance filter
        if ~isempty(MeasureDistanceMask) && isequal(size(DataMask), size(MeasureDistanceMask))
            DataMask =  DataMask == 1 & MeasureDistanceMask == 1;
        end
        % Anatomical filter
        if ~isempty(MeasureAnatomicalMask) && isequal(size(DataMask), size(MeasureAnatomicalMask))
            DataMask =  DataMask == 1 & MeasureAnatomicalMask == 1;
        end
        % Fiber filter
        if ~isempty(MeasureFiberMask) && isequal(size(DataMask), size(MeasureFiberMask))
            DataMask = DataMask == 1 & MeasureFiberMask == 1;
        end
        % Intensity Threshold filter
        if ~isempty(MeasureThresholdMask) && isequal(size(DataMask), size(MeasureThresholdMask))
            DataMask =  DataMask == 1 & MeasureThresholdMask == 1;
        end
    end
end

function [RegionDataPair, RegionDataMask] = GetRegionPairs(hFig)
    % Get figure data
    RegionDataPair = bst_figures('GetFigureHandleField', hFig, 'RegionDataPair');
    RegionDataMask = ones(size(RegionDataPair,1),1);
    if (size(RegionDataPair,1) > 0)
        % Get colormap
        sColormap = bst_colormaps('GetColormap', hFig);
        % Get threshold option
        ThresholdAbsoluteValue = getappdata(hFig, 'ThresholdAbsoluteValue');
        if (ThresholdAbsoluteValue) || sColormap.isAbsoluteValues
            RegionDataPair(:,3) = abs(RegionDataPair(:,3));
        end
        % Get threshold
        MeasureThreshold = bst_figures('GetFigureHandleField', hFig, 'MeasureThreshold');
        if (~isempty(MeasureThreshold))
            % Compute new mask
            MeasureThresholdMask = RegionDataPair(:,3) >= MeasureThreshold;
            RegionDataMask = RegionDataMask & MeasureThresholdMask;
        end
        % Get anatomical filter
        MeasureAnatomicalFilter = bst_figures('GetFigureHandleField', hFig, 'MeasureAnatomicalFilter');
        if (~isempty(MeasureAnatomicalFilter))
            % Compute new mask
            NewMeasureAnatomicalMask = GetMeasureAnatomicalMask(hFig, RegionDataPair, MeasureAnatomicalFilter);
            RegionDataMask = RegionDataMask & NewMeasureAnatomicalMask;
        end
        % Get fiber filter
        MeasureFiberFilter = bst_figures('GetFigureHandleField', hFig, 'MeasureFiberFilter');
        if (~isempty(MeasureFiberFilter))
            % Compute new mask
            NewMeasureFiberFilterMask = GetMeasureFiberMask(hFig, RegionDataPair, MeasureFiberFilter);
            RegionDataMask = RegionDataMask & NewMeasureFiberFilterMask;
        end
    end
end


%% ===== UPDATE COLORMAP =====
function UpdateColormap(hFig)
    % Get selected frequencies and rows
    TfInfo = getappdata(hFig, 'Timefreq');
    if isempty(TfInfo)
        return
    end
    % Get data description
    iDS = bst_memory('GetDataSetTimefreq', TfInfo.FileName);
    if isempty(iDS)
        return
    end
    % Get colormap
    sColormap = bst_colormaps('GetColormap', hFig);
    % Get DataPair
    [DataPair, DataMask] = GetPairs(hFig);    
    if sColormap.isAbsoluteValues
        DataPair(:,3) = abs(DataPair(:,3));
    end
    % Get figure method
    Method = getappdata(hFig, 'Method');
    % Get maximum values
    DataMinMax = bst_figures('GetFigureHandleField', hFig, 'DataMinMax');
    % Get threshold min/max values
    ThresholdMinMax = bst_figures('GetFigureHandleField', hFig, 'ThresholdMinMax');
    % === COLORMAP LIMITS ===
    % Units type
    if ismember(Method, {'granger', 'spgranger', 'plv', 'plvt', 'aec'})
        UnitsType = 'timefreq';
    else
        UnitsType = 'connect';
    end
    % Get colormap bounds
    if strcmpi(sColormap.MaxMode, 'custom')
        CLim = [sColormap.MinValue, sColormap.MaxValue];
    elseif ismember(Method, {'granger', 'spgranger', 'plv', 'plvt', 'aec', 'cohere', 'pte','henv'})
        CLim = [DataMinMax(1) DataMinMax(2)];
    elseif ismember(Method, {'corr'})
        if strcmpi(sColormap.MaxMode, 'local')
            CLim = ThresholdMinMax;
            if sColormap.isAbsoluteValues
                CLim = abs(CLim);            
            end
        else
            if sColormap.isAbsoluteValues
                CLim = [0, 1];
            else
                CLim = [-1, 1];
            end
        end
    end
    setappdata(hFig, 'CLim', CLim);
    
    % === SET COLORMAP ===
    % Update colorbar font size
    hColorbar = findobj(hFig, '-depth', 1, 'Tag', 'Colorbar');
    if ~isempty(hColorbar)
        set(hColorbar, 'FontSize', bst_get('FigFont'), 'FontUnits', 'points');
    end
    % Get figure colormap
    ColormapInfo = getappdata(hFig, 'Colormap');
    sColormap = bst_colormaps('GetColormap', ColormapInfo.Type);
    % Set figure colormap
    set(hFig, 'Colormap', sColormap.CMap);
    % Create/Delete colorbar
    bst_colormaps('SetColorbarVisible', hFig, sColormap.DisplayColorbar);
    % Display only one colorbar (preferentially the results colorbar)
    bst_colormaps('ConfigureColorbar', hFig, ColormapInfo.Type, UnitsType, ColormapInfo.DisplayUnits);
    
    % === UPDATE DISPLAY ===
    CMap = sColormap.CMap;
    OGL = getappdata(hFig, 'OpenGLDisplay');
    is3DDisplay = getappdata(hFig, 'is3DDisplay');
    
    if (sum(DataMask) > 0)
        % Normalize DataPair for Offset
        Max = max(DataPair(:,3));
        Min = min(abs(DataPair(:,3)));
        Diff = (Max - Min);
        if (Diff == 0)
            Offset = DataPair(DataMask,3);
        else
            Offset = (abs(DataPair(DataMask,3)) - Min) ./ (Max - Min);
        end
        % Interpolate
        [StartColor, EndColor] = InterpolateColorMap(hFig, DataPair(DataMask,:), CMap, CLim);
        % Update color
        OGL.setMeasureLinkColorGradient( ...
            find(DataMask) - 1, ...
            StartColor(:,1), StartColor(:,2), StartColor(:,3), ...
            EndColor(:,1), EndColor(:,2), EndColor(:,3));
        if (~is3DDisplay)
            % Offset is always in absolute
            OGL.setMeasureLinkOffset(find(DataMask) - 1, Offset(:).^2 * 2);
        end
        
        % === UPDATE FIBER COLORS ===
        plotFibers = getappdata(hFig, 'plotFibers');
        if plotFibers
            % Get scout information
            AgregatingNodes = bst_figures('GetFigureHandleField', hFig, 'AgregatingNodes');
            nAgregatingNode = size(AgregatingNodes, 2);
            iData = find(DataMask == 1) - 1;
            iScouts = DataPair(iData + 1, 1:2) - nAgregatingNode;
            figure_3d('SelectFiberScouts', hFig, iScouts, StartColor, 1);
        end
    end
    
    [RegionDataPair, RegionDataMask] = GetRegionPairs(hFig);
    if (sum(RegionDataMask) > 0)
        % Normalize DataPair for Offset
        Max = max(RegionDataPair(:,3));
        Min = min(RegionDataPair(:,3));
        Diff = (Max - Min);
        if (Diff == 0)
            Offset = RegionDataPair(RegionDataMask,3);
        else
            Offset = (abs(RegionDataPair(RegionDataMask,3)) - Min) ./ (Max - Min);
        end
        % Normalize within the colormap range 
        [StartColor, EndColor] = InterpolateColorMap(hFig, RegionDataPair(RegionDataMask,:), CMap, CLim);
        % Update display
        OGL.setRegionLinkColorGradient( ...
            find(RegionDataMask) - 1, ...
            StartColor(:,1), StartColor(:,2), StartColor(:,3), ...
            EndColor(:,1), EndColor(:,2), EndColor(:,3));
        if (~is3DDisplay)
            % Offset is always in absolute
            OGL.setRegionLinkOffset(find(RegionDataMask) - 1, Offset(:).^2 * 2);
        end
    end
    
    OGL.repaint();
end


function [StartColor EndColor] = InterpolateColorMap(hFig, DataPair, ColorMap, Limit)
    IsBinaryData = getappdata(hFig, 'IsBinaryData');
    if (~isempty(IsBinaryData) && IsBinaryData == 1)
        % Retrieve ColorMap extremeties
        nDataPair = size(DataPair,1);
        % 
        StartColor(:,:) = repmat(ColorMap(1,:), nDataPair, 1);
        EndColor(:,:) = repmat(ColorMap(end,:), nDataPair, 1);
        % Bidirectional data ?
        DisplayBidirectionalMeasure = getappdata(hFig, 'DisplayBidirectionalMeasure');
        if (DisplayBidirectionalMeasure)
            % Get Bidirectional data
            OutIndex = ismember(DataPair(:,1:2),DataPair(:,2:-1:1),'rows');
            InIndex = ismember(DataPair(:,1:2),DataPair(:,2:-1:1),'rows');
            % Bidirectional links in total Green
            StartColor(OutIndex | InIndex,1) = 0;
            StartColor(OutIndex | InIndex,2) = 0.7;
            StartColor(OutIndex | InIndex,3) = 0;
            EndColor(OutIndex | InIndex,:) = StartColor(OutIndex | InIndex,:);
        end
    else
        % Normalize and interpolate
        a = (DataPair(:,3)' - Limit(1)) / (Limit(2) - Limit(1));
        b = linspace(0,1,size(ColorMap,1));
        m = size(a,2);
        n = size(b,2);
        [tmp,p] = sort([a,b]);
        q = 1:m+n; q(p) = q;
        t = cumsum(p>m);
        r = 1:n; r(t(q(m+1:m+n))) = r;
        s = t(q(1:m));
        id = r(max(s,1));
        iu = r(min(s+1,n));
        [tmp,it] = min([abs(a-b(id));abs(b(iu)-a)]);
        StartColor = ColorMap(id+(it-1).*(iu-id),:);
        EndColor = ColorMap(id+(it-1).*(iu-id),:);
    end
end


%% ===== UPDATE CAMERA =====
function UpdateCamera(hFig)
    Pos = getappdata(hFig, 'CameraPosition');
    CameraTarget = getappdata(hFig, 'CameraTarget');
    Zoom = getappdata(hFig, 'CameraZoom');
    OGL = getappdata(hFig, 'OpenGLDisplay');
    OGL.zoom(Zoom);
    OGL.lookAt(Pos(1), Pos(2), Pos(3), CameraTarget(1), CameraTarget(2), CameraTarget(3), 0, 1, 0);
    OGL.repaint();
end

%% ===== ZOOM CAMERA =====
function ZoomCamera(hFig, inc)
    Zoom = getappdata(hFig, 'CameraZoom');
    Zoom = Zoom + (inc * 0.01);
    setappdata(hFig, 'CameraZoom', Zoom);
	UpdateCamera(hFig);
end

%% ===== ROTATE CAMERA =====
function RotateCameraAlongAxis(hFig, theta, phi)
	Pos = getappdata(hFig, 'CameraPosition');
    Target = getappdata(hFig, 'CameraTarget');
    Zoom = getappdata(hFig, 'CameraZoom');
    Pitch = getappdata(hFig, 'CamPitch');
    Yaw = getappdata(hFig, 'CamYaw');
    
    Pitch = Pitch + theta;
    Yaw = Yaw + phi;
    if (Pitch > (0.5 * 3.1415))
        Pitch = (0.5 * 3.1415);
    elseif (Pitch < -(0.5 * 3.1415))
        Pitch = -(0.5 * 3.1415);
    end
    
    % Projection 
    Pos(1) = cos(Yaw) * cos(Pitch);
	Pos(2) = sin(Yaw) * cos(Pitch);
    Pos(3) = sin(Pitch);
    Pos = Target + Zoom * Pos;
    
    setappdata(hFig, 'CamPitch', Pitch);
    setappdata(hFig, 'CamYaw', Yaw);
    setappdata(hFig, 'CameraPosition', Pos);

	UpdateCamera(hFig);
end

function MoveCamera(hFig, Translation)
    CameraPosition = getappdata(hFig, 'CameraPosition') + Translation;
    CameraTarget = getappdata(hFig, 'CameraTarget') + Translation;
    setappdata(hFig, 'CameraPosition', CameraPosition);
    setappdata(hFig, 'CameraTarget', CameraTarget);
    UpdateCamera(hFig);
end


%% ===========================================================================
%  ===== NODE DISPLAY AND SELECTION ==========================================
%  ===========================================================================

%% ===== SET SELECTED NODES =====
% USAGE:  SetSelectedNodes(hFig, iNodes=[], isSelected=1, isRedraw=1) : Add or remove nodes from the current selection
%         If node selection is empty: select/unselect all the nodes
function SetSelectedNodes(hFig, iNodes, isSelected, isRedraw)
    % Parse inputs
    if (nargin < 2) || isempty(iNodes)
        % Get all the nodes
        NumberOfNodes = bst_figures('GetFigureHandleField', hFig, 'NumberOfNodes');
        iNodes = 1:NumberOfNodes;
    end
    if (nargin < 3) || isempty(isSelected)
        isSelected = 1;
    end
    if (nargin < 4) || isempty(isRedraw)
        isRedraw = 1;
    end
    % Get list of selected channels
    selNodes = bst_figures('GetFigureHandleField', hFig, 'SelectedNodes');
    % If nodes are not specified
    if (nargin < 3)
        iNodes = selNodes;
        isSelected = 1;
    end
    % Define node properties
    if isSelected
        SelectedNodeColor = [0.95, 0.0, 0.0];
        selNodes = union(selNodes, iNodes);
    else
        SelectedNodeColor = getappdata(hFig, 'BgColor');
        selNodes = setdiff(selNodes, iNodes);
    end
    % Update list of selected channels
    bst_figures('SetFigureHandleField', hFig, 'SelectedNodes', selNodes);
    
    % Get OpenGL handle
    OGL = getappdata(hFig, 'OpenGLDisplay');
    
    % Agregating nodes are not visually selected
    AgregatingNodes = bst_figures('GetFigureHandleField', hFig, 'AgregatingNodes');
    NoColorNodes = ismember(iNodes,AgregatingNodes);
    if (sum(~NoColorNodes) > 0)
        if isSelected
            OGL.setNodeOuterCircleVisibility(iNodes(~NoColorNodes) - 1, 1);
            OGL.setNodeOuterColor(iNodes(~NoColorNodes) - 1, SelectedNodeColor(1), SelectedNodeColor(2), SelectedNodeColor(3));
        else
            OGL.setNodeOuterCircleVisibility(iNodes(~NoColorNodes) - 1, 0);
        end
    end
    RefreshTextDisplay(hFig, isRedraw);
    
    % Get data
    MeasureLinksIsVisible = getappdata(hFig, 'MeasureLinksIsVisible');
    if (MeasureLinksIsVisible)
        [DataToFilter, DataMask] = GetPairs(hFig);
    else
        [DataToFilter, DataMask] = GetRegionPairs(hFig);
    end
    
    % ===== Selection based data filtering =====
    % Direction mask
    IsDirectionalData = getappdata(hFig, 'IsDirectionalData');
    if (~isempty(IsDirectionalData) && IsDirectionalData == 1)
        NodeDirectionMask = zeros(size(DataMask,1),1);
        DisplayOutwardMeasure = getappdata(hFig, 'DisplayOutwardMeasure');
        DisplayInwardMeasure = getappdata(hFig, 'DisplayInwardMeasure');
        DisplayBidirectionalMeasure = getappdata(hFig, 'DisplayBidirectionalMeasure');
        if (DisplayOutwardMeasure)
            OutMask = ismember(DataToFilter(:,1), iNodes);
            NodeDirectionMask = NodeDirectionMask | OutMask;
        end
        if (DisplayInwardMeasure)
            InMask = ismember(DataToFilter(:,2), iNodes);
            NodeDirectionMask = NodeDirectionMask | InMask;
        end
        if (DisplayBidirectionalMeasure)
            % Selection
            SelectedNodeMask = ismember(DataToFilter(:,1), iNodes) ...
                             | ismember(DataToFilter(:,2), iNodes);
            VisibleIndex = find(DataMask == 1);
            % Get Bidirectional data
            BiIndex = ismember(DataToFilter(DataMask,1:2),DataToFilter(DataMask,2:-1:1),'rows');
            NodeDirectionMask(VisibleIndex(BiIndex)) = 1;
            NodeDirectionMask = NodeDirectionMask & SelectedNodeMask;
        end
        UserSpecifiedBinaryData = getappdata(hFig, 'UserSpecifiedBinaryData');
        if (isempty(UserSpecifiedBinaryData) || UserSpecifiedBinaryData == 0)
            % Update binary status
            RefreshBinaryStatus(hFig);                
        end
        DataMask = DataMask == 1 & NodeDirectionMask == 1;
    else
        % Selection filtering
        SelectedNodeMask = ismember(DataToFilter(:,1), iNodes) ...
                         | ismember(DataToFilter(:,2), iNodes);
        DataMask = DataMask & SelectedNodeMask;
    end
    
    % Links are from valid node only
    ValidNode = find(bst_figures('GetFigureHandleField', hFig, 'ValidNode') > 0);
    ValidDataForDisplay = sum(ismember(DataToFilter(:,1:2), ValidNode),2);
    DataMask = DataMask == 1 & ValidDataForDisplay == 2;

    iData = find(DataMask == 1) - 1;
    if (~isempty(iData))
        % Update visibility
        if (MeasureLinksIsVisible)
            OGL.setMeasureLinkVisibility(iData, isSelected);
        else
            OGL.setRegionLinkVisibility(iData, isSelected);
        end
    end
    
    % These functions sets global Boolean value in Java that allows
    % or disallows the drawing of these measures, which makes it
    % really fast to switch between the two mode
    OGL.setMeasureIsVisible(MeasureLinksIsVisible);
    OGL.setRegionIsVisible(~MeasureLinksIsVisible);
    
    % Redraw OpenGL
    if isRedraw
        OGL.repaint();
    end
    
    % Propagate selection to other figures
    NodeNames = bst_figures('GetFigureHandleField', hFig, 'Names');
    if ~isempty(selNodes) && (length(selNodes) < length(NodeNames))
        % Select rows
        bst_figures('SetSelectedRows', NodeNames(selNodes));
        % Select scouts
        panel_scout('SetSelectedScoutLabels', NodeNames(selNodes));
    else
        bst_figures('SetSelectedRows', []);
        panel_scout('SetSelectedScoutLabels', []);
    end
    if isSelected
        % If we're plotting fibers, send pairs of scouts that are to be displayed
        plotFibers = getappdata(hFig, 'plotFibers');
        if plotFibers
            % Get scout information
            nAgregatingNode = size(AgregatingNodes, 2);
            iScouts = DataToFilter(iData + 1, 1:2) - nAgregatingNode;
            
            % Get color information
            CMap = get(hFig, 'Colormap');
            CLim = getappdata(hFig, 'CLim');
            if isempty(CLim)
                CLim = [0, 1];
            end
            Color = InterpolateColorMap(hFig, abs(DataToFilter(DataMask,:)), CMap, CLim);
            
            % Send to 3D fibers
            if ~isempty(iScouts)
                figure_3d('SelectFiberScouts', hFig, iScouts, Color);
            end
        end
    end
end


%%
function SetHierarchyNodeIsVisible(hFig, isVisible)
    HierarchyNodeIsVisible = getappdata(hFig, 'HierarchyNodeIsVisible');
    if (HierarchyNodeIsVisible ~= isVisible)
        AgregatingNodes = bst_figures('GetFigureHandleField', hFig, 'AgregatingNodes');
        if (isVisible)
            %ValidNode = find(bst_figures('GetFigureHandleField', hFig, 'ValidNode'));
            %AgregatingNodes(ismember(AgregatingNodes,ValidNode)) = [];
        end
        SetDisplayNodeFilter(hFig, AgregatingNodes, isVisible);
        % Update variable
        setappdata(hFig, 'HierarchyNodeIsVisible', isVisible);
    end
    % Make sure they are invisible
    HideLonelyRegionNode(hFig);
end


%% 
function RegionDataPair = SetRegionFunction(hFig, RegionFunction)
    % Does data has regions to cluster ?
    DisplayInCircle = getappdata(hFig, 'DisplayInCircle');
    if (isempty(DisplayInCircle) || DisplayInCircle == 0)    
        % Get data
        DataPair = GetPairs(hFig);
        % Which function
        switch (RegionFunction)
            case 'mean'
                RegionDataPair = ComputeMeanMeasureMatrix(hFig, DataPair);
            case 'max'
                RegionDataPair = ComputeMaxMeasureMatrix(hFig, DataPair);
            otherwise
                disp('The region function specified is not yet supported. Default to mean.');
                RegionFunction = 'mean';
                RegionDataPair = ComputeMeanMeasureMatrix(hFig, M);
        end
        %
        OGL = getappdata(hFig, 'OpenGLDisplay');
        % Clear
        OGL.clearRegionLinks();
        %
        Paths = bst_figures('GetFigureHandleField', hFig, 'NodePaths');
        Vertices = bst_figures('GetFigureHandleField', hFig, 'Vertices');
        % Build path for new datapair
        MeasureLinks = BuildRegionPath(hFig, Paths, RegionDataPair);
        % Compute spline
        aSplines = ComputeSpline(hFig, MeasureLinks, Vertices);
        if (~isempty(aSplines))
            % Add on Java side
            OGL.addPrecomputedHierarchyLink(aSplines); 
            % Get link size
            LinkSize = 6;
            % Width
            OGL.setRegionLinkWidth(0:(size(RegionDataPair,1) - 1), LinkSize);
        end
        % Update figure value
        bst_figures('SetFigureHandleField', hFig, 'RegionDataPair', RegionDataPair);
        setappdata(hFig, 'RegionFunction', RegionFunction);
        % Update color map
        UpdateColormap(hFig);
    end
end


function ToggleMeasureToRegionDisplay(hFig)
    DisplayInRegion = getappdata(hFig, 'DisplayInRegion');
    if (DisplayInRegion)
        % Toggle visibility
        MeasureLinksIsVisible = getappdata(hFig, 'MeasureLinksIsVisible');
        if (MeasureLinksIsVisible)
            MeasureLinksIsVisible = 0;
            RegionLinksIsVisible = 1;
        else
            MeasureLinksIsVisible = 1;
            RegionLinksIsVisible = 0;
        end
        % Get selected node
        selNodes = bst_figures('GetFigureHandleField', hFig, 'SelectedNodes');
        % Erase selected node
        SetSelectedNodes(hFig, selNodes, 0, 1);
        % Update visibility variable
        setappdata(hFig, 'MeasureLinksIsVisible', MeasureLinksIsVisible);
        setappdata(hFig, 'RegionLinksIsVisible', RegionLinksIsVisible);
        % Redraw selected nodes
        SetSelectedNodes(hFig, selNodes, 1, 1);
    else
        disp('Current data does not support region display.');
    end
end


%% ===== DISPLAY MODE =====
function SetTextDisplayMode(hFig, DisplayMode)
    % Get current display
    TextDisplayMode = getappdata(hFig, 'TextDisplayMode');
    % If not already set
    Index = ismember(TextDisplayMode, DisplayMode);
    if (sum(Index) == 0)
        % 'Selection' mode and the others are mutually exclusive
        if (DisplayMode == 3)
            TextDisplayMode = DisplayMode;
        else
            TextDisplayMode = [TextDisplayMode DisplayMode];
            % Remove 'Selection' mode if necessary
            SelectionModeIndex = ismember(TextDisplayMode,3);
            if (sum(SelectionModeIndex) >= 1)
                TextDisplayMode(SelectionModeIndex) = [];
            end
        end
    else
        TextDisplayMode(Index) = [];
    end
    % Add display mode
    setappdata(hFig, 'TextDisplayMode', TextDisplayMode);
    % Refresh
    RefreshTextDisplay(hFig);
end

function ToggleTextDisplayMode(hFig)
    % Get display mode
    TextDisplayMode = getappdata(hFig, 'TextDisplayMode');
    if (TextDisplayMode == 1)
        TextDisplayMode = [TextDisplayMode 2];
    else
        TextDisplayMode = 1;
    end
    % Add display mode
    setappdata(hFig, 'TextDisplayMode', TextDisplayMode);
    % Refresh
    RefreshTextDisplay(hFig);
end

%% ===== BLENDING =====
% Blending functions has defined by OpenGL
% GL_SRC_COLOR = 768;
% GL_ONE_MINUS_SRC_COLOR = 769;
% GL_SRC_ALPHA = 770;
% GL_ONE_MINUS_SRC_ALPHA = 771;
% GL_ONE_MINUS_DST_COLOR = 775;
% GL_ONE = 1;
% GL_ZERO = 0;

function SetBlendingMode(hFig, BlendingEnabled)
    % Update figure variable
    setappdata(hFig, 'BlendingEnabled', BlendingEnabled);
    % Update display
    OGL = getappdata(hFig,'OpenGLDisplay');
    % 
    if BlendingEnabled
        % Good looking additive blending
        OGL.setMeasureLinkBlendingFunction(770,1);
        % Blending only works nicely on black background
        SetBackgroundColor(hFig, [0 0 0], [1 1 1]);
        % AND with a minimum amount of transparency
        LinkTransparency = getappdata(hFig, 'LinkTransparency');
        if (LinkTransparency == 0)
            SetLinkTransparency(hFig, 0.02);
        end
    else
        % Translucent blending only
        OGL.setMeasureLinkBlendingFunction(770,771);
    end
    % Request redraw
    OGL.repaint();
end

function ToggleBlendingMode(hFig)
    BlendingEnabled = getappdata(hFig, 'BlendingEnabled');
    if isempty(BlendingEnabled)
        BlendingEnabled = 0;
    end
    SetBlendingMode(hFig, 1 - BlendingEnabled);
end

%% ===== LINK SIZE =====
function LinkSize = GetLinkSize(hFig)
    LinkSize = getappdata(hFig, 'LinkSize');
    if isempty(LinkSize)
        LinkSize = 1;
    end
end

function SetLinkSize(hFig, LinkSize)
    % Get display
    OGL = getappdata(hFig,'OpenGLDisplay');
    % Get # of data to update
    nLinks = size(bst_figures('GetFigureHandleField', hFig, 'DataPair'), 1);
    % Update size
    OGL.setMeasureLinkWidth(0:(nLinks - 1), LinkSize);
    OGL.repaint();
    % 
    setappdata(hFig, 'LinkSize', LinkSize);
end

%% ===== LINK TRANSPARENCY =====
function SetLinkTransparency(hFig, LinkTransparency)
    % Get display
    OGL = getappdata(hFig,'OpenGLDisplay');
    % 
    nLinks = size(bst_figures('GetFigureHandleField', hFig, 'DataPair'),1);
    % 
    OGL.setMeasureLinkTransparency(0:(nLinks - 1), LinkTransparency);
    OGL.repaint();
    % 
    setappdata(hFig, 'LinkTransparency', LinkTransparency);
end

%% ===== CORTEX TRANSPARENCY =====
function CortexTransparency = GetCortexTransparency(hFig)
    CortexTransparency = getappdata(hFig, 'CortexTransparency');
    if isempty(CortexTransparency)
        CortexTransparency = 0.025;
    end
end

function SetCortexTransparency(hFig, CortexTransparency)
    %
    is3DDisplay = getappdata(hFig, 'is3DDisplay');
    if is3DDisplay
        % Get display
        OGL = getappdata(hFig,'OpenGLDisplay');
        % 
        OGL.setPolygonTransparency(0, CortexTransparency);
        OGL.repaint();
    end
    % 
    setappdata(hFig, 'CortexTransparency', CortexTransparency);
end

%% ===== BACKGROUND COLOR =====
function SetBackgroundColor(hFig, BackgroundColor, TextColor)
    % Negate text color if necessary
    if nargin < 3
        TextColor = ~BackgroundColor;
    end
    % Get display
    OGL = getappdata(hFig,'OpenGLDisplay');
    % Update Java background color
    OGL.setClearColor(BackgroundColor(1), BackgroundColor(2), BackgroundColor(3), 0);
    % Update Matlab background color
    set(hFig, 'Color', BackgroundColor)
    % === BLENDING ===
    % Ensures that if background is white no blending is on.
    % Blending is additive and therefore won't be visible.
    if all(BackgroundColor == [1 1 1])
        SetBlendingMode(hFig, 0);
    end
    
    % === UPDATE TEXT COLOR ===
    FigureHasText = getappdata(hFig, 'FigureHasText');
    if FigureHasText
        % Agregating node text
        AgregatingNodes = bst_figures('GetFigureHandleField', hFig, 'AgregatingNodes');
        if ~isempty(AgregatingNodes)
            OGL.setTextColor(AgregatingNodes - 1, TextColor(1), TextColor(2), TextColor(3));
        end
        % Measure node text
        MeasureNodes = bst_figures('GetFigureHandleField', hFig, 'MeasureNodes');
        if ~isempty(MeasureNodes)
            OGL.setTextColor(MeasureNodes - 1, TextColor(1), TextColor(2), TextColor(3));
        end
    end
    
    % === 3D POLYGON ===
    is3DDisplay = getappdata(hFig, 'is3DDisplay');
    if is3DDisplay
        OGL.setPolygonColor(0, TextColor(1), TextColor(2), TextColor(3));
    end
    % Update
    OGL.repaint();
    % 
    setappdata(hFig, 'BgColor', BackgroundColor);
    %
    UpdateContainer(hFig, []);
end

function ToggleBackground(hFig)
    % 
    BackgroundColor = getappdata(hFig, 'BgColor');
    if all(BackgroundColor == [1 1 1])
        BackgroundColor = [0 0 0];
    else
        BackgroundColor = [1 1 1];
    end
    TextColor = ~BackgroundColor;
    SetBackgroundColor(hFig, BackgroundColor, TextColor)
end

%%
function SetIsBinaryData(hFig, IsBinaryData)
    % Update variable
    setappdata(hFig, 'IsBinaryData', IsBinaryData);
    setappdata(hFig, 'UserSpecifiedBinaryData', 1);
    % Update colormap
    UpdateColormap(hFig);
end

function ToggleDisplayMode(hFig)
    % Get display mode
    DisplayOutwardMeasure = getappdata(hFig, 'DisplayOutwardMeasure');
    DisplayInwardMeasure = getappdata(hFig, 'DisplayInwardMeasure');
    % Toggle value
    if (DisplayInwardMeasure == 0 && DisplayOutwardMeasure == 0)
        DisplayOutwardMeasure = 1;
        DisplayInwardMeasure = 1;
        DisplayBidirectionalMeasure = 0;
    elseif (DisplayInwardMeasure == 0 && DisplayOutwardMeasure == 1)
        DisplayOutwardMeasure = 0;
        DisplayInwardMeasure = 1;
        DisplayBidirectionalMeasure = 0;
    elseif (DisplayInwardMeasure == 1 && DisplayOutwardMeasure == 0)
        DisplayOutwardMeasure = 1;
        DisplayInwardMeasure = 1;
        DisplayBidirectionalMeasure = 1;
    else
        DisplayOutwardMeasure = 0;
        DisplayInwardMeasure = 0;
        DisplayBidirectionalMeasure = 1;
    end
    % Update display
    setDisplayMeasureMode(DisplayOutwardMeasure, DisplayInwardMeasure, DisplayBidirectionalMeasure);
    % UI refresh candy
    RefreshBinaryStatus(hFig);
end

function setDisplayMeasureMode(hFig, DisplayOutwardMeasure, DisplayInwardMeasure, DisplayBidirectionalMeasure, Refresh)
    if (nargin < 5)
        Refresh = 1;
    end
    % Get selected rows
    selNodes = bst_figures('GetFigureHandleField', hFig, 'SelectedNodes');
    if (Refresh)
        % Remove previous links
        SetSelectedNodes(hFig, selNodes, 0, 0);
    end
    % Update display mode
    setappdata(hFig, 'DisplayOutwardMeasure', DisplayOutwardMeasure);
    setappdata(hFig, 'DisplayInwardMeasure', DisplayInwardMeasure);
    setappdata(hFig, 'DisplayBidirectionalMeasure', DisplayBidirectionalMeasure);
    % ----- User convenience code -----
    RefreshBinaryStatus(hFig);
    if (Refresh)
        % Redraw selected nodes
        SetSelectedNodes(hFig, selNodes, 1, 1);
    end
end

function RefreshBinaryStatus(hFig)
    IsBinaryData = getappdata(hFig, 'IsBinaryData');
    DisplayOutwardMeasure = getappdata(hFig, 'DisplayOutwardMeasure');
    DisplayInwardMeasure = getappdata(hFig, 'DisplayInwardMeasure');
    DisplayBidirectionalMeasure = getappdata(hFig, 'DisplayBidirectionalMeasure');
    if (DisplayInwardMeasure && DisplayOutwardMeasure)
        IsBinaryData = 1;
    elseif (DisplayInwardMeasure || DisplayOutwardMeasure)
        IsBinaryData = 0;
        selNodes = bst_figures('GetFigureHandleField', hFig, 'SelectedNodes');
        Nodes = bst_figures('GetFigureHandleField', hFig, 'MeasureNodes');
        nSelectedMeasureNodes = sum(ismember(Nodes, selNodes));
        if (length(Nodes) == nSelectedMeasureNodes);
            IsBinaryData = 1;
        end
    elseif (DisplayBidirectionalMeasure)
        IsBinaryData = 1;
    end
    curBinaryData = getappdata(hFig, 'IsBinaryData');
    if (IsBinaryData ~= curBinaryData)
        setappdata(hFig, 'IsBinaryData', IsBinaryData);
        % Update colormap
        UpdateColormap(hFig);
    end
    setappdata(hFig, 'UserSpecifiedBinaryData', 0);
end

% ===== REFRESH TEXT VISIBILITY =====
function RefreshTextDisplay(hFig, isRedraw)
    % 
    FigureHasText = getappdata(hFig, 'FigureHasText');
    if FigureHasText
        % 
        if nargin < 2
            isRedraw = 1;
        end
        % 
        AgregatingNodes = bst_figures('GetFigureHandleField', hFig, 'AgregatingNodes');
        MeasureNodes = bst_figures('GetFigureHandleField', hFig, 'MeasureNodes');
        ValidNode = bst_figures('GetFigureHandleField', hFig, 'ValidNode');
        %
        nVertices = size(AgregatingNodes,2) + size(MeasureNodes,2);
        VisibleText = zeros(nVertices,1);
        %
        TextDisplayMode = getappdata(hFig, 'TextDisplayMode');
        if ismember(1,TextDisplayMode)
            VisibleText(MeasureNodes) = ValidNode(MeasureNodes);
        end
        if ismember(2,TextDisplayMode)
            VisibleText(AgregatingNodes) = ValidNode(AgregatingNodes);
        end
        if ismember(3,TextDisplayMode)
            selNodes = bst_figures('GetFigureHandleField', hFig, 'SelectedNodes');
            VisibleText(selNodes) = ValidNode(selNodes);
        end
        InvisibleText = ~VisibleText;
        % OpenGL Handle
        OGL = getappdata(hFig, 'OpenGLDisplay');
        % Update text visibility
        if (sum(VisibleText) > 0)
            OGL.setTextVisible(find(VisibleText) - 1, 1.0);
        end
        if (sum(InvisibleText) > 0)
            OGL.setTextVisible(find(InvisibleText) - 1, 0.0);
        end
        % Refresh
        if (isRedraw)
            OGL.repaint();
        end
    end
end


%% ===== SET DATA THRESHOLD =====
function SetDataThreshold(hFig, DataThreshold) %#ok<DEFNU>
    % Get selected rows
    selNodes = bst_figures('GetFigureHandleField', hFig, 'SelectedNodes');
    % Remove previous links
    SetSelectedNodes(hFig, selNodes, 0, 0);
    % Update threshold
    setappdata(hFig, 'DataThreshold', DataThreshold);
    % Redraw selected nodes
    SetSelectedNodes(hFig, selNodes, 1, 1);
end


%% ===== UTILITY FUNCTIONS =====
function NodeIndex = getAgregatedNodesFrom(hFig, AgregatingNodeIndex)
    NodeIndex = [];
    AgregatingNodes = bst_figures('GetFigureHandleField', hFig, 'AgregatingNodes');
    if ismember(AgregatingNodeIndex,AgregatingNodes)
        NodePaths = bst_figures('GetFigureHandleField', hFig, 'NodePaths');
        member = cellfun(@(x) ismember(AgregatingNodeIndex,x), NodePaths);
        NodeIndex = find(member == 1);
    end
end


%% ===== COMPUTING LINK PATH =====
function MeasureLinks = BuildRegionPath(hFig, mPaths, mDataPair)
    % Init return variable
    MeasureLinks = [];
    if isempty(mDataPair)
        return;
    end
    % 
    nPairs = size(mDataPair,1);
    if (nPairs > 0)
        % Define path to center as defined by the hierarchy
        ToCenter = mPaths(mDataPair(:,1));
        ToDestination = cellfun(@(x) x(end-1:-1:1), mPaths(mDataPair(:,2)), 'UniformOutput', 0);
        % Concat 
        MeasureLinks = cellfun(@(x,y) cat(2, x, y), ToCenter, ToDestination, 'UniformOutput', 0);
        % Level specific display
        NumberOfLevels = bst_figures('GetFigureHandleField', hFig, 'NumberOfLevels');
        if (NumberOfLevels > 2)
            % Retrieve channel hierarchy
            ChannelData = bst_figures('GetFigureHandleField', hFig, 'ChannelData');
            % 
            if (~isempty(ChannelData))
                SameRegion = ChannelData(mDataPair(1:end,1),1) == ChannelData(mDataPair(1:end,2),1);
                MeasureLinks(SameRegion) = cellfun(@(x,y) cat(2, x(1:2), y(end)), ToCenter(SameRegion), ToDestination(SameRegion), 'UniformOutput', 0);
                % 
                if (NumberOfLevels > 3)
                    % 
                    SameHemisphere = ChannelData(mDataPair(1:end,1),3) == ChannelData(mDataPair(1:end,2),3);
                    SameLobe = ChannelData(mDataPair(1:end,1),2) == ChannelData(mDataPair(1:end,2),2);
                    % Remove hierarchy based duplicate
                    SameLobe = SameLobe == 1 & SameRegion == 0 & SameHemisphere == 1;
                    SameHemisphere = SameHemisphere == 1 & SameRegion == 0 & SameLobe == 0;
                    %
                    MeasureLinks(SameLobe) = cellfun(@(x,y) cat(2, x(1:2), y(end-1:end)), ToCenter(SameLobe), ToDestination(SameLobe), 'UniformOutput', 0);
                    MeasureLinks(SameHemisphere) = cellfun(@(x,y) cat(2, x(1:3), y(end-2:end)), ToCenter(SameHemisphere), ToDestination(SameHemisphere), 'UniformOutput', 0);
                end
            end
        end
    end
end

function MeasureLinks = BuildRegionPath3D(hFig, mPaths, mDataPair, mLoc)
    % Init return variable
    MeasureLinks = [];
    if isempty(mDataPair)
        return;
    end
    % 
    if (size(mDataPair, 1) > 0)
        % Define path to center as defined by the hierarchy
        ToCenter = mPaths(mDataPair(:,1));        
        ToDestination = cellfun(@(x) bst_flip(x,2), mPaths(mDataPair(:,2)), 'UniformOutput', 0);
        % Use path based on connectivity map
        ANCMap = bst_figures('GetFigureHandleField', hFig, 'AgregatingNodeConnectMap');
        % 
        MeasureLinks = cellfun(@(x,y) [x(1) ANCMap{x(2),y(end-1)} y(end)], ToCenter, ToDestination, 'UniformOutput', 0);
    end
end


function [aSplines] = ComputeSpline(hFig, MeasureLinks, Vertices)
    %
    aSplines = [];
    nMeasureLinks = size(MeasureLinks,1);
    if (nMeasureLinks > 0)
        % Define Spline Implementation details
        Order = [3 4 5 6 7 8 9 10];
        Weights = [
 {
    [ 1.0000  0.8975  0.8006  0.7091  0.6233  0.5429  0.4681  0.3989  0.3352  0.2770  0.2244  0.1773  0.1357  0.0997  0.0693  0.0443  0.0249  0.0111  0.0028  0.0000 ;
      0.0000  0.0997  0.1884  0.2659  0.3324  0.3878  0.4321  0.4654  0.4875  0.4986  0.4986  0.4875  0.4654  0.4321  0.3878  0.3324  0.2659  0.1884  0.0997  0.0000  ;
      0.0000  0.0028  0.0111  0.0249  0.0443  0.0693  0.0997  0.1357  0.1773  0.2244  0.2770  0.3352  0.3989  0.4681  0.5429  0.6233  0.7091  0.8006  0.8975  1.0000 ]'
}
 {
    [ 1.0000  0.8503  0.7163  0.5972  0.4921  0.4001  0.3203  0.2519  0.1941  0.1458  0.1063  0.0746  0.0500  0.0315  0.0182  0.0093  0.0039  0.0012  0.0001  0.0000 ;
      0.0000  0.1417  0.2528  0.3359  0.3936  0.4286  0.4435  0.4409  0.4234  0.3936  0.3543  0.3079  0.2572  0.2047  0.1531  0.1050  0.0630  0.0297  0.0079  0.0000 ;
      0.0000  0.0079  0.0297  0.0630  0.1050  0.1531  0.2047  0.2572  0.3079  0.3543  0.3936  0.4234  0.4409  0.4435  0.4286  0.3936  0.3359  0.2528  0.1417  0.0000 ;
      0.0000  0.0001  0.0012  0.0039  0.0093  0.0182  0.0315  0.0500  0.0746  0.1063  0.1458  0.1941  0.2519  0.3203  0.4001  0.4921  0.5972  0.7163  0.8503  1.0000 ]'
}
 {
    [ 1.0000  0.8055  0.6409  0.5029  0.3885  0.2948  0.2192  0.1591  0.1123  0.0767  0.0503  0.0314  0.0184  0.0099  0.0048  0.0020  0.0006  0.0001  0.0000  0.0000 ;
      0.0000  0.1790  0.3016  0.3772  0.4144  0.4211  0.4046  0.3713  0.3268  0.2762  0.2238  0.1729  0.1263  0.0862  0.0537  0.0295  0.0133  0.0042  0.0006  0.0000 ;
      0.0000  0.0149  0.0532  0.1061  0.1657  0.2256  0.2801  0.3249  0.3565  0.3729  0.3729  0.3565  0.3249  0.2801  0.2256  0.1657  0.1061  0.0532  0.0149  0.0000 ;
      0.0000  0.0006  0.0042  0.0133  0.0295  0.0537  0.0862  0.1263  0.1729  0.2238  0.2762  0.3268  0.3713  0.4046  0.4211  0.4144  0.3772  0.3016  0.1790  0.0000 ;
      0.0000  0.0000  0.0001  0.0006  0.0020  0.0048  0.0099  0.0184  0.0314  0.0503  0.0767  0.1123  0.1591  0.2192  0.2948  0.3885  0.5029  0.6409  0.8055  1.0000 ]'
}
 {
    [ 1.0000  0.7631  0.5734  0.4235  0.3067  0.2172  0.1500  0.1005  0.0650  0.0404  0.0238  0.0132  0.0068  0.0031  0.0013  0.0004  0.0001  0.0000  0.0000  0.0000 ;
      0.0000  0.2120  0.3373  0.3970  0.4089  0.3879  0.3460  0.2931  0.2365  0.1817  0.1325  0.0910  0.0582  0.0340  0.0177  0.0078  0.0026  0.0005  0.0000  0.0000 ;
      0.0000  0.0236  0.0794  0.1489  0.2181  0.2770  0.3194  0.3420  0.3440  0.3271  0.2944  0.2502  0.1995  0.1474  0.0989  0.0582  0.0279  0.0093  0.0013  0.0000 ;
      0.0000  0.0013  0.0093  0.0279  0.0582  0.0989  0.1474  0.1995  0.2502  0.2944  0.3271  0.3440  0.3420  0.3194  0.2770  0.2181  0.1489  0.0794  0.0236  0.0000 ;
      0.0000  0.0000  0.0005  0.0026  0.0078  0.0177  0.0340  0.0582  0.0910  0.1325  0.1817  0.2365  0.2931  0.3460  0.3879  0.4089  0.3970  0.3373  0.2120  0.0000 ;
      0.0000  0.0000  0.0000  0.0001  0.0004  0.0013  0.0031  0.0068  0.0132  0.0238  0.0404  0.0650  0.1005  0.1500  0.2172  0.3067  0.4235  0.5734  0.7631  1.0000 ]'
}
 {
    [ 1.0000  0.7230  0.5131  0.3566  0.2421  0.1600  0.1026  0.0635  0.0377  0.0213  0.0113  0.0056  0.0025  0.0010  0.0003  0.0001  0.0000  0.0000  0.0000  0.0000 ;
      0.0000  0.2410  0.3622  0.4012  0.3874  0.3430  0.2841  0.2221  0.1643  0.1148  0.0753  0.0460  0.0257  0.0129  0.0056  0.0020  0.0005  0.0001  0.0000  0.0000 ;
      0.0000  0.0335  0.1065  0.1881  0.2583  0.3062  0.3278  0.3240  0.2988  0.2583  0.2092  0.1580  0.1102  0.0698  0.0391  0.0184  0.0066  0.0015  0.0001  0.0000 ;
      0.0000  0.0025  0.0167  0.0470  0.0918  0.1458  0.2017  0.2520  0.2897  0.3099  0.3099  0.2897  0.2520  0.2017  0.1458  0.0918  0.0470  0.0167  0.0025  0.0000 ;
      0.0000  0.0001  0.0015  0.0066  0.0184  0.0391  0.0698  0.1102  0.1580  0.2092  0.2583  0.2988  0.3240  0.3278  0.3062  0.2583  0.1881  0.1065  0.0335  0.0000 ;
      0.0000  0.0000  0.0001  0.0005  0.0020  0.0056  0.0129  0.0257  0.0460  0.0753  0.1148  0.1643  0.2221  0.2841  0.3430  0.3874  0.4012  0.3622  0.2410  0.0000 ;
      0.0000  0.0000  0.0000  0.0000  0.0001  0.0003  0.0010  0.0025  0.0056  0.0113  0.0213  0.0377  0.0635  0.1026  0.1600  0.2421  0.3566  0.5131  0.7230  1.0000 ]'
}
 {
    [ 1.0000  0.6849  0.4591  0.3003  0.1911  0.1179  0.0702  0.0401  0.0218  0.0112  0.0054  0.0023  0.0009  0.0003  0.0001  0.0000  0.0000  0.0000  0.0000  0.0000 ;
      0.0000  0.2664  0.3780  0.3942  0.3568  0.2948  0.2268  0.1637  0.1110  0.0705  0.0416  0.0226  0.0111  0.0047  0.0017  0.0005  0.0001  0.0000  0.0000  0.0000 ;
      0.0000  0.0444  0.1334  0.2217  0.2854  0.3159  0.3140  0.2864  0.2422  0.1903  0.1387  0.0931  0.0569  0.0309  0.0144  0.0054  0.0015  0.0002  0.0000  0.0000 ;
      0.0000  0.0041  0.0262  0.0693  0.1269  0.1880  0.2416  0.2785  0.2935  0.2854  0.2569  0.2135  0.1625  0.1115  0.0672  0.0338  0.0130  0.0031  0.0002  0.0000 ;
      0.0000  0.0002  0.0031  0.0130  0.0338  0.0672  0.1115  0.1625  0.2135  0.2569  0.2854  0.2935  0.2785  0.2416  0.1880  0.1269  0.0693  0.0262  0.0041  0.0000 ;
      0.0000  0.0000  0.0002  0.0015  0.0054  0.0144  0.0309  0.0569  0.0931  0.1387  0.1903  0.2422  0.2864  0.3140  0.3159  0.2854  0.2217  0.1334  0.0444  0.0000 ;
      0.0000  0.0000  0.0000  0.0001  0.0005  0.0017  0.0047  0.0111  0.0226  0.0416  0.0705  0.1110  0.1637  0.2268  0.2948  0.3568  0.3942  0.3780  0.2664  0.0000 ;
      0.0000  0.0000  0.0000  0.0000  0.0000  0.0001  0.0003  0.0009  0.0023  0.0054  0.0112  0.0218  0.0401  0.0702  0.1179  0.1911  0.3003  0.4591  0.6849  1.0000 ]'
}
 {
    [ 1.0000  0.6489  0.4107  0.2529  0.1509  0.0869  0.0480  0.0253  0.0126  0.0059  0.0025  0.0010  0.0003  0.0001  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000 ;
      0.0000  0.2884  0.3866  0.3793  0.3219  0.2483  0.1773  0.1181  0.0734  0.0424  0.0225  0.0109  0.0047  0.0017  0.0005  0.0001  0.0000  0.0000  0.0000  0.0000 ;
      0.0000  0.0561  0.1592  0.2489  0.3005  0.3103  0.2865  0.2412  0.1869  0.1335  0.0876  0.0523  0.0279  0.0130  0.0050  0.0015  0.0003  0.0000  0.0000  0.0000 ;
      0.0000  0.0062  0.0375  0.0934  0.1602  0.2217  0.2644  0.2814  0.2719  0.2404  0.1947  0.1438  0.0958  0.0563  0.0283  0.0114  0.0033  0.0005  0.0000  0.0000 ;
      0.0000  0.0004  0.0055  0.0219  0.0534  0.0990  0.1526  0.2052  0.2472  0.2704  0.2704  0.2472  0.2052  0.1526  0.0990  0.0534  0.0219  0.0055  0.0004  0.0000 ;
      0.0000  0.0000  0.0005  0.0033  0.0114  0.0283  0.0563  0.0958  0.1438  0.1947  0.2404  0.2719  0.2814  0.2644  0.2217  0.1602  0.0934  0.0375  0.0062  0.0000 ;
      0.0000  0.0000  0.0000  0.0003  0.0015  0.0050  0.0130  0.0279  0.0523  0.0876  0.1335  0.1869  0.2412  0.2865  0.3103  0.3005  0.2489  0.1592  0.0561  0.0000 ;
      0.0000  0.0000  0.0000  0.0000  0.0001  0.0005  0.0017  0.0047  0.0109  0.0225  0.0424  0.0734  0.1181  0.1773  0.2483  0.3219  0.3793  0.3866  0.2884  0.0000 ;
      0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0001  0.0003  0.0010  0.0025  0.0059  0.0126  0.0253  0.0480  0.0869  0.1509  0.2529  0.4107  0.6489  1.0000 ]'
}
 {
    [ 1.0000  0.6147  0.3675  0.2130  0.1191  0.0640  0.0329  0.0160  0.0073  0.0031  0.0012  0.0004  0.0001  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000 ;
      0.0000  0.3074  0.3891  0.3594  0.2859  0.2058  0.1365  0.0839  0.0478  0.0251  0.0120  0.0051  0.0019  0.0006  0.0002  0.0000  0.0000  0.0000  0.0000  0.0000 ;
      0.0000  0.0683  0.1831  0.2695  0.3050  0.2940  0.2520  0.1959  0.1391  0.0904  0.0534  0.0283  0.0132  0.0053  0.0017  0.0004  0.0001  0.0000  0.0000  0.0000 ;
      0.0000  0.0089  0.0503  0.1179  0.1898  0.2450  0.2714  0.2666  0.2361  0.1898  0.1383  0.0908  0.0529  0.0267  0.0112  0.0036  0.0008  0.0001  0.0000  0.0000 ;
      0.0000  0.0007  0.0089  0.0332  0.0759  0.1313  0.1879  0.2333  0.2576  0.2562  0.2306  0.1873  0.1361  0.0867  0.0469  0.0202  0.0062  0.0010  0.0000  0.0000 ;
      0.0000  0.0000  0.0010  0.0062  0.0202  0.0469  0.0867  0.1361  0.1873  0.2306  0.2562  0.2576  0.2333  0.1879  0.1313  0.0759  0.0332  0.0089  0.0007  0.0000 ;
      0.0000  0.0000  0.0001  0.0008  0.0036  0.0112  0.0267  0.0529  0.0908  0.1383  0.1898  0.2361  0.2666  0.2714  0.2450  0.1898  0.1179  0.0503  0.0089  0.0000 ;
      0.0000  0.0000  0.0000  0.0001  0.0004  0.0017  0.0053  0.0132  0.0283  0.0534  0.0904  0.1391  0.1959  0.2520  0.2940  0.3050  0.2695  0.1831  0.0683  0.0000 ;
      0.0000  0.0000  0.0000  0.0000  0.0000  0.0002  0.0006  0.0019  0.0051  0.0120  0.0251  0.0478  0.0839  0.1365  0.2058  0.2859  0.3594  0.3891  0.3074  0.0000 ;
      0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0001  0.0004  0.0012  0.0031  0.0073  0.0160  0.0329  0.0640  0.1191  0.2130  0.3675  0.6147  1.0000 ]'
}
];
        LinkDetail = 20;
        Spread = linspace(0,1,LinkDetail);
        % Bundling factor
        Bundling = 0.9;
        
        is3DDisplay = getappdata(hFig, 'is3DDisplay');
        if (is3DDisplay)
            % Compute weights
            Order = [1 2 3 4 5 6 7 8 9 10];
            Weights = cell(10,1);
            for i=3:10
                n = i - 1;
                t = [0 0 0:1/(n-1):1 1 1];
                Weights{i} = bspline_basismatrix(3, t, Spread);
            end
            Bundling = 0.95;
        end
        
        % Compute spline for each MeasureLinks
        MaxDist = max(max(Vertices(:,:))) * 2;
        aSplines = zeros(nMeasureLinks * 8 * 10 * 3,1);
        
        Index = 1;
        for i=1:nMeasureLinks
            % Link
            Link = MeasureLinks{i};
            % Number of control points (CP)
            nFrames = size(Link,2);
            % Get the positions of CP
            Frames = Vertices(Link(:),:);
            % Last minute display candy
            if (nFrames == 3)
                % We assume that 3 frames are nodes near each others
                % and force an arc between the nodes
                Dist = sqrt(sum(abs(Frames(end,:) - Frames(1,:)).^2));
                Dist = abs(0.9 - Dist / MaxDist);
                Middle = (Frames(1,:) + Frames(end,:)) / 2;
                Frames(2,:) = Middle * Dist;
            end
            % 
            if (nFrames == 2)
                aSplines(Index) = 2;
                aSplines(Index+1:Index + 2 * 3) = reshape(Frames(1:2,:)',[],1);
                Index = Index + 2 * 3 + 1;
            else
                % Bundling property (Higher beta very bundled)
                % Beta = 0.7 + 0.2 * sin(0:pi/(nFrames-1):pi);
                Beta = Bundling * ones(1,nFrames);
                
                % Prototype: Corpus Callosum influence
                % N = nFrames;
                % t = 0:1/(N-1):1;
                % Beta = Bundling + 0.1 * cos((2 * pi) / (N / 2) * (t * N));
                
                for y=2:nFrames-1
                    Frames(y,:) = Beta(y) * Frames(y,:) + (1 - Beta(y)) * (Frames(1,:) + y / (nFrames - 1) * (Frames(end,:) - Frames(1,:)));
                end
                %
                W = Weights{Order == nFrames};
                % 
                Spline = W * Frames;
                % Specifiy link length for Java
                aSplines(Index) = LinkDetail;
                % Assign spline vertices in a one dimension structure
                aSplines(Index+1:Index + (LinkDetail) * 3) = reshape(Spline',[],1);
                % Update index
                Index = Index + (LinkDetail) * 3 + 1;
            end
        end
        % Truncate unused data
        aSplines = aSplines(1:Index-1);
    end
end

function [B,x] = bspline_basismatrix(n,t,x)
    if nargin > 2
        B = zeros(numel(x),numel(t)-n);
        for j = 0 : numel(t)-n-1
            B(:,j+1) = bspline_basis(j,n,t,x);
        end
    else
        [b,x] = bspline_basis(0,n,t);
        B = zeros(numel(x),numel(t)-n);
        B(:,1) = b;
        for j = 1 : numel(t)-n-1
            B(:,j+1) = bspline_basis(j,n,t,x);
        end
    end
end


% This code is the original ComputeSpline without the precomputed
% weight values. This function could be used if we want to user a higher 
% degree of details (LinkDetail) or add a order degree (LongerLinks).
%
% function [aSplines] = OldComputeSpline(hFig, MeasureLinks, Vertices)
%     %
%     aSplines = [];
%     nMeasureLinks = size(MeasureLinks,1);
%     if (nMeasureLinks > 0)
%         % Define Spline Implementation details
%         LinkDetail = 20;
%         Spread = linspace(0, 1, LinkDetail);
%         Order = [3 4 5 6 7 8 9 10];
%         KnotsPerOrder = cell(size(Order,2),1);
%         WeightsPerOrder = cell(size(Order,2),1);
%         for i=1:size(Order,2)
%             KnotsPerOrder(i) = {[zeros(1,Order(i)) 1 ones(1,Order(i))]};
%             Weights = cell(Order(i),1);
%             for y=1:Order(i)
%                 Weights(y) = {bspline_basis(y-1, Order(i), KnotsPerOrder{i}, Spread)};
%             end
%             
%             WeightsPerOrder(i) = {Weights};
%         end
%         % Compute spline for each MeasureLinks
%         MaxDist = max(max(Vertices(:,:))) * 2;
%         Index = 1;
%         aSplines = zeros(nMeasureLinks * 8 * 10 * 3,1);
%         for i=1:nMeasureLinks
%             % Link
%             Link = MeasureLinks{i};
%             % Number of control points (CP)
%             nFrames = size(Link,2);
%             % Get the positions of CP
%             Frames = Vertices(Link(:),:);
%             % Last minute display candy
%             if (nFrames == 3)
%                 % Simple arc for same region nodes
%                 Dist = sqrt(sum(abs(Frames(end,:) - Frames(1,:)).^2));
%                 Dist = abs(0.9 - Dist / MaxDist);
%                 Middle = (Frames(1,:) + Frames(end,:)) / 2;
%                 Frames(2,:) = Middle * Dist;
%             end
%             
%             if (nFrames == 2)
%                 aSplines(Index) = 2;
%                 aSplines(Index+1:Index + 2 * 3) = reshape(Frames(1:2,:)',[],1);
%                 Index = Index + 2 * 3 + 1;
%             else
%                 % Retrieve proper weight for spline
%                 Weights = WeightsPerOrder{Order == nFrames};
%                 Spline = zeros(3,LinkDetail);
%                 for y=1:nFrames
%                     W = Weights{y};
%                     Spline(:,:) = Spline(:,:) + bsxfun(@times, W, Frames(y,:)');
%                 end            
%                 % Specifiy link length for Java
%                 aSplines(Index) = LinkDetail;
%                 % Assign spline vertices in a one dimension structure
%                 aSplines(Index+1:Index + (LinkDetail) * 3) = reshape(Spline,[],1);
%                 % Update index
%                 Index = Index + (LinkDetail) * 3 + 1;
%             end
%         end
%         % Truncate unused data
%         aSplines = aSplines(1:Index-1);
%     end
% end


%% ===== ADD NODES TO JAVA ENGINE =====
function ClearAndAddChannelsNode(hFig, V, Names)
    % Get OpenGL handle
    OGL = getappdata(hFig, 'OpenGLDisplay');
    MeasureNodes = bst_figures('GetFigureHandleField', hFig, 'MeasureNodes');
    AgregatingNodes = bst_figures('GetFigureHandleField', hFig, 'AgregatingNodes');
    DisplayedNodes = find(bst_figures('GetFigureHandleField', hFig, 'ValidNode'));
    DisplayedMeasureNodes = MeasureNodes(ismember(MeasureNodes,DisplayedNodes));
    NumberOfMeasureNode = length(DisplayedMeasureNodes);
    nAgregatingNodes = length(AgregatingNodes);
    
    % Is display in 3D ?
    is3DDisplay = getappdata(hFig, 'is3DDisplay');
    if isempty(is3DDisplay)
        is3DDisplay = 0;
    end
    
    % @TODO: If the number of node is greater than a certain number
    % our current Java engine might not run smoothly for that many text
    FigureHasText = NumberOfMeasureNode <= 500;
    setappdata(hFig, 'FigureHasText', FigureHasText);
    
    % Default link size
    LinkSize = GetLinkSize(hFig);
    % Default radial display option
    RadialTextDisplay = 0;
    % Default node size
    NodeSize = 0;
    % Default text size
    TextSize = 0.005;
    % Default text distance from node
    TextDistanceFromNode = 1;
    
    if ~is3DDisplay
        %
        NodeSize = 30 / NumberOfMeasureNode * 0.25;
        % Small number of node have different hardcoded values
        if (NumberOfMeasureNode <= 20)
            NodeSize = 0.25;
            % For very long text, radial display are much nicer
            MaxLabelLength = max(cellfun(@(x) size(x,2), Names));
            if (MaxLabelLength > 10)
                RadialTextDisplay = 1;
            end
        else
            RadialTextDisplay = 1;
        end
        % Note: 1/20 is an arbitrarily defined ratio 
        %       to compensate for the high font resolution
        FontScalingRatio = 1 / 20;
        TextSize = 1.2 * NodeSize * FontScalingRatio;
        TextDistanceFromNode = NodeSize * 2.5;
        LinkSize = NodeSize * 20;
        if (LinkSize < 1)
            LinkSize = 1;
        end
    end
    RegionNodeSize = 0.5 * NodeSize;
    if (RegionNodeSize < 0.05)
        RegionNodeSize = 0.05;
    end
    RegionTextSize = TextSize;
    
    setappdata(hFig, 'NodeSize', NodeSize);
    setappdata(hFig, 'LinkSize', LinkSize);
    
    nVertices = size(V,1);

    OGL.addNode(V(:,1), V(:,2), V(:,3));
    % 
    OGL.setNodeInnerColor(0:(nVertices-1), 0.7, 0.7, 0.7);
    OGL.setNodeOuterColor(0:(nVertices-1), 0.5, 0.5, 0.5);
    OGL.setNodeOuterRadius(0:(nVertices-1), NodeSize);
    OGL.setNodeInnerRadius(0:(nVertices-1), 0.75 * NodeSize);
    OGL.setNodeOuterRadius(AgregatingNodes - 1, RegionNodeSize);
    OGL.setNodeInnerRadius(AgregatingNodes - 1, 0.75 * RegionNodeSize);
    
    % Node are color coded to their Scout counterpart
    RowColors = bst_figures('GetFigureHandleField', hFig, 'RowColors');
    if ~isempty(RowColors)
        for i=1:length(RowColors)
            OGL.setNodeInnerColor(nAgregatingNodes+i-1, RowColors(i,1), RowColors(i,2), RowColors(i,3));
        end
    end
    
    Pos = V(:,1:3);
    if ~is3DDisplay
        Dir = bsxfun(@minus, V(:,1:3), [0 0 0]);
        Sum = sum(abs(Dir).^2,2).^(1/2);
        NonZero = Sum ~= 0;
        Dir(NonZero,:) = bsxfun(@rdivide, Dir(NonZero,:), Sum(NonZero));
        Pos(MeasureNodes,:) = V(MeasureNodes,1:3) + Dir(MeasureNodes,:) * TextDistanceFromNode;
    end
    
    % Middle axe used for text alignment
    Axe = [0 1 0];
    % For each node
    for i=1:nVertices
        % Blank name if none is assigned
        if (isempty(Names(i)) || isempty(Names{i}))
            Names{i} = '';
        end
        
        if (is3DDisplay)
            OGL.setNodeTransparency(i - 1, 1.00);
        else
            OGL.setNodeTransparency(i - 1, 0.01);
        end
        
        if (FigureHasText)
            % Assign name
            OGL.setNodeText(i-1, Names(i));
            % Text alignment code
            %   1: Left,
            %   2: Middle,
            %   3: Right
            if (i < nAgregatingNodes)
                % Region nodes are always middle aligned
                OGL.setTextAlignment(i-1, 2);
            else
                if (V(i,1) > 0)
                    % Right hemisphere
                    OGL.setTextAlignment(i-1, 1);
                else
                    % Left hemisphere
                    OGL.setTextAlignment(i-1, 3);
                end
            end
            
            if (RadialTextDisplay && i > nAgregatingNodes)
                % Find out the angle between the node vertex and the center
                theta = 0;
                Denom = (norm(Axe)*norm(Pos(i,:)));
                if (Denom ~= 0)
                    theta = acos(dot(Axe,Pos(i,:))/Denom);
                end
                % Right or Left
                if (V(i,1) > 0)
                    theta = -theta + 3.1415 / 2;
                else
                    theta = theta - 3.1415 / 2;
                end
                % Convert angle
                thetaDeg = (180 / pi) .* theta;
                OGL.setTextOrientation(i-1, thetaDeg);
            end
        end
    end
    
    if (FigureHasText)
        OGL.setTextSize(0:(nVertices-1), TextSize);
        OGL.setTextSize(AgregatingNodes - 1, RegionTextSize);
        OGL.setTextPosition(0:(nVertices-1), Pos(:,1), Pos(:,2), Pos(:,3));
        OGL.setTextTransparency(0:(nVertices-1), 0.0);
        OGL.setTextColor(0:(nVertices-1), 0.1, 0.1, 0.1);
        OGL.setTextVisible(0:(nVertices-1), 1.0);
        OGL.setTextVisible(AgregatingNodes - 1, 0);
    end
end


% function SetupRadialRegion(hFig, Vertices, sGroups, aNames, RowLocs)
%     % 
%     OGL = getappdata(hFig, 'OpenGLDisplay');
%     MeasureLevelDistance = getappdata(hFig, 'MeasureLevelDistance');
%     % 
%     MeasureNodes = bst_figures('GetFigureHandleField', hFig, 'MeasureNodes');
%     AgregatingNodes = bst_figures('GetFigureHandleField', hFig, 'AgregatingNodes');
%     NumberOfAgregatingNodes = size(AgregatingNodes,2);
%     nMeasureNodes = size(MeasureNodes,2);
%     % Common rendering parameters
%     rbLineDetail = 50;
%     rbVertexCount = rbLineDetail * 2;
%     rbIndices = zeros(rbVertexCount,1);
%     rbIndices(1:2:rbVertexCount) = 1:1:rbLineDetail;
% 	rbIndices(2:2:rbVertexCount) = (rbLineDetail+1):1:rbVertexCount;
%     rbIndices = rbIndices - 1;
%     % Selection data
%     NumberOfGroups = size(sGroups,2);
%     RadialRegionSelection = zeros(NumberOfGroups * 3,1);
%     RegionParameters = zeros(NumberOfGroups,2);
%     for i=1:NumberOfGroups
%         % Find which node and their Index
%         NodesOfThisGroup = ismember(aNames, sGroups(i).RowNames);
%         Index = find(NodesOfThisGroup) + NumberOfAgregatingNodes;
%         % Get vertices and sort Ant-Post
%         Order = 1:size(Index,1);
%         if ~isempty(RowLocs)
%             [tmp, Order] = sort(RowLocs(NodesOfThisGroup,1), 'descend');
%         end
%         NodesVertices = Vertices(Index(Order),:);
%         % 
%         RegionParameters(i,1) = VectorToAngle(NodesVertices(1,:) / norm(NodesVertices(1,:)));
%         RegionParameters(i,2) = VectorToAngle(NodesVertices(end,:) / norm(NodesVertices(end,:)));
%         % 1st to 4th Quadrant correction
%         if (RegionParameters(i,1) >= 0   && RegionParameters(i,1) <= 90 && ...
%             RegionParameters(i,2) >= 270 && RegionParameters(i,2) <= 360)  
%             RegionParameters(i,1) = 360 + RegionParameters(i,1);
%         end
%     end
% 
%     Parameters{1} = RegionParameters;
%     Lengths = [1.10 1.16];
%     
%     Parameter = Parameters{1};
%     nRadialBox = size(Parameter,1);
%     for i=1:nRadialBox
%         % 
%         StartAngle = Parameter(i,1);
%         EndAngle = Parameter(i,2);
%         % Compute cartesian
%         Interp = linspace(StartAngle, EndAngle, rbLineDetail);
%         [x,y] = pol2cart(deg2rad(Interp), MeasureLevelDistance);
%         % Assign
%         rbVertices = zeros(rbVertexCount,3);
%         rbVertices(1:(rbVertexCount/2),1:2) = Lengths(1,1) * [x' y'];
%         rbVertices((rbVertexCount/2+1):rbVertexCount,1:2) = Lengths(1,2) * [x' y'];
%         % 
%         OGL.addRadialBox(rbVertices(:,1), rbVertices(:,2), rbVertices(:,3), rbIndices(:));
%     end
%     
%     setappdata(hFig, 'RadialRegionSelection', RadialRegionSelection);
%     
%     %LeftHem = ChannelData(:,3) == 1;
%     %RightHem = ChannelData(:,3) == 2;
%     %if (nCerebellum > 0)
%     %    CereHem = ChannelData(:,2) == 4;
%     %    Vertices(CereHem,2) = Vertices(CereHem,2) * 1.2;
%     %end
%     %if (nUnkown > 0)
%     %    Unknown = ChannelData(:,3) == 0;
%     %    Vertices(Unknown,2) = Vertices(Unknown,2) * 1.2;
%     %end
%     
%     %Vertices(LeftHem,1) = Vertices(LeftHem,1) - 0.6;
%     %Vertices(LeftHem,2) = Vertices(LeftHem,2) * 1.2;
% 	%Vertices(RightHem,1) = Vertices(RightHem,1) + 0.6;
%     %Vertices(RightHem,2) = Vertices(RightHem,2) * 1.2;
% 
% end

% function Angle = VectorToAngle(Vector)
%     Reference = [1 0 0];
%     Angle = zeros(size(Vector,1),1);
%     for i=1:size(Vector,1)
%         Angle(i) = acosd(Vector(i,:) * Reference');
%         if (Vector(i,2) < 0 - 0.000001)
%             Angle(i) = 360 - Angle(i);
%         end
%     end
% end


function [Vertices Paths Names] = OrganiseChannelsIn3D(hFig, sGroups, aNames, aLocs, SurfaceStruct)
    % Some values are Hardcoded for Display consistency
    NumberOfMeasureNodes = size(aNames,1);
    NumberOfGroups = size(sGroups,2);
    NumberOfLobes = 7;
    NumberOfHemispheres = 4;
    NumberOfLevels = 5;
    
    [V H] = ComputeCortexPathBundle(SurfaceStruct);
    NumberOfAgregatingNodes = size(V,1);
    
    % Extract only the first region letter of each group
    HemisphereRegions = cellfun(@(x) {x(1)}, {sGroups.Region})';
    LobeRegions = cellfun(@(x) {LobeIndexToTag(LobeTagToIndex(x))}, {sGroups.Region})';
    
    LeftGroupsIndex = strcmp('L',HemisphereRegions) == 1;
    RightGroupsIndex = strcmp('R',HemisphereRegions) == 1;
    
    Lobes = [];
    NumberOfNodesPerLobe = zeros(NumberOfLobes * 2,1);
    for i=1:NumberOfLobes
        Tag = LobeIndexToTag(i);
        RegionsIndex = strcmp(Tag,LobeRegions) == 1;
        NodesInLeft = [sGroups(LeftGroupsIndex & RegionsIndex).RowNames];
        NodesInRight = [sGroups(RightGroupsIndex & RegionsIndex).RowNames];
        NumberOfNodesPerLobe(i) = size(NodesInLeft,2);
        NumberOfNodesPerLobe(NumberOfLobes + i) = size(NodesInRight,2);
        if (size(NodesInLeft,2) > 0 || size(NodesInRight,2) > 0)
            Lobes = [Lobes i];
        end
    end
    
    % Actual number of lobes with data
    NumberOfLobes = size(Lobes,2);    
    NumberOfVertices = NumberOfMeasureNodes + NumberOfAgregatingNodes;
    Vertices = zeros(NumberOfVertices,3);
    Names = cell(NumberOfVertices,1);
    Paths = cell(NumberOfVertices,1);
    ChannelData = zeros(NumberOfVertices,3);
    Levels = cell(3,1);
    
    AgregatingNodeIndex = NumberOfHemispheres;
    for z=1:NumberOfHemispheres
        HemisphereTag = HemisphereIndexToTag(z);
        HemisphereIndex = z;
        for i=1:NumberOfLobes
            LobeTag = LobeIndexToTag(Lobes(i));
            RegionMask = strcmp(LobeTag,LobeRegions) == 1 & strcmp(HemisphereTag,HemisphereRegions) == 1;
            NumberOfRegionInLobe = sum(RegionMask);
            if (NumberOfRegionInLobe > 0)
                AgregatingNodeIndex = AgregatingNodeIndex + 1;
                LobeIndex = AgregatingNodeIndex;
                RegionNodeIndex = find(RegionMask == 1);
                for y=1:NumberOfRegionInLobe
                    AgregatingNodeIndex = AgregatingNodeIndex + 1;
                    RegionIndex = AgregatingNodeIndex;
                    ChannelsOfThisGroup = ismember(aNames, sGroups(RegionNodeIndex(y)).RowNames);
                    Index = find(ChannelsOfThisGroup) + NumberOfAgregatingNodes;
                    Vertices(Index,1:3) = aLocs(ChannelsOfThisGroup, 1:3);
                    Names(Index) = aNames(ChannelsOfThisGroup);
                    ChannelData(Index,:) = repmat([RegionIndex LobeIndex HemisphereIndex], size(Index));
                end
            end
        end
    end
    
    VertexScale3D = getappdata(hFig, 'VertexScale3D');
    Centroid = getappdata(hFig, 'VertexInitCentroid');
    %Centroid = sum(Vertices) / size(Vertices,1);
    Vertices = Vertices - repmat(Centroid, size(Vertices,1), 1);
    Vertices = Vertices * VertexScale3D;
    
    m = size(Vertices,1);
    n = size(V,1);
    XX = sum(Vertices.*Vertices,2);
    YY = sum(V'.*V',1);
    D = XX(:,ones(1,n)) + YY(ones(1,m),:) - 2*Vertices*V';
    for i=NumberOfAgregatingNodes+1:NumberOfVertices
        Hemis = ChannelData(i,3);
        Valid = find(H == Hemis);
        [tmp, nearestNode] = min(D(i,Valid));
        nearestNode = Valid(nearestNode);
        Paths{i} = [i nearestNode];
    end
    
    Vertices(1:NumberOfAgregatingNodes,:) = V;
    
    bst_figures('SetFigureHandleField', hFig, 'AgregatingNodes', 1:NumberOfAgregatingNodes);
    bst_figures('SetFigureHandleField', hFig, 'MeasureNodes', (NumberOfAgregatingNodes + 1):(NumberOfAgregatingNodes + NumberOfMeasureNodes));
    bst_figures('SetFigureHandleField', hFig, 'NumberOfLevels', NumberOfLevels);
    bst_figures('SetFigureHandleField', hFig, 'Levels', Levels);
    bst_figures('SetFigureHandleField', hFig, 'ChannelData', ChannelData);
end


function [V H] = ComputeCortexPathBundle(SurfaceStruct)

    Vertices = SurfaceStruct.Vertices;
    Middle = sum(Vertices) / size(Vertices,1);
    [yMin, minHideVert] = min(Vertices(:,2));
    [yMax, maxHideVert] = max(Vertices(:,2));
    xMin = min(Vertices(:,1));
    xMax = max(Vertices(:,1));
    zMin = min(Vertices(:,3));
    zMax = max(Vertices(:,3));
    
    V(1,:) = Middle + [xMin * 0.00 yMin * 0.20 zMin * 0.20];
    V(2,:) = Middle + [xMin * 0.00 yMin * 0.20 zMax * 0.10];
    V(3,:) = Middle + [xMin * 0.00 yMax * 0.20 zMin * 0.20];
    V(4,:) = Middle + [xMin * 0.00 yMax * 0.20 zMax * 0.10];
    H(1:4) = [1 1 2 2]'; 
    vIndex = 4;
    
    % Start point
    START_PERCENT = .3;
    
    % Left hemisphere
    LeftSurface = find(Vertices(:,2) < START_PERCENT * yMin)';
    LeftSurface = setdiff(LeftSurface, minHideVert);
    if ~isempty(minHideVert)
        while ~isempty(LeftSurface)
            minHideVert = union(minHideVert, LeftSurface);
            LeftSurface = tess_scout_swell(minHideVert, SurfaceStruct.VertConn);
        end
    end
    
    % Right hemisphere
    RightSurface = find(Vertices(:,2) > START_PERCENT * yMax)';
    RightSurface = setdiff(RightSurface, maxHideVert);
    if ~isempty(maxHideVert)
        while ~isempty(RightSurface)
            maxHideVert = union(maxHideVert, RightSurface);
            RightSurface = tess_scout_swell(maxHideVert, SurfaceStruct.VertConn);
        end
    end
    
    Surface{1} = Vertices(maxHideVert,:);
    Surface{2} = Vertices(minHideVert,:);
    
%     nCoronalSlice = 4;
%     nTransversalSlice = [2 3 3 2];
%     Connected = [1 2; 1 3; 1 17; 1 18; 1 20; 1 21;
%                  2 1; 2 4; 2 18; 2 19; 2 21; 2 22;
%                  3 1; 3 4; 3 7; 3 8; 3 10; 3 11;
%                  4 2; 4 3; 4 8; 4 9; 4 11; 4 12;
%                  ...
%                  5 6; 5 8;
%                  6 8;
%                  7 8; 7 10;
%                  8 9; 8 11;
%                  9 12;
%                  10 11;
%                  11 12; 11 13; 11 14;
%                  12 14;
%                  13 14;
%                  14 13;
%                  ...
%                  15 16; 15 18;
%                  16 18;
%                  17 18; 17 20;
%                  18 19; 18 21;
%                  19 22;
%                  20 21;
%                  21 22; 21 23; 21 24;
%                  22 24;
%                  23 24;
%                  24 23];
    nCoronalSlice = 4;
    nTransversalSlice = [2 3 3 2];
    CoronalStep = (xMax + abs(xMin)) / nCoronalSlice;
    for y=1:2
        Surf = Surface{y};
        cStart = xMin;
        for i=1:nCoronalSlice
            cEnd = cStart + CoronalStep;
            cIndex = Surf(:,1) >= cStart & Surf(:,1) < cEnd;
            tStart = zMin;
            TransversalStep = (zMax + abs(zMin)) / nTransversalSlice(i);
            for z=1:nTransversalSlice(i)
                tEnd = tStart + TransversalStep;
                tIndex = Surf(:,3) >= tStart & Surf(:,3) < tEnd;
                denom = sum(cIndex & tIndex);
                vIndex = vIndex + 1;
                V(vIndex,:) = [0 0 0];
                H(vIndex) = y;
                if (denom > 0)
                    V(vIndex,:) = sum(Surf(cIndex & tIndex,:)) / denom;
                    V(vIndex,:) = (0.75 * V(vIndex,:));
                end
                tStart = tEnd;
            end
            cStart = cEnd;
        end
    end
end


% Experimental code
% function [sGroups] = AssignRegionBasedOnPosition(hFig, aNames, aLocs, sGroups)
%     NumberOfGroups = size(sGroups,2);
%     CentroidOfEachGroups = zeros(NumberOfGroups,3);
%     for i=1:NumberOfGroups
%         NumberOfChannelsInGroup = size(sGroups(i).RowNames,1);
%         ChannelsInGroupIndex = ismember(aNames, sGroups(i).RowNames);
%         C = aLocs(ChannelsInGroupIndex,:);
%         CentroidOfEachGroups(i,:) = [sum(C(:,1)) sum(C(:,2)) sum(C(:,3))] / NumberOfChannelsInGroup;
%         % Assign channel hemisphere
%         if (CentroidOfEachGroups(i,2) > 0.05)
%             sGroups(i).Region = 1;
%         elseif (CentroidOfEachGroups(i,2) <= -0.05)
%             sGroups(i).Region = 2;
%         else
%             if (CentroidOfEachGroups(i,1) <= 0)
%                 sGroups(i).Region = 3;
%             else
%                 sGroups(i).Region = 4;
%             end
%         end
%     end
% end

function Index = HemisphereTagToIndex(Region)
    Tag = Region(1);
    Index = 4; % Unknown
    switch (Tag)
        case 'L' % Left
            Index = 1;
        case 'R' % Right
            Index = 2;
        case 'C' % Cerebellum
            Index = 3;
    end
end

function Index = LobeTagToIndex(Region)
    Tag = Region(2);
    Index = 7; % Unknown
    switch (Tag)
        case 'F' %Frontal
            Index = 2;
        case 'C' %Central
            Index = 3;
        case 'T' %Temporal
            Index = 4;
        case 'P' %Parietal
            Index = 5;
            if (size(Region,2) >= 3)
                if (strcmp(Region(3), 'F'))
                    Index = 1;
                end
            end
        case 'O' %Occipital
            Index = 6;
    end
end

function Tag = ExtractSubRegion(Region)
    Index = LobeTagToIndex(Region);
    if (Index == 1)
        Tag = Region(4:end);
    else
        Tag = Region(3:end);
    end
end

function Tag = HemisphereIndexToTag(Index)
    Tag = 'U';
    switch (Index)
        case 1
            Tag = 'L';
        case 2
            Tag = 'R';
        case 3
            Tag = 'C';
    end
end

function Tag = LobeIndexToTag(Index)
    Tag = 'U';
    switch (Index)
        case 1
            Tag = 'PF';
        case 2
            Tag = 'F';
        case 3
            Tag = 'C';            
        case 4
            Tag = 'T';
        case 5
            Tag = 'P';
        case 6
            Tag = 'O';
    end
end

function PathNames = VerticeToFullName(hFig, Index)
    if (Index == 1)
        return
    end
    PathNames{1} = 'All';
    ChannelData = bst_figures('GetFigureHandleField', hFig, 'ChannelData');
    if (ChannelData(Index,3) ~= 0)
        switch (ChannelData(Index,3))
            case 1
                PathNames{2} = ' > Left hemisphere';
            case 2
                PathNames{2} = ' > Right hemisphere';
            case 3
                PathNames{2} = ' > Cerebellum';
            case 4
                PathNames{2} = ' > Unknown';
        end
    end
    
    if (ChannelData(Index,2) ~= 0)
        switch (ChannelData(Index,2))
            case 1
                PathNames{3} = ' > Pre-Frontal';
            case 2
                PathNames{3} = ' > Frontal';
            case 3
                PathNames{3} = ' > Central';
            case 4
                PathNames{3} = ' > Temporal';
            case 5
                PathNames{3} = ' > Parietal';
            case 6
                PathNames{3} = ' > Occipital';
            otherwise
                PathNames{3} = ' > Unknown';
        end
    end
    
    if (ChannelData(Index,1) ~= 0)
        Names = bst_figures('GetFigureHandleField', hFig, 'Names');
        if isempty(Names{Index})
            PathNames{4} = ' > Sub-region';
        else
            PathNames{4} = [' > ' Names{Index}];
        end
    end 
end


function [sGroups] = GroupScouts(Atlas)
    % 
    NumberOfGroups = 0;
    sGroups = repmat(struct('Name', [], 'RowNames', [], 'Region', {}), 0);
    NumberOfScouts = size(Atlas.Scouts,2);
    for i=1:NumberOfScouts
        Region = Atlas.Scouts(i).Region;
        GroupID = strmatch(Region, {sGroups.Region}, 'exact');
        if isempty(GroupID)
            % New group
            NumberOfGroups = NumberOfGroups + 1;
            sGroups(NumberOfGroups).Name = ['Group ' num2str(NumberOfGroups)];
            sGroups(NumberOfGroups).RowNames = {Atlas.Scouts(i).Label};
            sGroups(NumberOfGroups).Region = Region;
        else
            sGroups(GroupID).RowNames = [sGroups(GroupID).RowNames {Atlas.Scouts(i).Label}];
        end
    end
    
    if size(sGroups,2) == 1 && strcmp(sGroups(1).Region, 'UU') == 1
        sGroups = [];
        return;
    end
    
    % Sort by Hemisphere and Lobe
    for i=2:NumberOfGroups
        j = i;
        sTemp = sGroups(i);
        currentHemisphere = HemisphereTagToIndex(sGroups(i).Region);
        currentLobe = LobeTagToIndex(sGroups(i).Region);
        while ((j > 1))
            current = currentHemisphere;
            next = HemisphereTagToIndex(sGroups(j-1).Region);
            if (current == next)
                current = currentLobe;
                next = LobeTagToIndex(sGroups(j-1).Region);
            end
            if (next <= current)
                break;
            end
            sGroups(j) = sGroups(j-1);
            j = j - 1;
        end
        sGroups(j) = sTemp;
    end
end


% function ChannelData = BuildChannelData(hFig, aNames, sGroups)
%     % Get number of nodes
%     nAgregatingNodes = size(bst_figures('GetFigureHandleField', hFig, 'AgregatingNodes'),2);
%     nMeasureNodes = size(bst_figures('GetFigureHandleField', hFig, 'MeasureNodes'),2);
%     NumberOfChannels = nAgregatingNodes + nMeasureNodes;
%     % Get levels
%     % Levels = bst_figures('GetFigureHandleField', hFig, 'Levels');
%     % Number of levels
%     NumberOfLevels = bst_figures('GetFigureHandleField', hFig, 'NumberOfLevels');
%     % Init structure - (Hemisphere / Lobe / Region)
%     ChannelData = ones(NumberOfChannels, NumberOfLevels - 2);
%     % Constant variable
%     NumberOfHemisphere = 3;
%     NumberOfLobes = 6;
%     NumberOfGroups = size(sGroups,2);
%     % Level specific
%     if (NumberOfLevels == 5)
%         % Hemisphere
%         for i=1:NumberOfHemisphere
%             HemisphereRegions = cellfun(@(x) {x(1)}, {sGroups.Region})';
%             HemisphereFilter = strcmp(HemisphereIndexToTag(i), HemisphereRegions) == 1;
%             RowNames = [sGroups(HemisphereFilter).RowNames];
%             if (~isempty(RowNames))
%                 Index = ismember(aNames, RowNames);
%                 ChannelData(Index,3) = i;
%             end    
%         end
%         % Lobes
%         for i=1:NumberOfLobes
%             LobeRegions = cellfun(@(x) {x(2)}, {sGroups.Region})';
%             LobeFilter = strcmp(LobeIndexToTag(i), LobeRegions) == 1;
%             RowNames = [sGroups(LobeFilter).RowNames];
%             if (~isempty(RowNames))
%                 Index = ismember(aNames, RowNames);
%                 ChannelData(Index,2) = i;
%             end
%         end
%     end
%     % Lobe Regions
%     for i=1:NumberOfGroups
%         RowNames = [sGroups(i).RowNames];
%         if (~isempty(RowNames))
%             Index = ismember(aNames, RowNames);
%             ChannelData(Index,1) = i;
%         end
%     end
% end

%function BuildDisplayStatistics(hFig, sGroups)
%     RowNames = [sGroups.RowNames];
%     NumberOfMeasure = size(RowNames,1);
%     NumberOfRegion = size(sGroups,1);
%     
%     Hemispheres = [];
%     Lobes = [];
%     
%     RegionsSize = cellfun(@(x) {size(x,2)}, {sGroups.Region});
%     NumberOfLevel = max(RegionsSize) + 1;
%     if (NumberOfLevel > 0)
%         Hemispheres = unique(cellfun(@(x) {x(1)}, {sGroups.Region}));
%     end
%     if (NumberOfLevel > 1)
%         Lobes = unique(cellfun(@(x) {x(2)}, {sGroups.Region}));
%     end
%     
%     NumberOfLobes = size(Lobes,2);
%     NumberOfHemispheres = size(Hemispheres,2);
%end

%
% Experimental display, could be updated and used one day.
%
% function [Vertices Paths Names] = OrganiseNodesWithMeasureDensity(hFig, aNames, sGroups)
% 
%     % Display options
%     MeasureLevel = 4;
%     RegionLevel = 3.5;
%     LobeLevel = 2;
%     HemisphereLevel = 0.5;
% 
%     
%     RowNames = [sGroups.RowNames];    
%     Hemispheres = [];
%     Lobes = [];
%     
%     RegionsSize = cellfun(@(x) {size(x,2)}, {sGroups.Region});
%     % NumberOfLevel = Self + Middle + EverythingInBetween
%     NumberOfLevel = max([RegionsSize{:}]) + 2;
%     Levels = cell(NumberOfLevel,1);
%     if (NumberOfLevel > 0)
%         Levels{1} = cellfun(@(x) {x(1)}, {sGroups.Region});
%         Hemispheres = unique(Levels{1});
%     end
%     if (NumberOfLevel > 1)
%         Levels{2} = unique(cellfun(@(x) {x(2)}, {sGroups.Region}));
%         Lobes = unique(Levels{2});
%     end
%     
%     % Interior to Exterior
%     NumberOfEachLevel = zeros(NumberOfLevel,1);
%     NumberOfEachLevel(1) = 1;
%     NumberOfEachLevel(2) = size(Hemispheres,1);
%     NumberOfEachLevel(3) = size(Lobes,1) * 2;
%     NumberOfEachLevel(4) = size(sGroups,2);
%     NumberOfEachLevel(5) = size(RowNames,2);
%     
%     NumberOfAgregatingNodes = sum(NumberOfEachLevel(1:(end-1)));
%     NumberOfMeasureNodes = sum(NumberOfEachLevel(end));
%     NumberOfVertices = sum(NumberOfEachLevel);
%     Vertices = zeros(NumberOfVertices,3);
%     Names = cell(NumberOfVertices,1);
%     Paths = zeros(NumberOfVertices,NumberOfLevel);
%     
%     AngleStep = 360 / (NumberOfMeasureNodes + 2 * sum(NumberOfEachLevel(2:(end-1))));
% 
%     HemispheresChannels = cell(NumberOfEachLevel(2),1);
%     HemispheresPercent = zeros(NumberOfEachLevel(2),1);
%     for i=1:NumberOfEachLevel(2)
%         GroupsIndex = strcmp(LobeIndexToTag(i), Levels{1}) == 1;
%         HemispheresChannels{i} = [sGroups(GroupsIndex).RowNames];
%         HemispheresPercent(i) = size(HemispheresChannels{i},2) / NumberOfMeasureNodes;
%     end
%      
%     % Static Nodes
%     Vertices(1,:) = [0 0 0];                    % Corpus Callosum
%     Vertices(2,:) = [-HemisphereLevel 0 0];     % Left Hemisphere
%     Vertices(3,:) = [ HemisphereLevel 0 0];     % Right Hemisphere
%     Vertices(4,:) = [ 0 -HemisphereLevel 0];    % Cerebellum
%     Names(1) = {'Corpus Callosum'};
%     Names(2) = {'Left Hemisphere'};
%     Names(3) = {'Right Hemisphere'};
%     Names(4) = {'Cerebellum'};
% 
%     % The lobes are determined by the mean of the regions nodes
%     % The regions nodes are determined by the mean of their nodes
% 
%     % Organise Left Hemisphere
%     RegionIndex = 4 + NumberOfLobes * 2 + 1;
%     for i=1:NumberOfLobes
%         LobeIndex = i;
%         Angle = 90 + LobeSections(LobeIndex,1);
%         LobeTag = LobeIndexToTag(i);
%         HemisphereRegions
%         RegionMask = strcmp(LobeTag,LobeRegions) == 1 & strcmp('L',HemisphereRegions) == 1;
%         RegionNodeIndex = find(RegionMask == 1);
%         NumberOfRegionInLobe = sum(RegionMask);
%         for y=1:NumberOfRegionInLobe
%             Group = sGroups(RegionNodeIndex(y));
%             Region = [Group.Region];
%             NumberOfNodesInGroup = size([Group.RowNames],2);
%             % Figure out how much space per node
%             AllowedPercent = NumberOfNodesInGroup / NumberOfNodesPerLobe(LobeIndex);
%             LobeSpace = LobeSections(LobeIndex,2) - LobeSections(LobeIndex,1);
%             AllowedSpace = AllowedPercent * LobeSpace;
%             % +2 is for the offset at borders so regions don't touch
%             LocalTheta = linspace((pi/180) * (Angle), (pi/180) * (Angle + AllowedSpace), NumberOfNodesInGroup + 2);
%             % Retrieve cartesian coordinate
%             [posX,posY] = pol2cart(LocalTheta(2:end-1),1);
%             % Assign
%             ChannelsOfThisGroup = ismember(aNames, Group.RowNames);
%             % Compensate for agregating nodes
%             Index = find(ChannelsOfThisGroup) + NumberOfAgregatingNodes;
%             Vertices(Index, 1:2) = [posX' posY'] * MeasureLevel;
%             Names(Index) = aNames(ChannelsOfThisGroup);
%             % Update Paths
%             Paths(ChannelsOfThisGroup,1) = Index;
%             Paths(ChannelsOfThisGroup,2) = RegionIndex;
%             Paths(ChannelsOfThisGroup,3) = LobeIndex + 4;
%             Paths(ChannelsOfThisGroup,4) = 2;
%             Paths(ChannelsOfThisGroup,5) = 1;
%             % Update current angle
%             Angle = Angle + AllowedSpace;
%             % Update agregating node
%             Mean = mean([posX' posY']);
%             Mean = Mean / norm(Mean);
%             Vertices(RegionIndex, 1:2) = Mean * RegionLevel;
%             Names(RegionIndex) = {['Region ' Region(3:end)]};
%             RegionIndex = RegionIndex + 1;
%         end
%         
%         Pos = 90 + (LobeSections(LobeIndex,2) + LobeSections(LobeIndex,1)) / 2;
%         [posX,posY] = pol2cart((pi/180) * (Pos),1);
%         Vertices(i+4, 1:2) = [posX,posY] * LobeLevel;
%         Names(i+4) = {['Left ' LobeTag]};
%     end
% %     
% %     % Organise Right Hemisphere
% %     for i=1:NumberOfLobes
% %         LobeIndex = i;
% %         Angle = 90 - LobeSections(LobeIndex,1);
% %         LobeTag = LobeIndexToTag(i);
% %         RegionMask = strcmp(LobeTag,LobeRegions) == 1 & strcmp('R',HemisphereRegions) == 1;
% %         RegionNodeIndex = find(RegionMask == 1);
% %         NumberOfRegionInLobe = sum(RegionMask);
% %         for y=1:NumberOfRegionInLobe
% %             Group = sGroups(RegionNodeIndex(y));
% %             Region = [Group.Region];
% %             NumberOfNodesInGroup = size([Group.RowNames],2);
% %             % Figure out how much space per node
% %             AllowedPercent = NumberOfNodesInGroup / NumberOfNodesPerLobe(LobeIndex);
% %             LobeSpace = LobeSections(LobeIndex,2) - LobeSections(LobeIndex,1);
% %             AllowedSpace = AllowedPercent * LobeSpace;
% %             % +2 is for the offset at borders so regions don't touch        
% %             LocalTheta = linspace(deg2rad(Angle), deg2rad(Angle - AllowedSpace), NumberOfNodesInGroup + 2);
% %             % Retrieve cartesian coordinate
% %             [posX,posY] = pol2cart(LocalTheta(2:end-1),1);
% %             % Assign
% %             ChannelsOfThisGroup = ismember(aNames, Group.RowNames);
% %             % Compensate for agregating nodes
% %             Index = find(ChannelsOfThisGroup) + NumberOfAgregatingNodes;
% %             Vertices(Index, 1:2) = [posX' posY'] * MeasureLevel;
% %             Names(Index) = aNames(ChannelsOfThisGroup);
% %             % Update Paths
% %             Paths(ChannelsOfThisGroup,1) = Index;
% %             Paths(ChannelsOfThisGroup,2) = RegionIndex;
% %             Paths(ChannelsOfThisGroup,3) = NumberOfLobes + LobeIndex + 4;
% %             Paths(ChannelsOfThisGroup,4) = 3;
% %             Paths(ChannelsOfThisGroup,5) = 1;
% %             % Update current angle
% %             Angle = Angle - AllowedSpace;
% %             % Update agregating node
% %             Mean = mean([posX' posY']);
% %             Mean = Mean / norm(Mean);
% %             Vertices(RegionIndex, 1:2) = Mean * RegionLevel;
% %             Names(RegionIndex) = {['Region ' Region(3:end)]};
% %             RegionIndex = RegionIndex + 1;
% %         end
% %         
% %         Pos = 90 - (LobeSections(LobeIndex,2) + LobeSections(LobeIndex,1)) / 2;
% %         [posX,posY] = pol2cart(deg2rad(Pos),1);
% %         Vertices(i+NumberOfLobes+4, 1:2) = [posX,posY] * LobeLevel;
% %         Names(i+NumberOfLobes+4) = {['Right ' LobeTag]};
% %     end
% %     
% %     % Keep Structures Statistics
% %     AgregatingNodes = 1:NumberOfAgregatingNodes;
% %     MeasureNodes = NumberOfAgregatingNodes+1:NumberOfAgregatingNodes+NumberOfNodes;    
% %     bst_figures('SetFigureHandleField', hFig, 'AgregatingNodes', AgregatingNodes);
% %     bst_figures('SetFigureHandleField', hFig, 'MeasureNodes', MeasureNodes);
% 
% end

function [Vertices Paths Names] = OrganiseNodesWithConstantLobe(hFig, aNames, sGroups, RowLocs, UpdateStructureStatistics)

    % Display options
    MeasureLevel = 4;
    RegionLevel = 3.5;
    LobeLevel = 2.5;
    HemisphereLevel = 1.0;
    setappdata(hFig, 'MeasureLevelDistance', MeasureLevel);

    % Some values are Hardcoded for Display consistency
    NumberOfMeasureNodes = size(aNames,1);
    NumberOfGroups = size(sGroups,2);
    NumberOfLobes = 7;
    NumberOfHemispheres = 2;
    NumberOfLevels = 5;
        
    % Extract only the first region letter of each group
    HemisphereRegions = cellfun(@(x) {x(1)}, {sGroups.Region})';
    LobeRegions = cellfun(@(x) {LobeIndexToTag(LobeTagToIndex(x))}, {sGroups.Region})';
    
    LeftGroupsIndex = strcmp('L',HemisphereRegions) == 1;
    RightGroupsIndex = strcmp('R',HemisphereRegions) == 1;
    CerebellumGroupsIndex = strcmp('C',HemisphereRegions) == 1;
    UnknownGroupsIndex = strcmp('U',HemisphereRegions) == 1;
    
    % Angle allowed for each hemisphere
    AngleAllowed = [0 180];
    nCerebellum = sum(CerebellumGroupsIndex);
    if (nCerebellum > 0)
        % Constant size of 15% of circle allowed to Cerebellum
        AngleAllowed(2) = 180 - 15;
        NumberOfHemispheres = NumberOfHemispheres + 1;
    end
    
    nUnkown = sum(UnknownGroupsIndex);
    if (nUnkown > 0)
        % Constant size of 15% of circle allowed to Unknown
        AngleAllowed(1) = 15;
    end
    
    % NumberOfLevel = Self + Middle + EverythingInBetween
    Levels = cell(NumberOfLevels,1);
    Levels{5} = 1;
    Levels{4} = (2:(NumberOfHemispheres+1))';
    
    Lobes = [];
    NumberOfNodesPerLobe = zeros(NumberOfLobes * 2,1);
    for i=1:NumberOfLobes
        Tag = LobeIndexToTag(i);
        RegionsIndex = strcmp(Tag,LobeRegions) == 1;
        NodesInLeft = [sGroups(LeftGroupsIndex & RegionsIndex).RowNames];
        NodesInRight = [sGroups(RightGroupsIndex & RegionsIndex).RowNames];
        NumberOfNodesPerLobe(i) = length(NodesInLeft);
        NumberOfNodesPerLobe(NumberOfLobes + i) = length(NodesInRight);
        if (size(NodesInLeft,2) > 0 || size(NodesInRight,2) > 0)
            Lobes = [Lobes i];
        end
    end
    
    % Actual number of lobes with data
    NumberOfLobes = size(Lobes,2);
    
    % Start and end angle for each lobe section
    % We use a constant separation for each lobe
    AngleStep = (AngleAllowed(2) - AngleAllowed(1))/ NumberOfLobes;
    LobeSections = zeros(NumberOfLobes,2);
    LobeSections(:,1) = 0:NumberOfLobes-1;
    LobeSections(:,2) = 1:NumberOfLobes;
    LobeSections(:,:) = AngleAllowed(1) + LobeSections(:,:) * AngleStep;
    
    NumberOfAgregatingNodes = 1 + NumberOfHemispheres + NumberOfLobes * 2 + NumberOfGroups;
    NumberOfVertices = NumberOfMeasureNodes + NumberOfAgregatingNodes;
    Vertices = zeros(NumberOfVertices,3);
    Names = cell(NumberOfVertices,1);
    Paths = cell(NumberOfVertices,1);
    ChannelData = zeros(NumberOfVertices,3);
    
    % Static Nodes
    Vertices(1,:) = [0 0 0];                    % Corpus Callosum
    Vertices(2,:) = [-HemisphereLevel 0 0];     % Left Hemisphere
    Vertices(3,:) = [ HemisphereLevel 0 0];     % Right Hemisphere
    if (nCerebellum > 0)
        Vertices(4,:) = [ 0 -HemisphereLevel 0];    % Cerebellum
        Names(4) = {''};
        Paths{4} = [4 1];
        ChannelData(4,:) = [0 0 3];
    end
    Names(1) = {''};
    Names(2) = {'Left'};
    Names(3) = {'Right'};
    Paths{1} = 1;
    Paths{2} = [2 1];
    Paths{3} = [3 1];
    ChannelData(2,:) = [0 0 1];
    ChannelData(3,:) = [0 0 2];
    
    % The lobes are determined by the mean of the regions nodes
    % The regions nodes are determined by the mean of their nodes
    % Organise Left Hemisphere
    RegionIndex = 1 + NumberOfHemispheres + NumberOfLobes * 2 + 1;
    for i=1:NumberOfLobes
        Lobe = i;
        LobeIndex = Lobe + NumberOfHemispheres + 1;
        Levels{3} = [Levels{3}; LobeIndex];
        Angle = 90 + LobeSections(Lobe,1);
        LobeTag = LobeIndexToTag(Lobes(i));
        RegionMask = strcmp(LobeTag,LobeRegions) == 1 & strcmp('L',HemisphereRegions) == 1;
        RegionNodeIndex = find(RegionMask == 1);
        NumberOfRegionInLobe = sum(RegionMask);
        for y=1:NumberOfRegionInLobe
            Levels{2} = [Levels{2}; RegionIndex];
            Group = sGroups(RegionNodeIndex(y));
            Region = [Group.Region];
            NumberOfNodesInGroup = length([Group.RowNames]);
            if (NumberOfNodesInGroup > 0)
                % Figure out how much space per node
                AllowedPercent = NumberOfNodesInGroup / NumberOfNodesPerLobe(Lobes(i));
                LobeSpace = LobeSections(Lobe,2) - LobeSections(Lobe,1);
                AllowedSpace = AllowedPercent * LobeSpace;
                % +2 is for the offset at borders so regions don't touch        
                LocalTheta = linspace((pi/180) * (Angle), (pi/180) * (Angle + AllowedSpace), NumberOfNodesInGroup + 2);
                % Retrieve cartesian coordinate
                [posX,posY] = pol2cart(LocalTheta(2:(end-1)),1);
                % Assign
                ChannelsOfThisGroup = ismember(aNames, Group.RowNames);
                % Compensate for agregating nodes
                Index = find(ChannelsOfThisGroup) + NumberOfAgregatingNodes;
                % Update node information
                Order = 1:size(Index,1);
                if ~isempty(RowLocs)
                    [tmp, Order] = sort(RowLocs(ChannelsOfThisGroup,1), 'descend');
                end
                Vertices(Index(Order), 1:2) = [posX' posY'] * MeasureLevel;
                Names(Index) = aNames(ChannelsOfThisGroup);
                Paths(Index) = mat2cell([Index repmat([RegionIndex LobeIndex 2 1], size(Index))], ones(1,size(Index,1)), 5);
                ChannelData(Index,:) = repmat([RegionIndex Lobes(Lobe) 1], size(Index));
                Levels{1} = [Levels{1}; Index(Order)];
                % Update agregating node
                if (NumberOfNodesInGroup == 1)
                    Mean = [posX posY];
                else
                    Mean = mean([posX' posY']);
                end
                Mean = Mean / norm(Mean);
                Vertices(RegionIndex, 1:2) = Mean * RegionLevel;
                Names(RegionIndex) = {ExtractSubRegion(Region)};
                Paths(RegionIndex) = {[RegionIndex LobeIndex 2 1]};
                ChannelData(RegionIndex,:) = [RegionIndex Lobes(Lobe) 1];
                % Update current angle
                Angle = Angle + AllowedSpace;
            end
            RegionIndex = RegionIndex + 1;
        end
        
        Pos = 90 + (LobeSections(Lobe,2) + LobeSections(Lobe,1)) / 2;
        [posX,posY] = pol2cart((pi/180) * (Pos),1);
        Vertices(LobeIndex, 1:2) = [posX,posY] * LobeLevel;
        Names(LobeIndex) = {LobeTag};
        Paths(LobeIndex) = {[LobeIndex 2 1]};
        ChannelData(LobeIndex,:) = [0 Lobes(Lobe) 1];
    end
    
    % Organise Right Hemisphere
    for i=1:NumberOfLobes
        Lobe = i;
        LobeIndex = Lobe + NumberOfLobes + NumberOfHemispheres + 1;
        Levels{3} = [Levels{3}; LobeIndex];
        Angle = 90 - LobeSections(Lobe,1);
        LobeTag = LobeIndexToTag(Lobes(i));
        RegionMask = strcmp(LobeTag,LobeRegions) == 1 & strcmp('R',HemisphereRegions) == 1;
        RegionNodeIndex = find(RegionMask == 1);
        NumberOfRegionInLobe = sum(RegionMask);
        for y=1:NumberOfRegionInLobe
            Levels{2} = [Levels{2}; RegionIndex];
            Group = sGroups(RegionNodeIndex(y));
            Region = [Group.Region];
            NumberOfNodesInGroup = length([Group.RowNames]);
            if (NumberOfNodesInGroup > 0)
                % Figure out how much space per node
                AllowedPercent = NumberOfNodesInGroup / NumberOfNodesPerLobe(Lobes(i) + 7);
                LobeSpace = LobeSections(Lobe,2) - LobeSections(Lobe,1);
                AllowedSpace = AllowedPercent * LobeSpace;
                % +2 is for the offset at borders so regions don't touch        
                LocalTheta = linspace((pi/180) * (Angle), (pi/180) * (Angle - AllowedSpace), NumberOfNodesInGroup + 2);
                % Retrieve cartesian coordinate
                [posX,posY] = pol2cart(LocalTheta(2:(end-1)),1);
                % Assign
                ChannelsOfThisGroup = ismember(aNames, Group.RowNames);
                % Compensate for agregating nodes
                Index = find(ChannelsOfThisGroup) + NumberOfAgregatingNodes;
                % Update node information
                Order = 1:size(Index,1);
                if ~isempty(RowLocs)
                    [tmp, Order] = sort(RowLocs(ChannelsOfThisGroup,1), 'descend');
                end
                Vertices(Index(Order), 1:2) = [posX' posY'] * MeasureLevel;
                Names(Index) = aNames(ChannelsOfThisGroup);
                Paths(Index) = mat2cell([Index repmat([RegionIndex LobeIndex 3 1], size(Index))], ones(1,size(Index,1)), 5);
                ChannelData(Index,:) = repmat([RegionIndex Lobes(Lobe) 2], size(Index));
                Levels{1} = [Levels{1}; Index(Order)];
                % Update agregating node
                if (NumberOfNodesInGroup == 1)
                    Mean = [posX posY];
                else
                    Mean = mean([posX' posY']);
                end
                Mean = Mean / norm(Mean);
                Vertices(RegionIndex, 1:2) = Mean * RegionLevel;
                Names(RegionIndex) = {ExtractSubRegion(Region)};
                Paths(RegionIndex) = {[RegionIndex LobeIndex 3 1]};
                ChannelData(RegionIndex,:) = [RegionIndex Lobes(Lobe) 2];
                % Update current angle
                Angle = Angle - AllowedSpace;
            end
            RegionIndex = RegionIndex + 1;
        end
        
        Pos = 90 - (LobeSections(Lobe,2) + LobeSections(Lobe,1)) / 2;
        [posX,posY] = pol2cart((pi/180) * (Pos),1);
        Vertices(LobeIndex, 1:2) = [posX,posY] * LobeLevel;
        Names(LobeIndex) = {LobeTag};
        Paths(LobeIndex) = {[LobeIndex 3 1]};
        ChannelData(LobeIndex,:) = [0 Lobes(Lobe) 2];
    end
    
    % Organise Cerebellum
    if (nCerebellum > 0)
        Angle = 270 - 15;
        NodesInCerebellum = [sGroups(CerebellumGroupsIndex).RowNames];
        NumberOfNodesInCerebellum = size(NodesInCerebellum,2);
        RegionMask = strcmp('C',HemisphereRegions) == 1;
        RegionNodeIndex = find(RegionMask == 1);
        NumberOfRegionInCerebellum = sum(RegionMask);
        for y=1:NumberOfRegionInCerebellum
            Levels{2} = [Levels{2}; RegionIndex];
            Group = sGroups(RegionNodeIndex(y));
            Region = [Group.Region];
            NumberOfNodesInGroup = length([Group.RowNames]);
            if (NumberOfNodesInGroup > 0)
                % Figure out how much space per node
                AllowedPercent = NumberOfNodesInGroup / NumberOfNodesInCerebellum;
                % Static for Cerebellum
                LobeSpace = 30;
                AllowedSpace = AllowedPercent * LobeSpace;
                % +2 is for the offset at borders so regions don't touch        
                LocalTheta = linspace((pi/180) * (Angle), (pi/180) * (Angle + AllowedSpace), NumberOfNodesInGroup + 2);
                % Retrieve cartesian coordinate
                [posX,posY] = pol2cart(LocalTheta(2:(end-1)),1);
                % Assign
                ChannelsOfThisGroup = ismember(aNames, Group.RowNames);
                % Compensate for agregating nodes
                Index = find(ChannelsOfThisGroup) + NumberOfAgregatingNodes;
                Order = 1:size(Index,1);
                if ~isempty(RowLocs)
                    [tmp, Order] = sort(RowLocs(ChannelsOfThisGroup,1), 'descend');
                end
                Vertices(Index(Order), 1:2) = [posX' posY'] * MeasureLevel;
                Names(Index) = aNames(ChannelsOfThisGroup);
                Paths(Index) = mat2cell([Index repmat([RegionIndex 4 1 1], size(Index))], ones(1,size(Index,1)), 5);
                ChannelData(Index,:) = repmat([RegionIndex 0 0], size(Index));
                Levels{1} = [Levels{1}; Index];
                % Update agregating node
                if (NumberOfNodesInGroup == 1)
                    Mean = [posX posY];
                else
                    Mean = mean([posX' posY']);
                end
                Mean = Mean / norm(Mean);
                Vertices(RegionIndex, 1:2) = Mean * RegionLevel;
                Names(RegionIndex) = {ExtractSubRegion(Region)};
                Paths(RegionIndex) = {[RegionIndex 4 1 1]};
                ChannelData(RegionIndex,:) = [RegionIndex 0 0];
                % Update current angle
                Angle = Angle + AllowedSpace;
            end
            RegionIndex = RegionIndex + 1;
        end
    end
    
    % Organise Unknown...
    if (nUnkown > 0)
        Angle = 90 - 15;
        NodesInUnknown = [sGroups(UnknownGroupsIndex).RowNames];
        NumberOfNodesInUnknown = size(NodesInUnknown,2);
        RegionMask = strcmp('U',HemisphereRegions) == 1;
        RegionNodeIndex = find(RegionMask == 1);
        NumberOfRegionInUnknown = sum(RegionMask);
        for y=1:NumberOfRegionInUnknown
            Levels{2} = [Levels{2}; RegionIndex];
            Group = sGroups(RegionNodeIndex(y));
            Region = [Group.Region];
            NumberOfNodesInGroup = size([Group.RowNames],2);
            if (NumberOfNodesInGroup > 0)
                % Figure out how much space per node
                AllowedPercent = NumberOfNodesInGroup / NumberOfNodesInUnknown;
                % Static for Cerebellum
                LobeSpace = 30;
                AllowedSpace = AllowedPercent * LobeSpace;
                % +2 is for the offset at borders so regions don't touch        
                LocalTheta = linspace((pi/180) * (Angle), (pi/180) * (Angle + AllowedSpace), NumberOfNodesInGroup + 2);
                % Retrieve cartesian coordinate
                [posX,posY] = pol2cart(LocalTheta(2:(end-1)),1);
                % Assign
                ChannelsOfThisGroup = ismember(aNames, Group.RowNames);
                % Compensate for agregating nodes
                Index = find(ChannelsOfThisGroup) + NumberOfAgregatingNodes;
                Order = 1:size(Index,1);
                if ~isempty(RowLocs)
                    [tmp, Order] = sort(RowLocs(ChannelsOfThisGroup,1), 'descend');
                end
                Vertices(Index(Order), 1:2) = [posX' posY'] * MeasureLevel;
                Names(Index) = aNames(ChannelsOfThisGroup);
                Paths(Index) = mat2cell([Index repmat([RegionIndex 1 1 1], size(Index))], ones(1,size(Index,1)), 5);
                ChannelData(Index,:) = repmat([RegionIndex 0 0], size(Index));
                Levels{1} = [Levels{1}; Index];
                % Update agregating node
                if (NumberOfNodesInGroup == 1)
                    Mean = [posX posY];
                else
                    Mean = mean([posX' posY']);
                end
                Mean = Mean / norm(Mean);
                Vertices(RegionIndex, 1:2) = Mean * RegionLevel;
                Names(RegionIndex) = {ExtractSubRegion(Region)};
                Paths(RegionIndex) = {[RegionIndex 1 1 1]};
                ChannelData(RegionIndex,:) = [RegionIndex 0 0];
                % Update current angle
                Angle = Angle + AllowedSpace;
            end
            RegionIndex = RegionIndex + 1;
        end
    end
    
    
%     if (nCerebellum > 0)
%         CereHem = ChannelData(:,2) == 4;
%         Vertices(CereHem,2) = Vertices(CereHem,2) * 1.2;
%     end
%     
%     if (nUnkown > 0)
%         Unknown = ChannelData(:,3) == 0;
%         Vertices(Unknown,2) = Vertices(Unknown,2) * 1.2;
%     end
%     
%     %Prototype: Empirical values for a more oval/head-like shape
%     LeftHem = ChannelData(:,3) == 1;
%     RightHem = ChannelData(:,3) == 2;
%     Vertices(LeftHem,1) = Vertices(LeftHem,1) - 0.6;
%     Vertices(LeftHem,2) = Vertices(LeftHem,2) * 1.2;
% 	  Vertices(RightHem,1) = Vertices(RightHem,1) + 0.6;
%     Vertices(RightHem,2) = Vertices(RightHem,2) * 1.2;
    
    if (~isempty(UpdateStructureStatistics) && UpdateStructureStatistics == 1)
        % Keep Structures Statistics
        bst_figures('SetFigureHandleField', hFig, 'AgregatingNodes', 1:NumberOfAgregatingNodes);
        bst_figures('SetFigureHandleField', hFig, 'MeasureNodes', (NumberOfAgregatingNodes + 1):(NumberOfAgregatingNodes + NumberOfMeasureNodes));
        % Levels information
        bst_figures('SetFigureHandleField', hFig, 'NumberOfLevels', NumberOfLevels);
        bst_figures('SetFigureHandleField', hFig, 'Levels', Levels);
        % Node hierarchy data
        bst_figures('SetFigureHandleField', hFig, 'ChannelData', ChannelData);
    end
end


function [Vertices Paths Names] = OrganiseNodeInCircle(hFig, aNames, sGroups)
    % Display options
    MeasureLevel = 4;
    RegionLevel = 2;

    NumberOfMeasureNodes = size(aNames,1);
    NumberOfGroups = size(sGroups,2);
    NumberOfAgregatingNodes = 1;
        
    NumberOfLevels = 2;
    if (NumberOfGroups > 1)
        NumberOfLevels = 3;
        NumberOfAgregatingNodes = NumberOfAgregatingNodes + NumberOfGroups;
    end
    % NumberOfLevel = Self + Middle + EverythingInBetween
    Levels = cell(NumberOfLevels,1);
    Levels{end} = 1;
    
    NumberOfVertices = NumberOfMeasureNodes + NumberOfAgregatingNodes;
    
    % Structure for vertices
    Vertices = zeros(NumberOfVertices,3);
    Names = cell(NumberOfVertices,1);
    Paths = cell(NumberOfVertices,1);
    
    % Static node
    Vertices(1,1:2) = [0 0];
    Names{1} = ' ';
    Paths{1} = 1;
    
    NumberOfNodesInGroup = zeros(NumberOfGroups,1);
    GroupsTheta = zeros(NumberOfGroups,1);
    GroupsTheta(1,1) = (pi * 0.5);
    for i=1:NumberOfGroups
        if (i ~= 1)
            GroupsTheta(i,1) = GroupsTheta(i-1,2);
        end
        NumberOfNodesInGroup(i) = 1;
        if (iscellstr(sGroups(i).RowNames))
            NumberOfNodesInGroup(i) = size(sGroups(i).RowNames,2);
        end
        Theta = (NumberOfNodesInGroup(i) / NumberOfMeasureNodes * (2 * pi));
        GroupsTheta(i,2) = GroupsTheta(i,1) + Theta;
    end
        
    for i=1:NumberOfGroups
        LocalTheta = linspace(GroupsTheta(i,1), GroupsTheta(i,2), NumberOfNodesInGroup(i) + 1);
        ChannelsOfThisGroup = ismember(aNames, sGroups(i).RowNames);
        Index = find(ChannelsOfThisGroup) + NumberOfAgregatingNodes;
        [posX,posY] = pol2cart(LocalTheta(2:end),1);
        Vertices(Index,1:2) = [posX' posY'] * MeasureLevel;
        Names(Index) = sGroups(i).RowNames;
        Paths(Index) = mat2cell([Index repmat(1, size(Index))], ones(1,size(Index,1)), 2);
        Levels{1} = [Levels{1}; Index];
        
        if (NumberOfLevels > 2)
            RegionIndex = i + 1;
            Paths(Index) = mat2cell([Index repmat([RegionIndex 1], size(Index))], ones(1,size(Index,1)), 3);
            
            % Update agregating node
            if (NumberOfNodesInGroup(i) == 1)
                Mean = [posX posY];
            else
                Mean = mean([posX' posY']);
            end
            Mean = Mean / norm(Mean);
            Vertices(RegionIndex,1:2) = Mean * RegionLevel;
            Names(RegionIndex) = {['Region ' num2str(i)]};
            Paths(RegionIndex) = {[RegionIndex 1]};
            Levels{2} = [Levels{2}; RegionIndex];
        end
    end
    
    % Keep Structures Statistics
    AgregatingNodes = 1:NumberOfAgregatingNodes;
    MeasureNodes = NumberOfAgregatingNodes+1:NumberOfAgregatingNodes+NumberOfMeasureNodes;    
    bst_figures('SetFigureHandleField', hFig, 'AgregatingNodes', AgregatingNodes);
    bst_figures('SetFigureHandleField', hFig, 'MeasureNodes', MeasureNodes);
    % 
    bst_figures('SetFigureHandleField', hFig, 'NumberOfLevels', NumberOfLevels);
    %
    bst_figures('SetFigureHandleField', hFig, 'Levels', Levels);
end


function Vertices = ReorganiseNodeAroundInCircle(hFig, sGroups, aNames, Level)

    Paths = bst_figures('GetFigureHandleField', hFig, 'NodePaths');
    nVertices = size(bst_figures('GetFigureHandleField', hFig, 'Vertices'), 1);
    Vertices = zeros(nVertices,3);
    Vertices(:,3) = -5;
    
    DisplayLevel = 4:-(4/(Level-1)):0;
    
    NumberOfMeasureNodes = length([sGroups.RowNames]);
    NumberOfGroups = length(sGroups);
    
    NumberOfAgregatingNodes = length(bst_figures('GetFigureHandleField', hFig, 'AgregatingNodes'));
    
    NumberOfNodesInGroup = zeros(NumberOfGroups,1);
    GroupsTheta = zeros(NumberOfGroups,1);
    GroupsTheta(1,1) = (pi * 0.5);
    for i=1:NumberOfGroups
        if (i ~= 1)
            GroupsTheta(i,1) = GroupsTheta(i-1,2);
        end
        NumberOfNodesInGroup(i) = 1;
        if (iscellstr(sGroups(i).RowNames))
            NumberOfNodesInGroup(i) = length(sGroups(i).RowNames);
        end
        Theta = (NumberOfNodesInGroup(i) / NumberOfMeasureNodes * (2 * pi));
        GroupsTheta(i,2) = GroupsTheta(i,1) + Theta;
    end
    
    for i=1:NumberOfGroups
        LocalTheta = linspace(GroupsTheta(i,1), GroupsTheta(i,2), NumberOfNodesInGroup(i) + 2);
        ChannelsOfThisGroup = ismember(aNames, sGroups(i).RowNames);
        Index = find(ChannelsOfThisGroup) + NumberOfAgregatingNodes;
        [posX,posY] = pol2cart(LocalTheta(2:end-1),1);
        Vertices(Index,1:2) = [posX' posY'] * DisplayLevel(1);
        Vertices(Index,3) = 0;
        
        for y=2:Level
            Path = Paths{Index(1)};
            RegionIndex = Path(y);
            if (NumberOfNodesInGroup(i) == 1)
                Mean = [posX posY];
            else
                Mean = mean([posX' posY']);
            end
            Mean = Mean / norm(Mean);
            Vertices(RegionIndex,1:2) = Mean * DisplayLevel(y);
            Vertices(RegionIndex,3) = 0;
        end
    end
end
